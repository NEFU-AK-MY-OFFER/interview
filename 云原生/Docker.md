# Docker

[40. 面试题汇总_牛客网 (nowcoder.com)](https://www.nowcoder.com/discuss/490850490599608320?sourceSSR=search)

## 1. 什么是 Docker？有什么优点？

Docker 是一种容器化技术，它可以将应用程序及其依赖项封装为一个独立的容器中。Docker 的优点包括：

- 将应用对应的系统配置和SDK依赖打包成一个镜像文件，在环境上直接通过镜像创建容器并运行，简化了应用程序的部署过程；
- 提供了轻量级的虚拟化，只需要将应用对应的系统配置和SDK依赖打包成一个镜像文件，而不需要一个完整的操作系统，避免了虚拟机带来的额外开销；
- 可以更好地管理不同应用程序之间的依赖关系和版本，因为镜像可以有不同的版本，通过 `docker images` 来管理；
- 更容易迁移和扩展应用程序，这就是镜像文件的好处；
- 可以更好地保证应用程序在不同环境中的一致性，这就是镜像文件的好处。

## 2. Docker 的基本组件有哪些？

1. 服务端 Docker 进程（Server Docker Daemon）：负责管理 Docker 容器和镜像；处理客户端的请求，并执行相应的操作。
2. API 接口（REST API）：为 Docker 客户端提供与服务端 Docker daemon 交互的接口。
3. Docker 客户端命令行（Client Docker CLI）：允许用户与服务端 Docker daemon 交互，客户端发送的一系列请求，例如运行容器、构建镜像等操作，将最终由服务端 Docker daemon 来执行。
4. Docker 镜像（Images）：是一个轻量级、可执行的软件包，其中包含了运行应用程序所需的所有代码、库、配置文件等。容器镜像可以通过运行容器来启动，容器会使用镜像创建一个独立的运行环境，包含容器镜像中的所有文件和依赖项。
5. Docker 容器（Containers）：是 Docker 中的运行时实体，包含了应用程序及其依赖关系，可以被启动、停止、重启、删除等操作。
6. Docker 网络（Networks）：允许容器之间进行通信，并提供网络隔离、端口映射等功能。
7. Docker 存储（Data Volumes）：提供容器内部数据的持久化存储功能，包括数据卷、本地文件系统、网络存储等。

## 3. Docker 镜像是如何创建的？如何分享 Docker 镜像？

Docker 镜像可以通过 Dockerfile 文件创建，Dockerfile 文件描述了如何构建 Docker 镜像，包括基础镜像、应用程序代码、运行环境等。在 Dockerfile 文件所在的目录下，使用 `docker build` 命令可以构建 Docker 镜像。

要分享 Docker 镜像，可以将其推送到 Docker Hub 或者其他 Docker 镜像仓库中。使用 `docker tag` 命令可以给镜像打上标签，然后使用 `docker push` 命令将镜像推送到仓库中。别人在使用时通过 `docker pull` 拉取镜像。

## 4. Docker 镜像和容器的区别是什么？

1. 镜像是一个只读的模板，用于创建 Docker 容器。镜像可以看作是一个容器的静态版本，包括应用程序代码、运行环境、依赖项等。镜像通常是由 Dockerfile 或者从其他镜像派生而来，可以通过 Docker Hub 或者本地仓库获取。
2. 容器是由 Docker 镜像创建而来的可运行实例，包括应用程序的运行状态、环境变量等信息。容器可以看作是一个镜像的运行时实例，它可以被启动、停止、删除等。容器通常是基于镜像创建的，并且容器的变化不会影响镜像。

可以简单地将 Docker 镜像看作是容器的模板，而容器是基于该模板创建出来的实例。

## 5. 说说 Docker 常用命令

- docker run：运行一个新的容器。
- docker start：启动一个已停止的容器。
- docker stop：停止一个正在运行的容器。
- docker ps：列出当前正在运行的容器。
- docker images：列出本地镜像。
- docker build：使用 Dockerfile 构建一个新的镜像。
- docker exec：在运行中的容器中执行命令。
- docker rm：删除一个或多个容器。
- docker rmi：删除一个或多个本地镜像。
- docker network：管理 Docker 网络。

## 6. Docker 与传统虚拟机的区别什么？

资源占用：传统虚拟机需要在硬件上模拟一整套操作系统，因此每个虚拟机都需要占用大量的内存和存储空间。而 Docker 则共享主机操作系统的内核，并且只需要在容器中运行应用程序及其依赖的库，因此相比之下更加轻量级，资源占用更少。

1. 启动速度：由于传统虚拟机需要启动整个操作系统，因此启动速度通常较慢。而 Docker 采用了一种基于镜像的启动方式，可以秒级快速地启动和停止容器。
2. 部署和管理：传统虚拟机需要管理整个虚拟机，包括操作系统、安装和更新软件等，部署要安装完整操作系统和软件；而 Docker 更加简单，只需要管理容器本身即可，包括镜像、容器运行状态等。同时 Docker 将应用对应的系统配置和SDK依赖打包成一个镜像文件，在环境上直接通过镜像创建容器并运行，简化了应用程序的部署过程。
3. 移植与扩展程序：Docker 更容易迁移和扩展应用程序，通过将应用对应的系统配置和 SDK 依赖打包成一个镜像文件，上传到镜像仓库，可以在测试、生产环境中直接通过镜像创建容器并运行。
4. 资源隔离：Docker 可以更好地管理不同应用程序之间的依赖关系和版本，docker 可以同时运行多个版本的应用，不同版本的容器可以有效资源隔离；而虚拟机则较难处理多个版本应用同时运行，可能存在配置冲突、环境污染。

## 7. 什么是 Docker 镜像分层？

Docker 将一个 Docker 镜像分解成多个不同的层（Layer），个层都是只读的文件系统，层与层之间是相互独立的。这种分层的设计可以提高 Docker 镜像的复用性和共享性。每个 Docker 镜像都是由一个或多个只读层（镜像层）和一个可读写层（容器层）组成。只读层是可以在不同镜像之间共享的，因此 Docker 的镜像可以通过利用这种分层的设计来尽可能地减少重复的数据存储，提高镜像的复用性。同时，Docker 镜像分层的设计还可以方便地管理和维护镜像。例如，在更新镜像时，只需要修改镜像的某个层，而不需要对整个镜像重新构建，从而节省了时间和资源。



## 8. Docker 镜像分层的优势是什么？

1. 减小镜像大小：因为每个层都是只读的，所以在创建新镜像时，只需要新增或修改一层即可，不会影响到已有的层，从而减小了镜像的大小。同时，不同的镜像可以共享相同的层，从而减少了重复的数据存储，进一步减小了镜像的大小。
2. 提高镜像的复用性：由于Docker镜像分层的设计，不同的镜像可以共享相同的层，这就使得镜像的复用性得到了极大地提高。例如，当多个容器需要使用同一份镜像时，它们可以共享相同的只读层，这样就可以节省存储空间，并且不需要重复下载和构建镜像。
3. 方便镜像的管理和维护：由于每个层都可以单独更新和管理，因此 Docker 镜像的管理和维护变得更加容易。例如，在更新镜像时，只需要修改镜像的某个层，而不需要对整个镜像重新构建，这样就可以节省时间和资源，并且降低出错的风险。
4. 提高镜像的构建效率：利用 Docker 镜像分层的特性，可以将常用的层缓存下来，从而减少重复的构建过程，加快镜像构建的速度。同时，通过多阶段构建的方式，将构建过程拆分成多个阶段，每个阶段都可以利用不同的Docker镜像分层，从而进一步提高构建速度。

## 9. Docker 镜像的分层是如何实现的？

Docker 镜像分层的实现是通过 UFS（Union File System）合文件系统来实现的。**联合文件系统（Union File System）是一种将多个文件系统挂载到同一目录下的技术，使得这些文件系统中的内容可以像一个文件系统一样被访问**。在联合文件系统中，多个不同的文件系统以层次结构的形式被组织在一起，从而使得用户可以通过单一的挂载点来访问多个不同的文件系统。

在 Docker 中，每个镜像都是由多个只读层（镜像层）和一个可读写层（容器层）组成。Docker 通过 UFS 联合文件系统将这些只读层和可读写层合并在一起，形成一个联合文件系统。

## 10. 如何利用 Docker 镜像分层优化镜像构建过程？

利用 Docker 镜像分层优化镜像构建过程可以从以下几个方面入手：

1. 利用缓存：在构建 Docker 镜像时，Docker 会利用缓存来避免重复的构建过程。如果某个镜像层已经被构建过，Docker 就可以直接从缓存中获取该层，从而加快构建速度。因此，为了利用缓存，我们应该尽量减少构建过程中的变化，例如在 Dockerfile 中将不经常修改的指令放在前面，将经常修改的指令放在后面。
2. 利用多阶段构建：Docker 从 17.05 版本开始支持多阶段构建。利用多阶段构建，可以将构建过程拆分成多个阶段，并在每个阶段中利用不同的 Docker 镜像分层，从而减少重复的构建过程。
3. 选择合适的基础镜像：选择合适的基础镜像可以减少构建过程中的变化，从而提高构建速度。通常情况下，我们应该选择官方的基础镜像，因为官方的基础镜像已经被优化过，同时也得到了广泛的测试和验证。
4. 减小镜像大小：减小镜像大小可以加快构建速度，同时也可以减少存储空间的占用。为了减小镜像大小，我们可以采用一些常用的优化技巧，例如将多个指令合并成一个、使用多阶段构建、删除无用文件和缓存等。

## 11. 镜像层是可写的吗？怎么实现可写

Docker 镜像层是只读的，这是为了保证镜像的不可变性，也就是说，一个镜像被创建之后，它的每一层都是只读的，不能被修改。这样可以保证每个容器都以相同的镜像层为基础，从而保证容器之间的环境一致性。

然而，在有些情况下，我们需要对容器进行一些修改，例如安装软件、修改配置文件等。此时，我们可以通过在容器层上创建一个新的可写层来实现这个目的。Docker 中的可写层也称为容器层（container layer）或工作层（working layer），它是在只读的镜像层之上创建的一个可写层。

**当我们启动一个容器时，Docker 会在镜像层之上创建一个可写层，并将这个可写层挂载到容器的文件系统中**。容器层中的所有修改都将保存在这个可写层中，而镜像层则保持不变。这样，即使多个容器都使用同一个镜像，它们之间也可以有不同的可写层。

## 12. Docker 中基础镜像的作用

Docker 中基础镜像是用来构建 Docker 镜像的基础，也是构建整个 Docker 镜像的起点。它是一个只读的文件系统，包含了一些基本的操作系统和软件组件，例如操作系统内核、文件系统、运行时环境、库文件、工具等。

使用基础镜像可以避免从头开始构建 Docker 镜像，从而节省时间和精力。基础镜像已经被优化过，并且得到了广泛的测试和验证，因此可以保证镜像的稳定性和可靠性。

## 13. 容器层删除文件时，文件本体会被删除吗？

当容器层中的文件被删除时，文件本体不会被删除，因为容器层是一个可写层，它是在只读的镜像层之上创建的一个可写层，容器层中的所有修改都将保存在这个可写层中，而镜像层则保持不变。因此，当容器中的文件被删除时，实际上是删除了容器层中的文件记录，而不是删除了镜像层中的文件本体。

## 14. centos 镜像几个 G，但是 docker

这是因为 CentOS 镜像是完整的操作系统镜像，包含了所有的软件包和文件，而 Docker 镜像则是基于操作系统的一层层的增量更新，每一层都只包含一个或几个操作，可以共用基础镜像，因此其大小较小。

## 15. 讲一下镜像的分层结构以及为什么要使用镜像的分层结构？

一个新的镜像其实是从基础镜像一层一层叠加生成的。每安装一个软件，dockerfile 中使用 RUM 命令，就会在现有镜像的基础上增加一层，这样一层一层的叠加最后构成整个镜像。

分层结构最大的一个好处就是：共享资源。比如：有多个镜像都从相同的基础镜像构建而来，那么只需在磁盘上保存一份基础镜像；同时内存中也只需加载一份基础镜像，就可以为所有容器服务了。而且镜像的每一层都可以被共享。

## 16. 说说容器 Copy-on-Write(COW) 特性

容器 Copy-on-Write (COW) 特性是 Docker 中非常重要的一个特性。它的作用是让容器创建时尽可能地复用镜像层，从而节省存储空间并提高容器的创建速度。

当一个容器启动时，**Docker 会创建一个容器层作为容器的可写层，并将该容器层与镜像层进行联合挂载**。在容器运行时，所有的写操作都会被记录到容器层中，而**不会对镜像层进行任何修改**。因此，如果多个容器都使用同一个镜像，它们会共享相同的镜像层，而容器层则会针对每个容器单独记录写入操作。这种方式可以避免重复复制相同的数据，从而提高存储效率，并且能够更快地启动新的容器。

**当容器层中的文件被修改时，Docker 会使用 Copy-on-Write (COW) 技术来创建新的文件副本，而不是在原始镜像层上直接修改文件**。这意味着对文件的修改不会影响其他容器或镜像的使用，同时也能够更好地支持多个容器同时使用同一个镜像的场景。



## 17. 什么是 Dockerfile？它有什么作用？

Dockerfile 是一个包含用于构建 Docker 镜像的命令和指令的文本文件。它定义了镜像中包含的操作系统、应用程序、配置文件等组件，以及如何将它们组合在一起以创建可重复的 Docker 镜像。Dockerfile 的作用是提供一个自动化的镜像构建过程，通过在 Dockerfile 中定义的命令和参数，自动化地创建和配置 Docker 镜像，从而实现快速、可重复、可移植的应用部署。



## 18. Dockerfile 中的 FROM 命令的作用是什么？

FROM 命令指定了用于构建 Docker 镜像的基础镜像。这是 Dockerfile 中最重要的命令之一，因为它确定了容器的基础操作系统和运行时环境。

## 19. 如何在 Dockerfile 中安装应用程序和依赖项？

可以使用 RUN 命令在 Dockerfile 中安装应用程序和依赖项。RUN 命令允许在容器中运行任意的命令和脚本，例如在 Ubuntu 中使用 apt-get 安装软件包，在 Python 中使用 pip 安装 Python 包等。

## 20. 如何将本地文件复制到 Docker 镜像中？

可以使用 COPY 命令将本地文件复制到 Docker 镜像中。COPY 命令可以将本地文件或目录复制到 Docker 镜像中的指定位置。

## 21. 如何在 Dockerfile 中设置环境变量？

可以使用 ENV 命令在 Dockerfile 中设置环境变量。ENV 命令可以将一个或多个环境变量设置为指定的值。

## 22. 如何在 Dockerfile 中暴露端口？

可以使用 EXPOSE 命令在 Dockerfile 中暴露容器的端口。EXPOSE 命令告诉 Docker，容器将监听指定的端口，但并不会自动将它们映射到主机上的端口。

## 23. 如何在 Dockerfile 中使用多条命令来构建一个镜像？

可以在 Dockerfile 中使用多个 RUN 命令来构建一个镜像。每个 RUN 命令将在容器中执行一个命令或脚本，从而逐步构建镜像。

**需要注意的是，每个 RUN 命令都会在镜像中创建一个新的中间层。如果需要多次执行命令，可以将多个命令组合到一起，以减少镜像的层数**。例如，可以使用以下命令来替代上面的 Dockerfile：

```
FROM ubuntu:18.04

RUN apt-get update && \
    apt-get install -y \
    python3 \
    git
```

## 24. Dockerfile 中的 CMD 和 ENTRYPOINT 命令有什么区别？

1. CMD 命令定义了容器启动时默认执行的命令，如果在运行容器时指定了其他命令，则会覆盖 CMD 命令。CMD 命令可以在 Dockerfile 文件中多次出现，但只有最后一个会生效。如果 CMD 命令需要参数，可以在命令后面指定，例如 `CMD ["executable", "param1", "param2"]`。
2. ENTRYPOINT 命令也定义了容器启动时要执行的命令，但是不会被覆盖。ENTRYPOINT 命令也可以在 Dockerfile 文件中多次出现，但只有最后一个会生效。如果需要在运行容器时指定其他命令，可以在 ENTRYPOINT 命令后面使用 CMD 命令提供参数，例如 `ENTRYPOINT ["executable", "param1"]` 和 `CMD ["param2"]`。

## 25. Dockerfile 中的 COPY 和 ADD

在 Dockerfile 中，COPY 和 ADD 命令都可以用于将本地文件或目录复制到 Docker 镜像中，但是它们在一些细节上有所不同：

1. COPY 命令只能复制本地文件或目录，而 ADD 命令支持复制本地文件或目录，还可以从 URL 或 tar 归档文件中提取文件。
2. ADD 命令在复制文件时还支持自动解压缩 tar 归档文件，这使得 ADD 命令更加灵活，但也增加了镜像大小。
3. ADD 命令还支持在复制文件时进行权限更改、归档校验和和文件的远程复制等功能，但这些功能可能会增加 Docker 镜像构建的时间和复杂性。
4. COPY 命令比 ADD 命令更加简单和透明，它不会执行任何自动化操作，因此在大多数情况下，COPY 命令比 ADD 命令更受推荐。

## 26. Dockerfile 常用命令

- FROM：指定基础镜像，格式为 FROM image:tag。
- RUN：在容器中执行命令，格式为 RUN command。
- COPY：将本地文件或目录复制到容器中，格式为 COPY source destination。
- ADD：将本地文件或目录复制到容器中，并支持从URL或tar归档文件中提取文件，格式为 ADD source destination。
- WORKDIR：设置工作目录，格式为 WORKDIR path。
- ENV：设置环境变量，格式为 ENV key=value。
- EXPOSE：指定容器暴露的端口，格式为 EXPOSE port。
- CMD：指定容器启动时的默认命令和参数，格式为 CMD command。
- ENTRYPOINT：指定容器启动时要运行的可执行文件或脚本，格式为 ENTRYPOINT command。

## 27. 说说 Docker Compose 的作用

Docker Compose 是一个用于定义和运行多容器 Docker 应用程序的工具。它允许用户在一个 YAML 文件中定义多个容器以及它们之间的关系和依赖关系，以便一次性启动、停止和重建整个应用程序。Docker Compose 的作用如下：

1. 简化应用程序的部署：使用 Docker Compose 可以轻松地将多个容器打包在一起，构建出一个完整的应用程序，简化了部署和管理的工作。
2. 定义容器间的关系：在 Docker Compose 文件中，可以定义多个容器之间的关系，如依赖关系、网络连接、数据卷挂载等，使得应用程序的配置更加灵活。
3. 避免手动配置：使用 Docker Compose 可以避免手动配置各个容器之间的关系和依赖，减少出错的机会。
4. 快速构建和部署：使用 Docker Compose 可以快速构建和部署整个应用程序，从而缩短了开发和测试的周期。
5. 提高可移植性：使用 Docker Compose 可以在不同的环境中部署应用程序，提高了应用程序的可移植性，也方便了开发人员在不同的开发环境中工作。

## 28. 简单描述一下 Dockerfile 的整个构建镜像过程

Dockerfile 是一个文本文件，其中包含了一系列用于构建 Docker 镜像的指令，通过执行 docker build 命令，Docker 会按照 Dockerfile 中的指令逐层构建镜像。整个构建镜像的过程可以简单地分为以下几个步骤：

1. 创建一个新的临时容器：Docker 会基于指定的基础镜像启动一个新的容器。
2. 执行 Dockerfile 中的指令：Docker 会依次执行 Dockerfile 中的指令，每个指令都会在当前的容器中创建一个新的临时镜像层。
3. 对比并提交镜像层：在每个指令执行完成后，Docker 会将当前容器与上一层镜像进行比较，将容器中的差异部分提交为一个新的镜像层。
4. 重复执行步骤 2 和 3，直到所有指令都执行完成。
5. 生成最终镜像：当 Dockerfile 中的所有指令都执行完成后，Docker 会将最终生成的镜像层打包为一个完整的镜像，并将其保存到本地的镜像仓库中。

## 29. Docker 网络类型

1. None网络：容器没有网络连接，适用于一些特殊的场景，如容器只需要本地访问或者与其他容器通过共享数据卷进行通信。
2. Container网络：与另一个运行中的容器共享Network Namespace。
3. Host网络：使用宿主机的网络栈直接暴露容器的端口，容器和宿主机共享同一个IP地址，容器的网络性能会比较好，但会受到宿主机网络性能的限制。
4. Bridge网络：这是Docker默认使用的网络类型，它会在Docker宿主机上创建一个虚拟的网络桥接器，用于连接所有容器。
5. Macvlan网络：用于将容器连接到物理网络，每个容器都有一个唯一的MAC地址，可以直接通过宿主机网络与物理网络进行通信。
6. Overlay Network 基于 VXLAN 技术实现，它将不同主机上的容器连接到一个虚拟网络中，使得这些容器可以相互通信和协同工作。

| None            | 不为容器配置任何网络功能，没有网络 --net=none                |
| --------------- | ------------------------------------------------------------ |
| Container       | 与另一个运行中的容器共享Network Namespace，--net=container:containerID |
| Host            | 与主机共享Network Namespace，--net=host                      |
| Bridge          | Docker设计的NAT网络模型（默认类型）                          |
| Macvlan         | 每个容器都有一个唯一的MAC地址，以此进行物理网络通信          |
| Overlay Network | 将不同主机上的容器连接到一个虚拟网络中                       |

## 30 说说 Host 网络，优缺点是什么

Host 网络是 Docker 支持的一种网络模式，它可以让容器直接使用宿主机的网络栈，从而避免了网络地址转换 (NAT) 的开销和性能损失。

Host 网络的优点包括：

1. 性能更好：由于容器直接使用宿主机的网络栈，因此无需进行端口映射和数据包转发，网络性能更好，延迟更低。

2 .网络隔离更弱：容器与宿主机共享网络栈，因此它们之间的网络隔离更弱，容器可以直接访问宿主机上的网络和端口。

Host 网络的缺点包括：

1. 安全性较差：容器与宿主机共享网络栈，容器之间的网络隔离更弱，因此容器之间的网络攻击风险更高。
2. 可扩展性较差：Host 网络模式不支持容器的自动扩展，因为每个容器都需要占用宿主机的端口资源，因此会对宿主机造成一定的负载压力。

## 31. 说说 Bridge 网络，优缺点是什么

Bridge 网络是 Docker 中最常用的网络模式之一，它将 Docker 容器连接到一个 Docker 管理的虚拟网络中。每个容器可以分配一个 IP 地址，并且可以通过容器名称进行相互访问。Bridge 网络在 Docker 中是默认的网络模式。

Bridge 网络的优点包括：

1. 安全性好：Bridge 网络可以隔离容器之间的网络，保证容器之间的通信不会受到其他容器的干扰。每个容器可以分配一个独立的 IP 地址，从而保证容器之间的网络隔离。
2. 管理和扩展性好：Bridge 网络模式支持容器的自动扩展和负载均衡，可以将容器部署在不同的主机上，并通过 Docker Swarm 进行管理和控制。同时，Bridge 网络还支持自定义网络配置和插件，可以根据实际需求进行灵活的网络管理和扩展。
3. 易于使用：Bridge 网络是 Docker 的默认网络模式，可以直接使用 Docker 命令进行创建和管理。容器之间可以通过容器名称进行访问，无需进行端口映射和地址转换。

Bridge 网络的缺点包括：

1. 性能略差：Bridge 网络需要进行端口映射和地址转换，会对网络性能产生一定的影响。在高并发、大流量的应用场景下，可能会影响应用程序的性能。
2. 容器之间的网络隔离性相对 Host 网络较好



### 32. Docker 网络类型中安全性最高的

None网络：容器没有网络连接，安全性最高。但是不实用。



## 33. Docker 如何保证容器数据持久化

Docker 提供了以下几种方式：

1. 数据卷（Volume）：数据卷是 Docker 中最常用的数据持久化方式之一。数据卷是一个可独立于容器之外存在的目录（独立存储卷），可以将数据卷挂载到容器中，从而使容器能够访问该目录中的数据。数据卷通常存储在主机上的文件系统中，因此即使容器被删除或重新创建，数据卷中的数据仍然可以保留。
2. Docker 卷插件（Volume Plugin）：Docker 卷插件是一种扩展 Docker 存储功能的方式，可以通过插件机制，将 Docker 卷连接到外部存储系统，如云存储、分布式文件系统等。



## 34. 说说你对容器实现原理的理解

容器其实是一种特殊的进程，不过这个进程实现了隔离和资源限制。

而容器技术的实现原理在于通过限制和调整进程的动态表现，为其**创建一个明确的“边界”**。在 Docker 等大多数 Linux 容器中，**Cgroups 技术是制造限制的主要手段，而 Namespace 技术则是调整进程视图的主要方式**。

Linux 操作系统提供了 **PID、Mount、UTS、IPC、Network 和 User 这些 Namespace，用来对各种不同的进程上下文进行隔离操作**。

又提供了**Linux Cgroups（Linux Control Group） 用来为进程设置资源限制。其主要的作用，就是限制一个进程组能够使用的资源上限，包括 CPU、内存、磁盘、网络带宽等等**。

通过 Linux 的这两种技术，就实现了普通进程的隔离与资源限制，这就是容器的本质。

## 35. 说说 Linux Namespace技术

Linux Namespace 是 Linux 内核提供的一种机制，**用于将系统资源隔离到不同的命名空间中，每个命名空间都拥有独立的资源视图**。这种隔离机制使得不同进程可以在相同的系统上独立运行，不会相互影响。

Linux 操作系统提供了 **PID、Mount、UTS、IPC、Network 和 User 这些 Namespace，用来对各种不同的进程上下文进行隔离操作**。

比如 Linux 使用 clone() 系统调用创建一个新进程时，就可以在参数中指定 CLONE_NEWPID 参数，这样创建的进程就处于一个新的 PID Namespace。

## 36. 说说 Linux Cgroups 技术

Linux Cgroups（Control groups）是一种内核级别的机制，用于限制和管理进程、任务或者用户组的系统资源使用。Cgroups 可以在不同的层次结构中对系统资源进行分类，每个分类可以设置自己的资源限制、优先级和控制策略。**其主要的作用，就是限制一个进程组能够使用的资源上限，包括 CPU、内存、磁盘、网络带宽等等**。

在 `/sys/fs/cgroup` 目录下，有许多名为 cpuset、cpu 和 memory 的子目录，这些目录被称为子系统，表示可由 Cgroups 限制的资源种类。比如我们可以在这些子系统中创建新目录，目录下自动生成该子系统对应的资源限制文件，通过配置这些文件，我们就可以实现资源配置了。



## 37. 说说容器运行时

容器运行时是一种用于管理和运行容器的软件工具。它负责解析容器镜像、创建和管理容器的生命周期、以及与底层操作系统进行交互等任务。

容器运行时通常与容器编排工具（例如 Kubernetes）一起使用，以提供一种可伸缩、可靠和高效的容器化解决方案。容器运行时可以支持多种容器格式和操作系统，例如 Docker、rkt、CRI-O、Kata Containers 等。

## 38. Containerd 常用命令

- `ctr image pull <image>`：拉取指定的镜像
- `ctr image ls`：列出本地所有镜像
- `ctr image rm <image>`：删除本地的指定镜像
- `ctr container create <container>`：创建一个容器
- `ctr container start <container>`：启动指定容器
- `ctr container ls`：列出所有正在运行的容器
- `ctr container stop <container>`：停止指定容器
- `ctr container rm <container>`：删除指定容器
- `ctr tasks ls`：列出所有正在运行的任务

## 39. Containerd 和 Docker 的区别

1. 定位不同：Docker 早期被认为是一种容器技术，而现在已经发展成为一个生态系统，提供了包括构建、发布、部署、运行和管理容器的一系列工具和服务；而 Containerd 则更专注于容器运行时，它是一个轻量的容器运行时，为 Kubernetes 等容器编排工具提供了底层支持。
2. 架构不同：Docker 是一个完整的容器解决方案，它包括 Docker 引擎、Docker Registry 和 Docker Compose 等多个组件；而 Containerd 则是一个容器运行时，它可以通过 gRPC API 与外部系统交互，并通过不同的插件（如 runc）提供容器运行时服务。
3. 功能不同：Docker 提供了丰富的功能，如构建镜像、发布镜像、容器编排等等；而 Containerd 只提供了容器的运行时服务，例如容器的生命周期管理、容器文件系统挂载等。

新老版本的 Kubernetes 调用链如图：

![img](https://uploadfiles.nowcoder.com/images/20230524/675098158_1684899808190/B4675CCC172900F3942AC871E9EE7F1A)