# SQL 基本概念

## 问题

### 数据库基础

* 关系型和非关系型数据库的区别你了解多少？
* 数据库三大范式
*  主键、外键、超键、候选键

### SQL 基础

* 什么是 SQL

* SQL 语言分类

* 执行一条 select 语句，期间发生了什么？

### DDL

* MYSQL 中 CHAR 和 VARCHAR 的区别
* Drop、Delete 与 Truncate 的共同点和区别

### DML

* 添加数据
* 修改数据
* 删除数据

### DQL

* SQL 执行顺序

### DCL

### 函数

* SQL中的NOW()和CURRENT_DATE()两个函数有什么区别？



### 约束



### 多表查询





### 视图/存储过程/触发器





* SQL语法中内连接、自连接、外连接（左、右、全）、交叉连接的区别分别是什么？
* 触发器的作用
* 什么是存储过程？用什么来调用？有什么优缺点？与函数的区别
* 什么是视图？有什么优缺点？
* 什么是游标？
* 什么是临时表，临时表什么时候删除
* like % 和 - 的区别
* count(*)、count(1)、count(column) 的区别，哪个性能最好
* MySQL 一行记录是怎么存储的

## 回答

### 数据库基础

#### 关系型和非关系型数据库的区别你了解多少？

* 关系型数据库的优点
	* 容易理解。因为它采用了关系模型来组织数据。
	* 可以保持数据的一致性。
	* 数据更新的开销比较小。
	* 支持复杂查询（带where子句的查询）
* 非关系型数据库的优点
	* 不需要经过SQL层的解析，读写效率高。
	* 基于键值对，数据的扩展性很好。
	* 可以支持多种类型数据的存储，如图片，文档等等。

非关系型数据库也叫NOSQL，采用键值对的形式进行存储。它的读写性能很高，易于扩展，可分为内存性数据库以及文档型数据库，比如 Redis，Mongodb，HBase等等。

适合使用非关系型数据库的场景：

* 日志系统
* 地理位置存储
* 数据量巨大
* 高可用



#### 数据库三大范式

* 第一范式（1NF）：原子性，字段不可再分,否则就不是关系数据库;
* 第二范式（2NF）：唯一性，一个表只说明一个事物，有主键，非主键字段依赖主键
* 第三范式（3NF）：非主键字段不能相互依赖。每列都与主键有直接关系，不存在传递依赖。



#### 主键、外键、超键、候选键

**超键**：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。

**候选键**：是最小超键，即没有冗余元素的超键。

**主键**：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。

**外键**：在一个表中存在的另一个表的主键称此表的外键。







### SQL 基础

#### 什么是 SQL

SQL（结构化查询语言）是一种设计用于检索和操作数据的数据库



#### SQL 语言分类

* 数据定义语言DDL
    * 用来定义数据库对象(数据库，表，字段) 

- 数据操纵语言DML
    - 添加数据（INSERT） 
    - 修改数据（UPDATE）
    -  删除数据（DELETE）
- 数据查询语言DQL
    - SELECT 字段列表 
    - FROM 表名列表 
    - WHERE 条件列表 
    - GROUP BY 分组字段列表 
    - HAVING 分组后条件列表 
    - ORDER BY 排序字段列表 
    - LIMIT 分页参数
- 数据控制语言DCL。



#### 执行一条 select 语句，期间发生了什么？

* 连接器：建立连接，管理连接、校验用户身份；
* 查询缓存：查询语句如果命中查询缓存则直接返回，否则继续往下执行。MySQL 8.0 已删除该模块；
* 解析 SQL，通过解析器对 SQL 查询语句进行词法分析、语法分析，然后构建语法树，方便后续模块读取表名、字段、语句类型；
* 执行 SQL：执行 SQL 共有三个阶段：
    * 预处理阶段：检查表或字段是否存在；将 `select *` 中的 `*` 符号扩展为表上的所有列。
    * 优化阶段：基于查询成本的考虑， 选择查询成本最小的执行计划；
    * 执行阶段：根据执行计划执行 SQL 查询语句，从存储引擎读取记录，返回给客户端；

![查询语句执行流程](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/mysql%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B.png)



### DDL

#### 数据库操作

```sql
# 查询所有数据库
show databases;

# 查询当前数据库
select database();

# 创建数据库
create database [ if not exists ] 数据库名 [ default charset 字符集 ] [ collate 排序
规则 ] ;

# 删除数据库
drop database [ if exists ] 数据库名 ;

# 切换数据库
use 数据库名 ;
```



#### 数据表操作

##### 表操作-查询创建

```sql
# 查询当前数据库所有表
show tables;

# 查看指定表结构
desc 表名 ;

# 查询指定表的建表语句
show create table 表名 ;

# 创建表结构， 注意: [...] 内为可选参数，最后一个字段后面没有逗号
CREATE TABLE 表名(
    字段1 字段1类型 [ COMMENT 字段1注释 ],
    字段2 字段2类型 [COMMENT 字段2注释 ],
    字段3 字段3类型 [COMMENT 字段3注释 ],
    ......
    字段n 字段n类型 [COMMENT 字段n注释 ]
) [ COMMENT 表注释 ] 
```



##### 表操作-数据类型

数值类型

| 类型        | 大小   | 有符号(SIGNED)范围                                     | 无符号(UNSIGNED)范围                                       | 描述                  |
| ----------- | ------ | ------------------------------------------------------ | ---------------------------------------------------------- | --------------------- |
| TINYINT     | 1byte  | (-128，127)                                            | (0，255)                                                   | 小整数值              |
| SMALLINT    | 2bytes | (-32768，32767)                                        | (0，65535)                                                 | 大整数值              |
| MEDIUMINT   | 3bytes | (-8388608，8388607)                                    | (0，16777215)                                              | 大整数值              |
| INT/INTEGER | 4bytes | (-2147483648， 2147483647)                             | (0，4294967295)                                            | 大整数值              |
| BIGINT      | 8bytes | (-2^ 63 ，2^63-1)                                      | (0，2^64-1)                                                | 极 整数 值            |
| FLOAT       | 4bytes | (-3.402823466 E+38， 3.402823466351 E+38)              | 0 和 (1.175494351 E38，3.402823466 E+38)                   | 单精度浮点数 值       |
| DOUBLE      | 8bytes | (-1.7976931348623157 E+308， 1.7976931348623157 E+308) | 0 和 (2.2250738585072014 E-308， 1.7976931348623157 E+308) | 双精 度浮 点数 值     |
| DECIMAL     |        | 依赖于M(精度)和D(标度) 的值                            | 依赖于M(精度)和D(标度)的 值                                | 小数 值(精 确定 点数) |

```
1). 年龄字段 -- 不会出现负数, 而且人的年龄不会太大
age tinyint unsigned
2). 分数 -- 总分100分, 最多出现一位小数
score double(4,1)
```



字符串类型

| 类型       | 大小                  | 描述                         |
| ---------- | --------------------- | ---------------------------- |
| CHAR       | 0-255 bytes           | 定长字符串(需要指定长度)     |
| VARCHAR    | 0-65535 bytes         | 变长字符串(需要指定长度)     |
| TINYBLOB   | 0-255 bytes           | 不超过255个字符的二进制数据  |
| TINYTEXT   | 0-255 bytes           | 短文本字符串                 |
| BLOB       | 0-65 535 bytes        | 二进制形式的长文本数据       |
| TEXT       | 0-65 535 bytes        | 长文本数据                   |
| MEDIUMBLOB | 0-16 777 215 bytes    | 二进制形式的中等长度文本数据 |
| MEDIUMTEXT | 0-16 777 215 bytes    | 中等长度文本数据             |
| LONGBLOB   | 0-4 294 967 295 bytes | 二进制形式的极大文本数据     |
| LONGTEXT   | 0-4 294 967 295 bytes | 极大文本数据                 |



```
如：
1). 用户名 username ------> 长度不定, 最长不会超过50
username varchar(50)
2). 性别 gender ---------> 存储值, 不是男,就是女
gender char(1)
3). 手机号 phone --------> 固定长度为11
phone char(11)

```



###### MySQL中CHAR和VARCHAR的区别有哪些？

* char的长度是不可变的，用空格填充到指定长度大小，而varchar的长度是可变的。

* char的存取数度还是要比 varchar要快得多

* char的存储方式是：对英文字符（ASCII）占用1个字节，对一个汉字占用两个字节。varchar的存储方式是：对每个英文字符占用2个字节，汉字也占用2个字节。

* 两者的存储数据都非unicode的字符数据。

    



日期时间类型

| 类型      | 大小 | 范围                                       | 格式                | 描述                      |
| --------- | ---- | ------------------------------------------ | ------------------- | ------------------------- |
| DATE      | 3    | 1000-01-01 至 9999-12-31                   | YYYY-MM-DD          | 日期值                    |
| TIME      | 3    | -838:59:59 至 838:59:59                    | HH:MM:SS            | 时间值或持 时间           |
| YEAR      | 1    | 1901 至 2155                               | YYYY                | 年份值                    |
| DATETIME  | 8    | 1000-01-01 00:00:00 至 9999-12-31 23:59:59 | YYYY-MM-DD HH:MM:SS | 混合日期和时 间值         |
| TIMESTAMP | 4    | 1970-01-01 00:00:01 至 2038-01-19 03:14:07 | YYYY-MM-DD HH:MM:SS | 混合日期和时 间值，时间戳 |



```

1). 生日字段 birthday
birthday date
2). 创建时间 createtime
createtime datetime

```





##### 表操作-修改

```sql
#  添加字段
ALTER TABLE 表名 ADD 字段名 类型 (长度) [ COMMENT 注释 ] [ 约束 ];

# 修改数据类型
ALTER TABLE 表名 MODIFY 字段名 新数据类型 (长度)

# 修改字段名和字段类型
ALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型 (长度) [ COMMENT 注释 ] [ 约束 ];

# 删除字段
ALTER TABLE 表名 DROP 字段名;

# 修改表名
ALTER TABLE 表名 RENAME TO 新表名;
```



#####  表操作-删除

```sql
#  删除表
DROP TABLE [ IF EXISTS ] 表名

#  删除指定表, 并重新创建表
TRUNCATE TABLE 表名
```



###### **说一说Drop、Delete与Truncate的共同点和区别**

* Drop

    * Drop直接删掉表;
    * 从数据库中删除表，所有的数据行，索引和权限也会被删除，所有的DML触发器也不会被触发，这个命令也不能回滚。
    * drop语句将表所占用的空间全释放掉。

* Truncate

    * Truncate删除表中数据，再插入时自增长id又从1开始 ;
    * 删除表中的所有数据，这个操作不能回滚，也不会触发这个表上的触发器，TRUNCATE比delete更快，占用的空间更小
    * 表和索引所占空间。当表被TRUNCATE 后，这个表和索引所占用的空间会恢复到初始大小

* Delete

    * Delete删除表中数据，可以加where字句。
    * 用来删除表的全部或者一部分数据行，执行delete之后，用户需要提交(commmit)或者回滚(rollback)来执行删除或者撤销删除，会触发这个表上所有的delete触发器
    * DELETE操作不会减少表或索引所占用的空间

    

### DML

#### 添加数据

```sql
#  给指定字段添加数据
INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...)

# 给全部字段添加数据
INSERT INTO 表名 VALUES (值1, 值2, ...);

# 批量添加数据
INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...), (值1, 值2, ...), (值
1, 值2, ...) ;

INSERT INTO 表名 VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...) 


```

* 插入数据时，指定的字段顺序需要与值的顺序是一一对应的。

* 字符串和日期型数据应该包含在引号中。

*  插入的数据大小，应该在字段的规定范围内。

    

#### 修改数据

```sql
UPDATE 表名 SET 字段名1 = 值1 , 字段名2 = 值2 , .... [ WHERE 条件 ] ;
```



#### 删除数据

```sql
DELETE FROM 表名 [ WHERE 条件 ] 
```

* DELETE 语句的条件可以有，也可以没有，如果没有条件，则会删除整张表的所有数 据。

*  DELETE 语句不能删除某一个字段的值(可以使用UPDATE，将该字段值置为NULL即 可)。 

    

### DQL

#### SQL 执行顺序

**书写顺序**：SELECT -> FROM -> JOIN -> ON -> WHERE -> GROUP BY -> HAVING -> UNION -> ORDER BY ->LIMIT



**执行顺序**：FROM -> ON -> JOIN -> WHERE -> GROUP BY -> HAVING -> SELECT -> UNION -> ORDER BY ->LIMIT



#### 基础查询

```sql
# 查询多个字段
SELECT 字段1, 字段2, 字段3 ... FROM 表名 

# 字段设置别名
SELECT 字段1 [ AS 别名1 ] , 字段2 [ AS 别名2 ] ... FROM 表名;

# 去除重复记录
SELECT DISTINCT 字段列表 FROM 表名;
```



#### 条件查询

```sql
SELECT 字段列表 FROM 表名 WHERE 条件列表 ;
```

条件

| 比较运算符          | 功能                                            |
| ------------------- | ----------------------------------------------- |
| >                   | 大于                                            |
| >=                  | 大于等于                                        |
| <                   | 小于                                            |
| <=                  | 小于等于                                        |
| =                   | 等于                                            |
| <> 或 !=            | 不等于                                          |
| BETWEEN ... AND ... | 在某个范围之内(含最小、最大值)                  |
| IN(...)             | 在in之后的列表中的值，多选一                    |
| LIKE                | 占位符 模糊匹配(_匹配单个字符, %匹配任意个字符) |
| IS NULL             | 是NULL                                          |

逻辑运算符

| 逻辑运算符 | 功能                         |
| ---------- | ---------------------------- |
| AND 或 &&  | 并且 (多个条件同时成立)      |
| OR 或 \|\| | 或者 (多个条件任意一个成立） |
| NOT 或 !   | 非 , 不是                    |

##### like % 和 - 的区别

**通配符的分类:**

**%百分号通配符:**表示任何字符出现任意次数(可以是0次).

**_下划线通配符:**表示只能匹配单个字符,不能多也不能少,就是一个字符.

**like操作符:** LIKE作用是指示mysql后面的搜索模式是利用通配符而不是直接相等匹配进行比较.

**注意:** 如果在使用like操作符时,后面的没有使用通用匹配符效果是和=一致的,SELECT * FROM products WHERE products.prod_name like '1000';
只能匹配的结果为1000,而不能匹配像JetPack 1000这样的结果.

- %通配符使用: 匹配以"yves"开头的记录:(包括记录"yves") SELECT *FROM products WHERE products.prod_name like 'yves%';
    匹配包含"yves"的记录(包括记录"yves") SELECT* FROM products WHERE products.prod_name like '%yves%';
    匹配以"yves"结尾的记录(包括记录"yves",不包括记录"yves ",也就是yves后面有空格的记录,这里需要注意) SELECT * FROM products WHERE products.prod_name like '%yves';
- *通配符使用: SELECT \*FROM products WHERE products.prod_name like '_yves'; 匹配结果为: 像"yyves"这样记录.
    SELECT\* FROM products WHERE products.prod\*name like 'yves**'; 匹配结果为: 像"yvesHe"这样的记录.(一个下划线只能匹配一个字符,不能多也不能少)

**注意事项:**

- 注意大小写,在使用模糊匹配时,也就是匹配文本时,mysql是可能区分大小的,也可能是不区分大小写的,这个结果是取决于用户对MySQL的配置方式.如果是区分大小写,那么像YvesHe这样记录是不能被"yves__"这样的匹配条件匹配的.
- 注意尾部空格,"%yves"是不能匹配"heyves "这样的记录的.
- 注意NULL,%通配符可以匹配任意字符,但是不能匹配NULL,也就是说SELECT * FROM products WHERE products.prod_name like '%;是匹配不到products.prod_name为NULL的的记录.

**技巧与建议:**

正如所见， MySQL的通配符很有用。但这种功能是有代价的：通配符搜索的处理一般要比前面讨论的其他搜索所花时间更长。这里给出一些使用通配符要记住的技巧。

- 不要过度使用通配符。如果其他操作符能达到相同的目的，应该 使用其他操作符。
- 在确实需要使用通配符时，除非绝对有必要，否则不要把它们用 在搜索模式的开始处。把通配符置于搜索模式的开始处，搜索起 来是最慢的。
- 仔细注意通配符的位置。如果放错地方，可能不会返回想要的数.



##### MySQL 中 in 和 exists 区别

MySQL中的in语句是把外表和内表作hash 连接，而exists语句是对外表作loop循环，每次loop循环再对内表进行查询。一直大家都认为exists比in语句的效率要高，这种说法其实是不准确的。这个是要区分环境的。

如果查询的两个表大小相当，那么用in和exists差别不大。 如果两个表中一个较小，一个是大表，则子查询表大的用exists，子查询表小的用in。 not in 和not exists：如果查询语句使用了not in，那么内外表都进行全表扫描，没有用到索引；而not extsts的子查询依然能用到表上的索引。所以无论那个表大，用not exists都比not in要快。



#### 聚合函数

```sql
SELECT 聚合函数(字段列表) FROM 表名 ;
```

注意 : NULL值是不参与所有聚合函数运算的。

| 函数  | 功能     |
| ----- | -------- |
| count | 统计数量 |
| max   | 最大值   |
| min   | 最小值   |
| avg   | 平均值   |
| sum   | 求和     |

#### 分组查询

```sql
SELECT 字段列表 FROM 表名 [ WHERE 条件 ] GROUP BY 分组字段名 [ HAVING 分组
后过滤条件 ];
```



#####  where与having区别

* 执行时机不同：where是分组之前进行过滤，不满足where条件，不参与分组；而having是分组 之后对结果进行过滤。 
* 判断条件不同：where不能对聚合函数进行判断，而having可以。



* 分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义。 
* 执行顺序: where > 聚合函数 > having 。 
*  支持多字段分组, 具体语法为 : group by columnA,columnB

#### 排序查询

```sql
SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1 , 字段2 排序方式2 ;
```

排序方式

* ASC : 升序(默认值) 
* DESC: 降序 

注意事项： 

* 如果是升序, 可以不指定排序方式ASC ; 
*  如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序 ;

#### 分页查询

```sql
SELECT 字段列表 FROM 表名 LIMIT 起始索引, 查询记录数 ;
```

* 起始索引从0开始，起始索引 = （查询页码 - 1）* 每页显示记录数。 
* 分页查询是数据库的方言，不同的数据库有不同的实现，MySQL中是LIMIT。 
*  如果查询的是第一页数据，起始索引可以省略，直接简写为 limit 10。





### DCL

DCL英文全称是Data Control Language(数据控制语言)，用来管理数据库用户、控制数据库的访 问权限。

#### 管理用户

```sql
# 查询用户
select * from mysql.user;

# 创建用户
CREATE USER '用户名'@'主机名' IDENTIFIED BY '密码';

# 修改用户密码
ALTER USER '用户名'@'主机名' IDENTIFIED WITH mysql_native_password BY '新密码' ;

# 删除用户
DROP USER '用户名'@'主机名' ;
```



*  在MySQL中需要通过用户名@主机名的方式，来唯一标识一个用户。
* 主机名可以使用 % 通配。
* 这类SQL开发人员操作的比较少，主要是DBA（ Database Administrator 数据库 管理员）使用。



#### 权限控制

权限

| 权限                | 说明               |
| ------------------- | ------------------ |
| ALL, ALL PRIVILEGES | 所有权限           |
| SELECT              | 查询数据           |
| INSERT              | 插入数据           |
| UPDATE              | 修改数据           |
| DELETE              | 删除数据           |
| ALTER               | 修改表             |
| DROP                | 删除数据库/表/视图 |
| CREATE              | 创建数据库/表      |



```sql
# 查询权限
SHOW GRANTS FOR '用户名'@'主机名' ;

# 授予权限
GRANT 权限列表 ON 数据库名.表名 TO '用户名'@'主机名';

# 撤销权限
REVOKE 权限列表 ON 数据库名.表名 FROM '用户名'@'主机名';
```

注意事项： 

* 多个权限之间，使用逗号分隔 
* 授权时， 数据库名和表名可以使用 * 进行通配，代表所有。



### 函数

#### 字符串函数

```sql
# concat 字符串拼接
select concat('Hello', 'MySQL');

# lower 全部转小写
select lower('Hello');

# upper 全部转大写
select upper('Hello');

# lpad 左填充
select lpad('01', 5, '-');

# rpad 右填充
select rpad('01', 5, '-');

# trim 去除空格
select trim(' Hello MySQL ')

# substring 截取子字符串
select substring('Hello MySQL',1,5);
```



#### 数值函数

```sql
# ceil 向上取整
select ceil(1.1);

# floor 向下取整
select floor(1.9);

# mod 取模
select mod(7, 4);

# rand 获取 0- 1 随机数 
select rand();

# round：四舍五入 求参数x的四舍五入的值，保留y位小数
select round(2.344,2);
```



#### 日期函数

```sql
# curdate：当前日期
select curdate();

# curtime：当前时间
select curtime();

# now：当前日期和时间
select now();

# YEAR , MONTH , DAY：当前年、月、日
select YEAR(now());
select MONTH(now());
select DAY(now());

# date_add：增加指定的时间间隔
select date_add(now(), INTERVAL 70 YEAR );

# datediff：获取两个日期相差的天数
select datediff('2021-10-01', '2021-12-01');
```



#### 流程函数

| 函数                                                         | 功能                                                       |
| ------------------------------------------------------------ | ---------------------------------------------------------- |
| IF(value , t , f)                                            | 如果value为true，则返回t，否则返回 f                       |
| IFNULL(value1 , value2)                                      | 如果value1不为空，返回value1，否则 返回value2              |
| CASE WHEN [ val1 ] THEN [res1] ... ELSE [ default ] END      | 如果val1为true，返回res1，... 否 则返回default默认值       |
| CASE [ expr ] WHEN [ val1 ] THEN [res1] ... ELSE [ default ] END | 如果expr的值等于val1，返回 res1，... 否则返回default默认值 |



### 约束

* 概念：约束是作用于表中字段上的规则，用于限制存储在表中的数据。

* 目的：保证数据库中数据的正确、有效性和完整性。

#### 约束分类

| 约束                      | 描述                                                      | 关键字      |
| ------------------------- | --------------------------------------------------------- | ----------- |
| 非空约束                  | 限制该字段的数据不能为null                                | NOT NULL    |
| 唯一约束                  | 保证该字段的所有数据都是唯一、不重复的                    | UNIQUE      |
| 主键约束                  | 主键是一行数据的唯一标识，要求非空且唯一                  | PRIMARY KEY |
| 默认约束                  | 保存数据时，如果未指定该字段的值，则采用默认值            | DEFAULT     |
| 检查约束(8.0.16版本 之后) | 保证字段值满足某一个条件                                  | CHECK       |
| 外键约束                  | 用来让两张表的数据之间建立连接，保证数据的一致 性和完整性 | FOREIGN KEY |

约束是作用于表中字段上的，可以在创建表/修改表的时候添加约束。



#### 外键约束



### 多表查询

#### SQL语法中内连接、自连接、外连接（左、右、全）、交叉连接的区别分别是什么？

* 内连接：只有两个元素表相匹配的才能在结果集中显示。
* 外连接： 
    * 左外连接: 左边为驱动表，驱动表的数据全部显示，匹配表的不匹配的不会显示。
    * 右外连接:右边为驱动表，驱动表的数据全部显示，匹配表的不匹配的不会显示。
    * 全外连接：连接的表中不匹配的数据全部会显示出来。

* 交叉连接： 笛卡尔效应，显示的结果是链接表数的乘积。



#### 小表驱动大表



#### join 原理



#### 什么是临时表，临时表什么时候删除

**临时表可以手动删除：**
DROP TEMPORARY TABLE IF EXISTS temp_tb;

**临时表只在当前连接可见，当关闭连接时，MySQL会自动删除表并释放所有空间。因此在不同的连接中可以创建同名的临时表，并且操作属于本连接的临时表。
创建临时表的语法与创建表语法类似，不同之处是增加关键字TEMPORARY，**

如：

```sql
CREATE TEMPORARY TABLE tmp_table (
    NAME VARCHAR (10) NOT NULL,
    time date NOT NULL
);

select * from tmp_table;
```





### 视图/存储过程/触发器

#### 视图

##### 什么是视图

视图（View）是一种虚拟存在的表。视图中的数据并不在数据库中实际存在，行和列数据来自定义视 图的查询中使用的表，并且是在使用视图时动态生成的。 

通俗的讲，视图只保存了查询的SQL逻辑，不保存查询结果。所以我们在创建视图的时候，主要的工作 就落在创建这条SQL查询语句上。



##### 语法

```sql
# 创建
CREATE [OR REPLACE] VIEW 视图名称[(列名列表)] AS SELECT语句 [ WITH [
CASCADED | LOCAL ] CHECK OPTION ]

# 查询
查看创建视图语句：SHOW CREATE VIEW 视图名称;
查看视图数据：SELECT * FROM 视图名称 ...... ;

# 修改
方式一：CREATE [OR REPLACE] VIEW 视图名称[(列名列表)] AS SELECT语句 [ WITH
[ CASCADED | LOCAL ] CHECK OPTION ]
方式二：ALTER VIEW 视图名称[(列名列表)] AS SELECT语句 [ WITH [ CASCADED |
LOCAL ] CHECK OPTION ]

# 删除
DROP VIEW [IF EXISTS] 视图名称 [,视图名称] ...
```



##### 检查选项

当使用WITH CHECK OPTION子句创建视图时，MySQL会通过视图检查正在更改的每个行，例如 插 入，更新，删除，以使其符合视图的定义。 

MySQL允许基于另一个视图创建视图，它还会检查依赖视 图中的规则以保持一致性。为了确定检查的范围，mysql提供了两个选项： CASCADED 和 LOCAL ，默认值为 CASCADED 。 

* CASCADED 级联。 比如，v2 视图是基于 v1 视图的，如果在 v2 视图创建的时候指定了检查选项为 cascaded，但是 v1 视图 创建时未指定检查选项。 则在执行检查时，不仅会检查 v2，还会级联检查 v2 的关联视图 v1。 
* LOCAL 本地。 比如，v2 视图是基于 v1 视图的，如果在 v2 视图创建的时候指定了检查选项为 local ，但是 v1 视图创 建时未指定检查选项。 则在执行检查时，只会检查 v2，不会检查 v2 的关联视图 v1



##### 视图的更新

要使视图可更新，视图中的行与基础表中的行之间必须存在一对一的关系。如果视图包含以下任何一 项，则该视图不可更新： 

* 聚合函数或窗口函数（SUM()、 MIN()、 MAX()、 COUNT()等） 
*  DISTINCT 
* GROUP BY 
* HAVING 
* UNION 或者 UNION ALL



##### 视图的作用

* **简单 ：**视图不仅可以简化用户对数据的理解，也可以简化他们的操作。那些被经常使用的查询可以被定义为视图，从而使得用户不必为以后的操作每次指定全部的条件。 
* **安全：**数据库可以授权，但不能授权到数据库特定行和特定的列上。通过视图用户只能查询和修改他们所能见 到的数据 
*  **数据独立**：视图可帮助用户屏蔽真实表结构变化带来的影响。

##### 视图的优缺点

**优点：**

* 对数据库的访问，因为视图可以有选择性的选取数据库里的一部分。
* 用户通过简单的查询可以从复杂查询中得到结果。
* 维护数据的独立性，视图可从多个表检索数据。
* 对于相同的数据可产生不同的视图。

**缺点：**

* 性能：查询视图时，必须把视图的查询转化成对基本表的查询，如果这个视图是由一个复杂的多表查询所定义，那么，那么就无法更改数据
* 视图不能被索引，也不能有关联的触发器或默认值，如果视图本身内有order by 则对视图再次order by将被覆盖。

#### 存储过程

##### 什么是存储过程？

存储过程是事先经过编译并存储在数据库中的一段 SQL 语句的集合，调用存储过程可以简化应用开发 人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。 存储过程思想上很简单，就是数据库 SQL 语言层面的代码封装与重用。

* 封装，复用：可以把某一业务SQL封装在存储过程中，需要用到 的时候直接调用即可。 
* 可以接收参数，也可以返回数据 ：再存储过程中，可以传递参数，也可以接收返回 值
* 减少网络交互，效率提升： 如果涉及到多条SQL，每执行一次都是一次网络传 输。 而如果封装在存储过程中，我们只需要网络交互一次可能就可以了。



##### **存储过程的优缺点？**

**优点：**

* 存储过程是预编译过的，执行效率高。
* 存储过程的代码直接存放于数据库中，通过存储过程名直接调用，减少网络通讯。
* 安全性高，执行存储过程需要有一定权限的用户。
* 存储过程可以重复使用，可减少数据库开发人员的工作量。

**缺点：**移植性差



##### **存储过程与函数的区别**

![img](https://i.imgur.com/ymE9HPJ.png)

##### 什么是游标

游标是对查询出来的结果集作为一个单元来有效的处理。一般不使用游标，但是需要逐条处理数据的时候，游标显得十分重要。

游标（CURSOR）是用来存储查询结果集的数据类型 , 在存储过程和函数中可以使用游标对结果集进 行循环的处理。游标的使用包括游标的声明、OPEN、FETCH 和 CLOSE，其语法分别如下。



#### 存储函数

存储函数是有返回值的存储过程，存储函数的参数只能是IN类型的。具体语法如下：

```
CREATE FUNCTION 存储函数名称 ([ 参数列表 ])
RETURNS type [characteristic ...]
BEGIN
-- SQL语句
RETURN ...;
END ;

```

characteristic说明： 

* DETERMINISTIC：相同的输入参数总是产生相同的结果
* NO SQL ：不包含 SQL 语句。 
* READS SQL DATA：包含读取数据的语句，但不包含写入数据的语句。

#### 触发器

##### 什么是触发器

触发器是与表有关的数据库对象，指在insert/update/delete之前(BEFORE)或之后(AFTER)，触发并执行触发器中定义的SQL语句集合。

触发器的这种特性可以协助应用在数据库端确保数据的完整性 , 日志记录 , 数据校验等操作 。 

使用别名OLD和NEW来引用触发器中发生变化的记录内容，这与其他的数据库是相似的。现在触发器还 只支持行级触发，不支持语句级触发。

| 触发器类型      | NEW 和 OLD                                              |
| --------------- | ------------------------------------------------------- |
| INSERT 型触发器 | NEW 表示将要或者已经新增的数据                          |
| UPDATE 型触发器 | OLD 表示修改之前的数据 , NEW 表示将要或已经修改后的数据 |
| DELETE 型触发器 | OLD 表示将要或者已经删除的数据                          |

​    
