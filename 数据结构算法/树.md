# 树

树是由n个结点组成的有限集合

n=0为空树

n>0有一个结点为根只有后继结点，其他结点划分为m个互不相交的有限集合，每个集合本身是一棵树，称之为根的子树。每个子树的根节点有且只有一个直接前驱，但可以有0个或多个后继

度，树的度，叶子结点（终端结点），分支结点（非终端结点），内部结点，孩子，双亲，兄弟，祖先和子孙，层数，树的深度或高度，堂兄弟，无序树，有序树，结点的次序，最左结点（长子），次子，森林（删除一棵树的根就能得到一个森林）

* $结点数=分支数+1$
* $分支数=\sum 度数不为0的结点数 * 度数$
* 树的存储形式：双亲表示法，孩子链表表示法，孩子兄弟表示法

## 二叉树

**特点：**

每个结点最多有两棵子树

二叉树的子树有左右之分不可以颠倒，只有一棵子树树也必须分清左右子树

**二叉树的性质：**

* 第i层最多有$2^{i-1}$

* 深度为k的二叉树最多有 $2^k-1$ 结点

* 叶节点树数为 $n_0$,度数为2的结点数为 $n_2$, $n_0=n_2+1$

* 令二叉树的分支数（所有结点的度数和）为 $B$ , $n_0+n_1+n_2=B+1=n=n_1+2*n_2+1$

* n个结点的二叉树：高最多为$n$，最低为$\lfloor log_2n \rfloor+1$(完全二叉树)

* n个结点树转为二叉树后，没有右孩子的结点个数=分支结点个数+1，这个1是因为根节点也没有右孩子

**满二叉树**：

一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树。也就是说，如果一个二叉树的层数为K，且结点总数是(2^k) -1 ，则它就是满二叉树。

除了叶结点外每一个结点都有左右子叶且叶子结点都处在最底层的二叉树

满二叉树：深度为k且有$2^k-1$个结点的二叉树，不存在度为1的结点

满m叉树：第k层有$2^{k-1}$个结点

**完全二叉树：**

若设二叉树的高度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第h层有叶子结点，并且叶子结点都是从左到右依次排布，这就是完全二叉树。

叶节点只能出现在最下层和次下层，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树。

深度为k,n个结点的二叉树，当且仅当每个结点和深度为k的满二叉树编号从1-n的结点一一对应

若设二叉树的高度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第h层有叶子结点，并且叶子结点都是从左到右依次排布，这就是完全二叉树。

性质

* 叶子结点只可能在层次最大的两层上出现
* 结点无左子女那么一定没有右子女
* 度为1的结点数为$(n+1)\%2$,要么0要么1
* 度为0的结点数（叶子结点）为$\lfloor(n+1)/2\rfloor$
* 度为2的结点数为$\lfloor(n+1)/2\rfloor-1$
* 二叉树：度数为0的结点数=度数为2的结点数+1
* 编号最大的分支结点是$\lfloor n/2\rfloor$编号最小的叶子结点是$\lfloor n/2\rfloor$+1
* 具有n个结点的完全二叉树的深度$k=\lfloor log_2n\rfloor+1$
* 如果对一棵有n个结点的完全二叉树按层次次序从1开始编号，则对任意结点i有：

  i=1,序号结点是根

  i>1,其双亲结点是$\lfloor i/2 \rfloor$

  2i<=n,序号为i的结点的左子女结点的序号为2i

  2i>n序号为i的结点没有左子女

  2i+1<=n,序号为i的结点的右子女结点的序号为2i+1

  2i+1>n,序号为i的结点的没有右子女结点

**堆**

堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。

## 二叉查找树（BST）

[浅谈算法和数据结构: 七 二叉查找树](http://www.cnblogs.com/yangecnu/p/Introduce-Binary-Search-Tree.html)

二叉查找树的特点：

1. 若任意节点的左子树不空，则左子树上所有结点的 值均小于它的根结点的值；
2. 若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
3. 任意节点的左、右子树也分别为二叉查找树；
4. 没有键值相等的节点（no duplicate nodes）。

## 平衡二叉树（Self-balancing binary search tree）

[平衡二叉树](https://baike.baidu.com/item/平衡二叉树)（百度百科，平衡二叉树的常用实现方法有红黑树、AVL、替罪羊树、Treap、伸展树等）

平衡二叉树又被称为AVL树（区别于AVL算法），它是一棵二叉排序树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。

## 红黑树

红黑树特点:

1. 每个节点非红即黑；
2. 根节点总是黑色的；
3. 每个叶子节点都是黑色的空节点（NIL节点）；
4. 如果节点是红色的，则它的子节点必须是黑色的（反之不一定）；
5. 从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）。

红黑树的应用：

TreeMap、TreeSet以及JDK1.8的HashMap底层都用到了红黑树。

**为什么要用红黑树？**

简单来说红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。详细了解可以查看 [漫画：什么是红黑树？](https://juejin.im/post/5a27c6946fb9a04509096248)（也介绍到了二叉查找树，非常推荐）

推荐文章：

* [漫画：什么是红黑树？](https://juejin.im/post/5a27c6946fb9a04509096248)（也介绍到了二叉查找树，非常推荐）
* [寻找红黑树的操作手册](http://dandanlove.com/2018/03/18/red-black-tree/)（文章排版以及思路真的不错）
* [红黑树深入剖析及Java实现](https://zhuanlan.zhihu.com/p/24367771)（美团点评技术团队）

## B，B+，B*树

[二叉树学习笔记之B树、B+树、B*树](https://yq.aliyun.com/articles/38345)

[《B-树，B+树，B*树详解》](https://blog.csdn.net/aqzwss/article/details/53074186)

[《B-树，B+树与B*树的优缺点比较》](https://blog.csdn.net/bigtree_3721/article/details/73632405)

B-树（或B树）是一种平衡的多路查找（又称排序）树，在文件系统中有所应用。主要用作文件的索引。其中的B就表示平衡(Balance)

1. B+ 树的叶子节点链表结构相比于 B- 树便于扫库，和范围检索。
2. B+树支持range-query（区间查询）非常方便，而B树不支持。这是数据库选用B+树的最主要原因。
3. B*树 是B+树的变体，B*树分配新结点的概率比B+树要低，空间使用率更高；

## LSM 树

[[HBase\] LSM树 VS B+树](https://blog.csdn.net/dbanote/article/details/8897599)

B+树最大的性能问题是会产生大量的随机IO

为了克服B+树的弱点，HBase引入了LSM树的概念，即Log-Structured Merge-Trees。

[LSM树由来、设计思想以及应用到HBase的索引](http://www.cnblogs.com/yanghuahui/p/3483754.html)

## 哈夫曼树

### 什么是哈夫曼树

给定 N 个权值作为 N 个叶子结点，构造一棵二叉树，若该树的带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree)。哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近。

### 路径和路径长度

在一棵树中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为路径。

通路中分支的数目称为路径长度。若规定根结点的层数为1，则从根结点到第L层结点的路径长度为L-1。



![img](https://pic1.zhimg.com/80/v2-f07e3b68c7798559e664eeb6cf20ba3c_1440w.webp)



###  节点的权和带权路径长度

若将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。结点的带权路径长度为：从根结点到该结点之间的路径长度与该结点的权的乘积。



![img](https://pic2.zhimg.com/80/v2-561bb507a8adcbbed29281abac1d3485_1440w.webp)



###  树的带权路径长度

树的带权路径长度规定为所有叶子结点的带权路径长度之和，记为WPL。

如上图：数的带权路径长度为：

WPL = (2+3) * 3 + 4 * 2 + 6 * 1 = 29



### 哈夫曼树的构造

假设有n个权值，则构造出的哈夫曼树有n个叶子结点。 n个权值分别设为 w1、w2、…、wn，则哈夫曼树的构造规则为：

(1) 将w1、w2、…，wn看成是有n 棵树的森林(每棵树仅有一个结点)；

(2) 在森林中选出两个根结点的权值最小的树合并，作为一棵新树的左、右子树，且新树的根结点权值为其左、右子树根结点权值之和；

(3)从森林中删除选取的两棵树，并将新树加入森林；

(4)重复(2)、(3)步，直到森林中只剩一棵树为止，该树即为所求得的哈夫曼树。

例如：对 2，3，4，6 这四个数进行构造



![img](https://pic3.zhimg.com/80/v2-5c5bdbcdbfbacf4565bb5e99445b964a_1440w.webp)



### 特性

* 带权路径长度最短树
* $WPL=\sum_{k=1}^nW_kL_k$
* 哈夫曼树只有度为0和2的结点
* 权值大的结点离根结点近
* n个叶子的哈夫曼树的形态一般不唯一，但是WPL相同
* n个叶子的哈夫曼树有2n-1个结点
* 总结点数个数（多于1时）不能为偶数
* **n个权值均不相同的**（注意前提）字符构成哈夫曼树：树中一定没有度为1的结点，树中权值最小的结点一定是兄弟结点，树中任意非叶结点的权值一定不小于下一层任意结点的权值
* 哈夫曼编码是最优的前缀编码（任何一个编码不是其他任何编码的前缀）

手撕哈夫曼编码

```

```



## 树状数组



## 线段树
