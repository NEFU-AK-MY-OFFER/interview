# 笔试板子

* 目标：做出签到、做出板子题、剩下的骗分

## 复杂度反推

1. n<=30,指数级别
    dfs+剪枝，状压DP，指数型枚举（二进制）

2. n<=100 O(n^3)
    floyd,dp,高斯消元

3. n<=1000 O(n^2),O(n^2logn)
    dp,二分，朴素Dijkstra，朴素Prim，Bellman-Ford

4. n<=10000 O(n*sqrt(n))
    块状链表，分块，莫队

5. n<=1e5 O(nlogn)
    sort，线段树，树状数组，set/map，heap，拓扑排序，dijkstra+heap、prim+heap、spfa、求凸包、求半平面交、二分、CDQ分治、整体二分，map(超过4*1e5就别用了)

6. n<=1e6 O(n) 常数小的O(nlogn)
    **输入输出100w的时候必须scanf**

    hash，双指针，并查集，kmp，AC自动机
    常数小的O(nlogn)sort，树状数组，heap，dijkstra，spfa

7. n<=1e7 O(sqrt(n))
    判断质数

8. n<=1e18 O(logn)
    gcd,快速幂

9. n<=1e1000 O((logn)^2)
    高精加减乘除

10. n<=1e100000  O(logk*loglogk),k表示位数
    高精度加减，FFT/NTT


------



## 数学

### 质数

#### 试除法求质数

$O(sqrt(N))$

```c++
bool is_prime(long long x) {
    if (x < 2) return false;
    for (int i = 2; i <= x / i; i ++ ) { // i * i <= x可能会溢出
        if (x % i == 0) {
            return false;            
        }
    }
    return true;
}
```



#### 素数筛

**埃氏筛**

```c++
int primes[N], cnt;     // primes[]存储所有素数
bool st[N];         // st[x]存储x是否被筛掉
//筛掉每个数的倍数，如果p没有被筛掉，那么说明p不是2~p-1任何一个数倍数即，2~p-1都不是p约数
//优化：只要筛1~n所有质数的倍数就行了，唯一分解定理
void get_primes(int n)
{
    for (int i = 2; i <= n; i ++ )
    {
        if (st[i]) continue;
        primes[cnt ++ ] = i;
        for (int j = i + i; j <= n; j += i)//筛倍数
            st[j] = true;
    }
}
```

**[线性筛](https://www.acwing.com/problem/content/870/)**


```c++
int primes[N], cnt;     // primes[]存储所有素数
bool st[N];             // st[x]存储x是否被筛掉，后面可以直接用来判是否为素数
                        //n只会被最小质因子筛掉
void get_primes(int n)
{
    memset(st,0,sizeof st);
    st[0]=st[1]=1;
    for (int i = 2; i <= n; i ++ )                  //不要忘记等号
    {
        if (!st[i]) primes[++cnt] = i;
        for (int j = 1; primes[j] <= n / i; j ++ )  //不要忘记等号
        {
            st[primes[j] * i] = true;               
            //合数一定有最小质因数，用最小质因数的倍数筛去合数
            if (i % primes[j] == 0) break;
            //prime[j]一定是i最小质因子，也一定是prime[j]*i的最小质因子
        }
    }
}
```





**线性筛加速质因数分解**

```c++
//Author fishingrod
//CSDN:https://blog.csdn.net/qq_39354847
#pragma GCC optimize(2)
#pragma GCC optimize(3)
#pragma GCC optimize("Ofast")
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define int long long

ll T,Q,n,m,k,p,ans,cnt,sum,tmp,num,last;
map<int,int>prime;
int pri[N],st[N];//st标记同时预处理除i对应最小质因子

inline void get_primes(int n)
{
	memset(st,0,sizeof st);
	st[0]=st[1]=1;
	for (int i = 2; i <= n; i ++ )
	{
		if (!st[i])
		{
			 pri[++cnt]=i;
			 st[i]=i;
		}
		for (int j = 1; pri[j] <= n / i; j ++ )
		{
			st[pri[j] * i]=pri[j];
			if (i % pri[j] == 0) break;
		}
	}
}
inline void divide(int x)
{
	prime.clear();
	while(x>1)
	{
		prime[st[x]]++;
		x/=st[x];
	}
}

signed main()
{
	n=scanf("%d",&n);
	get_primes(n);
	for(int i=2; i<=n; i++)divide(i);
	return 0;
}

```

**线性筛预处理质因子个数**

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll T;
const int N=2e7+10;
ll pr[N],m[N];
bool st[N];
ll cnt;
void get_prime()
{
    for(ll i=2;i<=N;i++)
    {
        if(st[i]==0)
        {
            pr[++cnt]=i;
            m[i]=1;
        }
        for(ll j=1;pr[j]<=N/i;j++)
        {
            st[i*pr[j]]=1;
            m[i*pr[j]]=m[i]+1;
            if(i%pr[j]==0)//i是pr[j]的倍数,所以就不增加了
            {
                m[i*pr[j]]=m[i];
                break;
            }
        }
    }

}
```



### 质因数

#### 基本原理

算术基本定理可表述为：任何一个大于1的自然数 N,如果N不为质数，那么N可以唯一分解成有限个质数的乘积

$N = P_1^{a_1} P_2^{a_2} P_2^{a_2}...... P_k^{a_k}$

可以得到以下结论

* $N$ 的正约数个数 $f(N) = (a_1 + 1)(a_2 + 1)(a_3 + 1)...(a_k + 1)$
* $N$ 的正约数之和 $sum(N) = (p_1^0 + p_1^1 + ... +p_1^{a_1})(p_2^0 + p_2^1 + ... +p_2^{a_2})...(p_k^0 + p_k^1 + ... +p_k^{a_k})$



**[分解质因数](https://www.acwing.com/problem/content/869/)**

```c++
void divide(int n) {
	for(int i = 2 ; i < = n / i ; i ++ ) {
        if(n % i == 0) { //i一定是质数 
			int s = 0;	// 指数
			while(n % i == 0) {
				n /= i;
				s++;
			}
			printf("%d %d\n",i,s);
		}
    }
	if(n > 1)printf("%d %d\n",n,1);	//处理唯一一个>sqrt(n)的 
}
```



**[试除法求约数](https://www.acwing.com/problem/content/871/)**

```c++
#include<bits/stdc++.h>
using namespace std;

vector<int>get_divisors(int n)
{
	vector<int>res;
	for(int i=1;i<=n/i;i++)//从1开始，约数啊
		if(n%i==0)
		{
			res.push_back(i);
			if(i!=n/i)res.push_back(n/i);//约数通常成对出现，特判完全平方 
		}
	sort(res.begin(),res.end());
	return res;
}

int main()
{
	int n;
	cin>>n;
	while(n--)
	{
		int x;
		cin>>x;
		auto res=get_divisors(x);
		for(auto t:res)cout<<t<<' ';
		cout<<endl;
	}
}
```

**[约数个数(多个数相乘的)](https://www.acwing.com/problem/content/872/)**

```c++
#include<bits/stdc++.h>
using namespace std;

typedef long long LL;

const int mod=1e9+7;

int main()
{
	int n;
	cin>>n;
	unordered_map<int,int>primes;
	while(n--)
	{
		int x;
		cin>>x;
		for(int i=2;i<=x/i;i++)
			while(x%i==0)
			{
				x/=i;
				primes[i]++;
			}
		if(x>1)primes[x]++;
	}
	LL res=1;
	for(auto prime:primes)res=res*(prime.second+1)%mod;
	cout<<res<<endl;
	return 0;
}
```

**约数个数和**

```c++
#include<bits/stdc++.h>
using namespace std;


int main()
{
    int res=0,n;
    cin>>n;
    for(int i=1;i<=n;i++)res+=n/i;
    cout<<res;
    return 0;
}
```

**[约数和](https://www.acwing.com/problem/content/873/)**

```c++
#include<bits/stdc++.h>
using namespace std;

const int mod=1e9+7;
typedef long long LL;
int main()
{
    int n,x;
    unordered_map<int,int>primes;
    cin>>n;
    while(n--)
    {
        cin>>x;
        for(int i=2;i<=x/i;i++)
            while(x%i==0)
            {
                x/=i;
                primes[i]++;
            }
        if(x>1)primes[x]++;
    }
    LL res=1;
    for(auto prime:primes)
    {
        int p=prime.first,a=prime.second;
        LL t=1;
        while(a--)t=(t*p+1)%mod;
        res=res*t%mod;
    }
    cout<<res<<endl;
    return 0;
}
```

### 欧拉函数

**欧拉函数**

```c++
ll phi(ll x)
{
    ll res = x;
    for (int i = 2; i <= x / i; i ++ )
        if (x % i == 0)
        {
            res = res / i * (i - 1);
            while (x % i == 0) x /= i;
        }
    if (x > 1) res = res / x * (x - 1);

    return res;
}
```

**筛法求欧拉函数（1~n,欧拉函数之和）**

```c++
#include<bits/stdc++.h>
using namespace std;

typedef long long ll;
const int N=1e6+10;

ll n,primes[N],phi[N],cnt;
bool st[N];

ll get_eulers(ll n)
{
	phi[1]=1;
	for(int i=2;i<=n/i;i++)
	{
		if(!st[i])
		{
			prime[cnt++]=i;
			phi[i]=i-1;
		}
		for(int j=0;prime[j]<=n/i;j++)
		{
			st[i*primes[j]]=1;
			if(i%primes[j]==0)
			{
				phi[primes[j]*i]=phi[i]*primes[j];
				break; 
			}
			phi(primes[j]*i)=phi[i]*(primes[j]-1) 
		} 
	}
	ll res=0;
	for(int i=1;i<=n;i++)res+phi[i];
	return res;
}

int main()
{
	ll n;
	cin>>n;
	
	cout<<get_eulers(n)<<endl;
	
	return 0;
}
```

### 逆元

#### 费马小定理

```cpp
template<typename T>
const T MOD = 1e9 + 7;
T Q_Power(T a , T b ){
    T res = 1;
    while(b){
        if(b & 1) res = (res * a) % MOD;
        b >>= 1;
        a = (a * a) %　MOD;
    }
}

T X_1(T a){ return Q_Power(a,MOD - 2) ; }  //逆元
```

>费马小定理主要用于求解在取模为素数的情况下，对于式子 $a\times x \equiv 1 \mod MOD$ 求解 a 的逆元 x ，与上述 扩展欧几里得算法拥有相当的时间复杂度，但却更好写些。

#### 整除分块

>以下为例题的解法  
>&emsp;&emsp;求:$\sum_{i=1}^n\lfloor\frac n i\rfloor$
>(待更新)

```cpp
for(int l = 1 , r ; l <= n ; l = r + 1){
    r = n / (n / l);
    ans += (r - l + 1) * (n / l);
}
```

### 排列组合

#### 组合数

**递推**

```c++
for (int i = 0; i < N; i ++ )
    for (int j = 0; j <= i; j ++ )
        if (!j) c[i][j] = 1;
        else c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod;
```

**预处理逆元求组合数**

```c++
首先预处理出所有阶乘取模的余数fact[N]，以及所有阶乘取模的逆元infact[N]
如果取模的数是质数，可以用费马小定理求逆元
int qmi(int a, int k, int p)    // 快速幂模板
{
    int res = 1;
    while (k)
    {
        if (k & 1) res = (LL)res * a % p;
        a = (LL)a * a % p;
        k >>= 1;
    }
    return res;
}

// 预处理阶乘的余数和阶乘逆元的余数
fact[0] = infact[0] = 1;
for (int i = 1; i < N; i ++ )
{
    fact[i] = (LL)fact[i - 1] * i % mod;
    infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
}
```

**Lucas定理**

```c++
若p是质数，则对于任意整数 1 <= m <= n，有：
    C(n, m) = C(n % p, m % p) * C(n / p, m / p) (mod p)

int qmi(int a, int k, int p)  // 快速幂模板
{
    int res = 1 % p;
    while (k)
    {
        if (k & 1) res = (LL)res * a % p;
        a = (LL)a * a % p;
        k >>= 1;
    }
    return res;
}

int C(int a, int b, int p)  // 通过定理求组合数C(a, b)
{
    if (a < b) return 0;

    LL x = 1, y = 1;  // x是分子，y是分母
    for (int i = a, j = 1; j <= b; i --, j ++ )
    {
        x = (LL)x * i % p;
        y = (LL) y * j % p;
    }

    return x * (LL)qmi(y, p - 2, p) % p;
}

int lucas(LL a, LL b, int p)
{
    if (a < p && b < p) return C(a, b, p);
    return (LL)C(a % p, b % p, p) * lucas(a / p, b / p, p) % p;
}
```

**分解质因数法求组合数**

```c++
当我们需要求出组合数的真实值，而非对某个数的余数时，分解质因数的方式比较好用：
    1. 筛法求出范围内的所有质数
    2. 通过 C(a, b) = a! / b! / (a - b)! 这个公式求出每个质因子的次数。 n! 中p的次数是 n / p + n / p^2 + n / p^3 + ...
    3. 用高精度乘法将所有质因子相乘

int primes[N], cnt;     // 存储所有质数
int sum[N];     // 存储每个质数的次数
bool st[N];     // 存储每个数是否已被筛掉


void get_primes(int n)      // 线性筛法求素数
{
    for (int i = 2; i <= n; i ++ )
    {
        if (!st[i]) primes[cnt ++ ] = i;
        for (int j = 0; primes[j] <= n / i; j ++ )
        {
            st[primes[j] * i] = true;
            if (i % primes[j] == 0) break;
        }
    }
}


int get(int n, int p)       // 求n！中的次数
{
    int res = 0;
    while (n)
    {
        res += n / p;
        n /= p;
    }
    return res;
}


vector<int> mul(vector<int> a, int b)       // 高精度乘低精度模板
{
    vector<int> c;
    int t = 0;
    for (int i = 0; i < a.size(); i ++ )
    {
        t += a[i] * b;
        c.push_back(t % 10);
        t /= 10;
    }

    while (t)
    {
        c.push_back(t % 10);
        t /= 10;
    }

    return c;
}

get_primes(a);  // 预处理范围内的所有质数

for (int i = 0; i < cnt; i ++ )     // 求每个质因数的次数
{
    int p = primes[i];
    sum[i] = get(a, p) - get(b, p) - get(a - b, p);
}

vector<int> res;
res.push_back(1);

for (int i = 0; i < cnt; i ++ )     // 用高精度乘法将所有质因子相乘
    for (int j = 0; j < sum[i]; j ++ )
        res = mul(res, primes[i]);
```

#### Stirling数

**第一类**

**第二类**

用于求解n个不同小球分为m相同堆，且不存在空的方案数

```c++
for(int i=1;i<=n;i++){
		stir[i][i]=1;
		stir[i][0]=0;
	}
	for(int i=2;i<=n;i++)
		for(int j=1;j<=m;j++)
			stir[i][j]=stir[i-1][j]*j+stir[i-1][j-1];
```

**Bell数**

Bell（n）为基数为n的集合划分方案数(非空），他是第二类stirling数之和

$Bell(n)=\sum_{k=1}^nStirling(n,k)$

**错排**

```c++
LL D[N]={1,0};//0是1，1是0别写错了
for(int i=2;i<=N;i++)D[i]=(i-1)*(D[i-1]+D[i-2])%mod;
```



### 阶乘



**阶乘位数**

```c++
#include<bits/stdc++.h>
using namespace std;
int main()
{
	double n;
	while(cin>>n)
	{
		double s=0;
		for(int i=1;i<=n;i++)s+=log10(i);//n!取对数
		cout<<int(s)+1<<endl;
	}
	return 0;
}
```

### 斐波那契数列

矩阵快速幂

```cpp
ll Fib_Q_M_Power(ll n){
    if(n <= 1) return n;
    if(n == 2) return 1;
    ll ans[2][2] = {1,0,0,1}, tmp[2][2] , a[2][2] = {1,1,1,0};
    while(n){
        if(n & 1){
            memset(tmp,0,sizeof(tmp));
            for(int i = 0 ; i < 2 ; i ++ ){
                for(int j = 0 ; j < 2 ; j ++ ){
                    for(int k = 0 ; k < 2 ; k ++ ){
                        tmp[i][j] = (tmp[i][j] + ans[i][k] * a[k][j] % MOD) % MOD;
                    }
                }
            }

            for(int i = 0 ; i < 2 ; i ++ ){
                for(int j = 0 ; j < 2 ; j ++ ) ans[i][j] = tmp[i][j];
            }

        }

        n >>= 1;
        memset(tmp,0,sizeof(tmp));
        for(int i = 0 ; i < 2 ; i ++ ){
            for(int j = 0 ; j < 2 ; j ++ ){
                for(int k = 0 ; k < 2 ; k ++ ){
                    tmp[i][j] = (tmp[i][j] + a[i][k] * a[k][j] % MOD) % MOD;
                }
            }
        }

        for(int i = 0 ; i < 2 ; i ++ ){
            for(int j = 0 ; j < 2 ; j ++ ){
                a[i][j] = tmp[i][j];
            }
        }

    }
    return ans[1][0];
}
```

### 扩展欧几里得

扩欧求解同余方程ax+by=1（要求解最小正整数）

```c++
#include<bits/stdc++.h>
using namespace std;

typedef long long LL;

int exgcd(int a,int b ,int &x,int &y)
{
    if(!b)
    {
        x=1,y=0;
        return a;
    }
    
    int d=exgcd(b,a%b,y,x);
    y-=a/b*x;
    return d;
}
int get_mod(int a,int b)
{
    return (a%b+b)%b;
}
int main()
{
    int a,b;
    cin>>a>>b;
    int x,y;
    exgcd(a,b,x,y);
    cout<<get_mod(x,b)<<endl;
    return 0;
}

```

**求解线性同余方程ax+my=b**（保证解在int范围内）

```c++
#include<bits/stdc++.h>
using namespace std;

typedef long long LL;
int exgcd(int a,int b,int &x,int &y)
{
    if(!b)
    {
        x=1,y=0;
        return a;
    }
    int d=exgcd(b,a%b,y,x);
    y-=a/b*x;
    return d;
}

int main()
{
    int n;
    cin>>n;
    while(n--)
    {
        int a,b,m,x,y;
        cin>>a>>b>>m;
        //即求解ax+my=b
        int d=exgcd(a,m,x,y);
        if(b%d)puts("impossible");//gcd(a,b)|b看有没有解
        else cout<<(LL)x*b/d%m<<endl;
    }
    return 0;
}

```

**小结**

x1，y1为ax+by=c的特解 
那么他的**最小正整数解**为
$d=gcd(a,b),p=abs(\frac b d)防止出现负数$
$x=((x+p)\%p)\%p,如果x=0那么x=p$
**输出int范围内的解**
$x=x1\%b$

### 博弈论

**SG函数**（以NIM集合博弈为例题，每次可以拿走集合里的数）

```c++
#include<bits/stdc++.h>
using namespace std;
const int N=110,M=10010;
int n,m;
int s[N],f[M];
int sg(int x){//这是一棵搜索树 
	if(f[x]!=-1)return f[x];//记忆化搜索 保证时间复杂度不是指数级别 每个状态只算一次 记忆化搜索是对搜索的一种优化，也是动态规划的一种实现方式
	unordered_set<int>S;//所有可以到的局面，函数内部声明，后面递归出来的和本次的S是不一样的
	for(int i=0;i<m;++i){
		int sum=s[i]; //当前的数的个数是s[i] 
		if(x>=sum) S.insert(sg(x-sum)); //当前的数的个数大于sum 才能把它加进来 从x中取走s[i]个石子，要递归下去啊!
	}
	for(int i=0;;++i){//不属于当前集合的最小自然数 MEX 
		if(!S.count(i)) return f[x]=i;
	}
}
 
int main(){
	cin>>m;
	for(int i=0;i<m;++i)cin>>s[i];
	cin>>n;
	memset(f,-1,sizeof(f));//初始化
	int res=0;
	for(int i=0;i<n;++i){
		int x;
		cin>>x;//对每一堆求sg然后异或起来
		res^=sg(x);
	}
	if(res)puts("Yes");
	else puts("No");
}
```

**常见博弈结论**

1. **尼姆游戏 Nim   Game**

    给定 N 堆物品，第i堆物品有Ai个。两名玩家轮流行动，每次可以任选一堆，取走任意多个物品，可把一堆取光，但不能不取。**取走最后一件物品者获胜**。两人都采取最优策略，问先手是否必胜。

    结论:异或和为0，先手必败，反之先手必胜

2. **巴什博弈 Bash Game**

    有 1 堆石子，总个数是 n ，两名玩家轮流在石子堆中拿石子，每次至少取 1 个，至多取 m 个。**取走最后一个石子的玩家为胜者**。判定先手和后手谁胜。

    结论：若 ( m + 1 )  ∣  n （整除）则先手必败，否则先手必胜

3. **威佐夫博弈 Wythoff Game**

    有两堆石子，石子数可以不同。两人轮流取石子，每次可以在一堆中取，或者从两堆中取走相同个数的石子，数量不限，**取走最后一个石头的人获胜**。判定先手是否必胜。

    结论：假设两堆石子为(a,b)其中（a<b)，当且仅当$(b-a)*\frac {\sqrt 5 +1} 2=a$,反之必胜

4. **斐波那契博弈 Fibonacci Game**

    有一堆个数为 n ( n ≥ 2 ) 的石子，游戏双方轮流取石子，规则如下：

    先手不能在第一次把所有的石子取完，至少取 1 颗；

    之后每次可以取的石子数至少为 1 ，至多为对手刚取的石子数的 2  倍。

    约定**取走最后一个石子的人为赢家**，求必败态。

    结论:先手必败，当且仅当石子数为斐波那契数

    （有一个定理，任何正整数可以表示为若干个不连续斐波那契数之和）

**阶梯博弈**

**k倍减法游戏**

**对称构造**

**极大极小搜索**

**翻硬币游戏**

**树删边游戏**

**无向图删边游戏**

**nim积**

**混合纳什均衡**

**surreal number**

### 进制与位运算

#### 进制转换

```c++
// 字符串转为数字 注意确保字符串是数字并且不超过 int，否则抛异常
std::string str = "123";
int num = std::stoi(str);

// 指定字符串进制
std::string str = "1011";
int num = std::stoi(str, nullptr, 2);

// 数字转字符串
int num = 123;
std::string str = std::to_string(num);
```



#### 二进制枚举

**枚举子集  O(2^|S|),|S|表示集合中元素个数**

```c++
// S 是一个二进制数（二进制每位数字对应一种状态），表示一个集合，i 枚举 S 的所有子集
//s=9=1001,有子集9=1001,8=1000,1=0001
for (int i = S; i; i = S & i - 1)
    
//[0,2^n-1]，n个元素的子集有2^n个
for(int i = 0;i<(1<<n);i++)
```

**枚举方案**

```c++
for(int i=0;i<(1<<n);i++) {
    for(int j=0;j<n;j++) {
        if(i& (1<<j)) {
            array[j] //别写成array[i]
        }
    }
}
```

**枚举子集的子集O(3^n)**

```c++
for (int S = 0; S < 1 << n; S ++ ) // 枚举集合 {0, ..., n - 1} 的所有子集
    for (int i = S; i; i = S & i - 1) // 枚举子集 S 的子集
        // blablabla
```



#### 求二进制中1的个数

```c++
int count(int x) {
    int res = 0;
    while (x) res += x & 1, x >>= 1;
    return res;
}
```



#### 快速幂

[50. Pow(x, n) - 力扣（Leetcode）](https://leetcode.cn/problems/powx-n/description/)

```c++
//如果mod 1e18级别，改成加法防爆
int quick(int a,int b) {
    int res=1;
    a=a%mod;
    while(b) { 
        if(b&1) res=(res*a)%mod;//改成+
        a=(a*a)%mod;//改成+
        b>>=1;
    }
    return res;
}
```



## 数据结构

### 单调栈

求左边第一个或右边第一个比当前数大/小的位置



### 单调队列

求滑动窗口最值

```cpp
void get_min(int a[], int b[], int tot)
{
    int hh = 0, tt = -1;
    for (int i = 1; i <= tot; i ++ )
    {
        if (hh <= tt && q[hh] < i - k + 1) hh ++ ;
        while (hh <= tt && a[q[tt]] >= a[i]) tt -- ;
        q[ ++ tt] = i;
        b[i] = a[q[hh]];
    }
}

void get_max(int a[], int b[], int tot)
{
    int hh = 0, tt = -1;
    for (int i = 1; i <= tot; i ++ )
    {
        if (hh <= tt && q[hh] <= i - k) hh ++ ;
        while (hh <= tt && a[q[tt]] <= a[i]) tt -- ;

        q[ ++ tt] = i;
        //因为第i个元素也可能包含，所以最后再处理
        b[i] = a[q[hh]];
    }
}


/*
求区间长度S~T的区间最小值
int l=1,r=0;
for(int i=s;i<=n;i++){
		while(l<=r&&sum[q[r]]>=sum[i-s])r--;//发现降序，弹出队尾
		q[++r]=i-s;
		while(l<=r&&q[l]<i-t)l++;//超出长度了弹出队首
		if(l<=r&&sum[i]-sum[q[l]]>=0)return 1;//这行根据题目写
	}

*/
```

**二维单调队列**

```c++
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;
const int N = 1010,INF = 1e9;
int row_min[N][N],row_max[N][N];
//row_min[i][j]表示当前第i行，第[j - m + 1,j]这个区间的最小值，row_max同理
int n,m,k;  //表示n * m的矩阵，选出k * k矩阵的最大整数和最小整数的差值”的最小值
int w[N][N]; 
int q[N]; //优先队列

void get_min(int a[], int b[], int tot)
{
    int hh = 0, tt = -1;
    for (int i = 1; i <= tot; i ++ )
    {
        if (hh <= tt && q[hh] < i - k + 1) hh ++ ;
        while (hh <= tt && a[q[tt]] >= a[i]) tt -- ;
        q[ ++ tt] = i;
        b[i] = a[q[hh]];
    }
}

void get_max(int a[], int b[], int tot)
{
    int hh = 0, tt = -1;
    for (int i = 1; i <= tot; i ++ )
    {
        if (hh <= tt && q[hh] <= i - k) hh ++ ;
        while (hh <= tt && a[q[tt]] <= a[i]) tt -- ;

        q[ ++ tt] = i;
        //因为第i个元素也可能包含，所以最后再处理
        b[i] = a[q[hh]];
    }
}



int main(){
    cin >> n >> m >> k;
    for(int i = 1;i <= n;++i){
        for(int j = 1;j <= m;++j){
            scanf("%d",&w[i][j]);
        }
    }

    //分别找到每一行的每个[j - n - 1,j]区间的最小值和最大值
    for(int i = 1;i <= n;++i){
        get_min(w[i],row_min[i],m);
        get_max(w[i],row_max[i],m);
    }

    int res = INF;

    //ans表示当前这一列中所有横向区间的最值
    int ans[N],col_min[N],col_max[N]; //col_max,col_min分别表示竖直长度是n的区间的最小值和最大值

    //接着找到每列的最大值和最小值（直接从第n列开始,即表示第一个n * n的矩阵的每行内的最大元素）
    for(int j = k;j <= m;++j){ 
        //枚举列，因为第一个区间内的最大值或者最小值开始是存放在下标为n

        //枚举行，计算当前这一列中所有横向区间的最值复制给ans
        for(int i = 1;i <= n;++i) ans[i] = row_min[i][j];
        get_min(ans,col_min,n);   //最多有n行


        for(int i = 1;i <= n;++i) ans[i] = row_max[i][j];
        get_max(ans,col_max,n);



        //枚举当前这一列区间的所有最大值和最小值的差值，（也是从第k行开始）
        for(int i = k;i <= n;++i){
            res = min(res,col_max[i] - col_min[i]);
        }
    }

    cout << res << endl;
    return 0;
}
```



### Trie树

[208. 实现 Trie (前缀树) - 力扣（Leetcode）](https://leetcode.cn/problems/implement-trie-prefix-tree/description/)

```c++
class Trie {
private:
    bool isEnd;
    vector<Trie*> children;
public:
    Trie() : children(26), isEnd(false) {}
    
    void insert(string word) {
        Trie* node = this;
        for(char ch : word) {
            int idx = ch - 'a';
            if(node->children[idx] == nullptr) {
                node->children[idx] = new Trie();
            }
            node = node->children[idx];
        }
        node->isEnd = true;
    }
    
    bool search(string word) {
        Trie* node = this;
        for(char ch : word) {
            int idx = ch - 'a';
            if(node->children[idx] == nullptr) return false;
            node = node->children[idx];
        }
        return node->isEnd;
    }
    
    bool startsWith(string prefix) {
        Trie* node = this;
        for(char ch : prefix) {
            int idx = ch - 'a';
            if(node->children[idx] == nullptr) return false;
            node = node->children[idx];
        }
        return true;
    }
};
```





### 并查集

```c++
int find(int x) {
	return fa[x] = (x == fa[x] ? x : find(fa[x]));
}
```



### ST 表

[1273. 天才的记忆 - AcWing题库](https://www.acwing.com/problem/content/1275/)

* 区间最值
* $O(nlogn)$ 预处理，$O(1)$ 查询
* ST 表使用一个二维数组对范围内的所有 $f[b][a]$， 先计算出并存储 $[a, a + 2^b - 1]$ 区间的最值，区间长度 $2^b$；查询时再利用这些子区间求代求区间最大值
* `std::__lg(n)` 是 $O(1)$ 的，用于计算一个整数的二进制表示中最高位的位置。具体来说，它返回的是这个整数对应二进制数的对数（向下取整）

```cpp
int A[N], f[__lg(N) + 1][N];	
void init(int n) {
    for (int i = 1; i <= n; ++i)
        f[0][i] = A[i];
    for (int i = 1; i <= __lg(n); ++i)	// len = 2^i
        for (int j = 1; j + (1 << i) - 1 <= n; ++j)
            // [j, j + 2^i - 1]
            // [j, j + 2^(i - 1) - 1],[j + 2^(i - 1), j + 2 ^i - 1]
            f[i][j] = max(f[i - 1][j], f[i - 1][j + (1 << (i - 1))]);
}
int query(int l, int r) {
    int s = __lg(r - l + 1);
    // [l, r]
    // [l, l + 2 ^ s - 1], [r - 2 ^ s + 1, r]
    return max(f[s][l], f[s][r - (1 << s) + 1]);
}
```

### 树状数组

[307. 区域和检索 - 数组可修改 - 力扣（Leetcode）](https://leetcode.cn/problems/range-sum-query-mutable/)

```c++
// 确保下标是从 1 开始的 ！
int lowbit(int x) {
    return x&(-x);
}
int tree[MAXN];

// 单点加
void add(int x,int y) {
    for(; x <= n; x += lowbit(x)) tree[x] += y;
}

// 单点更新
void update(int x, int y) {
    // tree[x] 并不是 x 位置的数据
    int oldvalue = ask(x) - ask(x - 1);
    add(x, y - oldvalue);
}

// 查询前缀和
int ask(int x) {
    int ans=0;
    for(; x; x -= lowbit(x)) ans += tree[x];	// x > 0 不是 x >= 0
    return ans;
}

// 区间查询 ask(b) - ask(a - 1)
```





### 线段树

**普通线段树单点修改**

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
const int N=5e5+10;
int n,m;
LL w[N];
struct Node{
    int l,r;
    LL tmax;
    LL lmax,rmax;
    LL sum;
}tr[N*4];
/*维护更新信息*/
void pushup(Node &u,Node &l,Node &r){
    u.sum=l.sum+r.sum;
    u.lmax=max(l.lmax,l.sum+r.lmax);
    u.rmax=max(r.rmax,r.sum+l.rmax);
    u.tmax=max(l.rmax+r.lmax,max(l.tmax,r.tmax));
}

void pushup(int u){
    pushup(tr[u],tr[u<<1],tr[u<<1|1]);
}

void build(int u,int l,int r){
    if(l==r)tr[u]={l,r,w[r],w[r],w[r],w[r]};//叶子节点
    else{
        tr[u]={l,r};//别忘记
        int mid=(l+r)>>1;
        build(u<<1,l,mid),build(u<<1|1,mid+1,r);//递归左右区间
        pushup(u);
    }
}

void modify(int u,int x,LL v){
    if(tr[u].l==x&&tr[u].r==x)tr[u]={x,x,v,v,v,v};//叶子节点
    else{
        int mid=(tr[u].l+tr[u].r)>>1;
        if(x<=mid)modify(u<<1,x,v);
        else modify(u<<1|1,x,v);
        pushup(u);
    }
}
/*因为查询也有很多信息要合并所以直接传结构体方便些*/
Node query(int u,int l,int r){
    if(tr[u].l>=l&&tr[u].r<=r)return tr[u];//区间被包含
    else{
        int mid=(tr[u].l+tr[u].r)>>1;
        if(r<=mid)return query(u<<1,l,r);
        else if(l>mid)return query(u<<1|1,l,r);
        else{
            auto left=query(u<<1,l,r);
            auto right=query(u<<1|1,l,r);
            Node res;
            pushup(res,left,right);//合并左右子区间答案
            return res;
        }
    }
}
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)scanf("%lld",&w[i]);
    build(1,1,n);
    
    int k,x,y;
    while(m--){
        scanf("%d%d%d",&k,&x,&y);
        if(k==1){
            if(x>y)swap(x,y);
            printf("%lld\n",query(1,x,y).tmax);
        }
        else modify(1,x,y);
    }
    return 0;
}
```

**普通线段树区间修改**

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
const int N=5e5+10;
int n,m;
LL w[N];
struct Node{
    int l,r;
    LL sum,add;
}tr[N*4];
/*维护更新信息*/
void pushup(Node &u,Node &l,Node &r){
    u.sum=l.sum+r.sum;
}

void pushup(int u){
    pushup(tr[u],tr[u<<1],tr[u<<1|1]);
}

void pushdown(int u){
    auto &root=tr[u],&left=tr[u<<1],&right=tr[u<<1|1];
    if(root.add){//如果存在延迟标记
        left.sum+=(LL)(left.r-left.l+1)*root.add;//更新左节点信息
        right.sum+=(LL)(right.r-right.l+1)*root.add;//更新右节点信息
        left.add+=root.add;//给左节点打延迟标记
        right.add+=root.add;//给右节点打延迟标记
        root.add=0;//清空父节点延迟标记
    }
}
void build(int u, int l, int r)
{
    if (l == r) tr[u] = {l, r, w[r], 0};
    else
    {
        tr[u] = {l, r};
        int mid = l + r >> 1;
        build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);
        pushup(u);
    }
}

void modify(int u,int l,int r,int d){
    if(tr[u].l>=l&&tr[u].r<=r){//完全覆盖
        tr[u].sum+=(LL)(tr[u].r-tr[u].l+1)*d;//更新节点信息
        tr[u].add+=d;//给节点打上标记
    }
    else{
        pushdown(u);//下传延迟标记
        int mid=(tr[u].l+tr[u].r)>>1;
        if(l<=mid)modify(u<<1,l,r,d);
        if(r>mid)modify(u<<1|1,l,r,d);
        pushup(u);//更新节点信息
    }
}

LL query(int u,int l,int r){
    if( tr[u].l >= l && tr[u].r <= r)return tr[u].sum;//区间被包含
    pushdown(u);//下传延迟标记
    int mid=(tr[u].l+tr[u].r)>>1;
    LL sum=0;
    if(l<=mid)sum=query(u<<1,l,r);
    if(r>mid)sum+=query(u<<1|1,l,r);
    return sum;
}

int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)scanf("%lld",&w[i]);
    build(1,1,n);
    
    char op[2];
    int l,r,d;
    while(m--){
        scanf("%s%d%d",op,&l,&r);
        if(*op=='C'){
            scanf("%d",&d);
            modify(1,l,r,d);
        }
        else printf("%lld\n",query(1,l,r));
    }
    return 0;
}

```

### LCA





## 搜索与图论

### 存图

**vector 邻接表**

```c++
//如果没有边权可以不使用结构体，只存储终点即可
struct Edge {
    int to, w;
};

std::vector<Edge> edges[MAXN];
std::unordered_map<int, std::vector<Edge>> edges;
std::vector <std::vector<Edge>> edges;

void add(int from, int to, int w)
{
    Edge e = {to, w};
    edges[from].push_back(e);  //向vector的最后添加一条边
}

// 对于无向图，调用两次add()即可
inline void add2(int u, int v, int w)
{
    add(u, v, w);
    add(v, u, w);
}

// 遍历(无向图)
void dfs(int curr, int fa){
	// 相关逻辑
    for(int to : edges[curr]){
    	if(to == fa)continue;
        dfs(to ,curr);
        //递归完后开始更新子树，然后一层层向上更新
    }
}
dfs(1,-1);

for(int i= 1;i <= n;i++)edges[i].clear();
```

### 最短路

[850. Dijkstra求最短路 II - AcWing题库](https://www.acwing.com/problem/content/852/)

```c++
#include <bits/stdc++.h>
using namespace std;

using PII = pair<int,int>;

int n, m;
vector<vector<PII>> graph;

int dijkstra() {
    vector<int> dist(n + 1, 0x3f3f3f3f);
    vector<bool> st(n + 1, false);	// 判断是否已经求出最短路径
    
    priority_queue<PII, vector<PII>, greater<PII>> heap;    // {edgeLen, node}
    dist[1] = 0;
    heap.push({0, 1});
    
    while(!heap.empty()) {
        auto t = heap.top();
        heap.pop();
        
        auto [_, node] = t;
        
        if(st[node]) continue;
        st[node] = true;
        
        // 以 node 为桥梁更新每个出边
        for(const auto & [nextNode, edgeLen] : graph[node]) {
            if(dist[nextNode] > dist[node] + edgeLen) {
                dist[nextNode] = dist[node] + edgeLen;
                heap.push({dist[nextNode], nextNode});
            }
        } 
    }
    
    return dist[n] == 0x3f3f3f3f ? -1 : dist[n];
}

int main() {
    cin >> n >> m;
    graph.resize(n + 1);
    for(int i = 0; i < m; ++i) {
        int a, b, c;
        cin >> a >> b >> c;
        graph[a].push_back({b, c});
    }
    
    cout << dijkstra();
    return 0;    
}
```



**bellman_ford()(处理边数限制)**

```c++
#include<bits/stdc++.h>
using namespace std;


const int N=510,M=10010;


int n,m,k;
int dist[N],backup[N];


struct Edge
{
    int a,b,w;
}edges[M];


int bellman_ford()
{
    memset(dist,0x3f,sizeof dist);
    dist[1]=0;//初始化
    for(int i=0;i<k;i++)
    {
        memcpy(backup,dist,sizeof dist);//防止串联更新
        for(int j=0;j<m;j++)
        {
            int a=edges[j].a,b=edges[j].b,w=edges[j].w;
            dist[b]=min(dist[b],backup[a]+w);//用备份更新
        }
    }
    if(dist[n]>0x3f3f3f3f/2)return -1;//
    return dist[n];
}
int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    cin>>n>>m>>k;
    
    for(int i=0;i<m;i++)
    {
        int a,b,w;
        cin>>a>>b>>w;
        edges[i]={a,b,w};
    }
    int t=bellman_ford();
    if(t==-1)puts("impossible");
    else cout<<t<<endl;
    return 0;
}
```

**SPFA**

```c++
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+10;
int h[N],e[N],w[N],ne[N],idx;
bool st[N];
int dist[N];
int n,m;
void add(int a,int b,int c)
{
    e[idx]=b,w[idx]=c,ne[idx]=h[a],h[a]=idx++;
}


int spfa()
{
    memset(dist,0x3f,sizeof dist);
    dist[1]=0;
    queue<int>q;
    q.push(1);
    st[1]=1;
    while(q.size())
    {
        int t=q.front();
        q.pop();
        st[t]=0;
        for(int i=h[t];i!=-1;i=ne[i])
        {
            int j=e[i];
            if(dist[j]>dist[t]+w[i])
            {
                dist[j]=dist[t]+w[i];
                if(!st[j])
                {
                    q.push(j);
                    st[j]=1;
                }
            }
        }
    }
    if(dist[n]>0x3f3f3f3f/2)return -1;
    return dist[n];
}
int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    cin>>n>>m;
    memset(h,-1,sizeof h);
    while(m--)
    {
        int a,b,c;
        cin>>a>>b>>c;
        add(a,b,c);
    }
    int t=spfa();
    if(t==-1)puts("impossible");
    else cout<<t<<endl;
    return 0;
}
```

**SPFA（判有无负权环）**

```c++
#include<bits/stdc++.h>
using namespace std;


const int N=2010,M=10010;
int h[N],e[M],ne[M],w[M],idx;
int dist[N],cnt[N];
bool st[N];
int n,m;
void add(int a,int b,int c)
{
    e[idx]=b,w[idx]=c,ne[idx]=h[a],h[a]=idx++;
}
bool spfa()
{
    queue<int>q;
    for(int i=1;i<=n;i++)q.push(i),st[i]=1;
    while(q.size())
    {
        int t=q.front();
        q.pop();
        st[t]=0;
        for(int i=h[t];i!=-1;i=ne[i])
        {
            int j=e[i];
            if(dist[j]>dist[t]+w[i])
            {
                dist[j]=dist[t]+w[i];
                cnt[j]=cnt[t]+1;//不要写++cnt[j]，重边会影响的
                if(cnt[j]>=n)return 1;
                if(!st[j])
                {
                    q.push(j);
                    st[j]=1;
                }
            }
        }
    }
    return 0;
}
int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    cin>>n>>m;
    memset(h,-1,sizeof h);
    while(m--)
    {
        int a,b,c;
        cin>>a>>b>>c;
        add(a,b,c);
    }
    if(spfa())cout<<"Yes"<<endl;
    else cout<<"No"<<endl;
    return 0;
}
```

**Floyd(多源汇最短路)**

```c++
#include<bits/stdc++.h>
using namespace std;
int n,m,q;
const int N=210,INF=1e9;
int d[N][N];

void floyd()
{
    for(int k=1;k<=n;k++)//先循环k
        for(int i=1;i<=n;i++)
            for(int j=1;j<=n;j++)
                d[i][j]=min(d[i][j],d[i][k]+d[k][j]);
}
int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    cin>>n>>m>>q;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            if(i==j)d[i][j]=0;//处理自环
            else d[i][j]=INF;
    
    while(m--)
    {
        int a,b,w;
        cin>>a>>b>>w;
        d[a][b]=min(d[a][b],w);
    }
    floyd();
    while(q--)
    {
        int a,b;
        cin>>a>>b;
        if(d[a][b]>INF/2)cout<<"impossible"<<endl;
        else cout<<d[a][b]<<endl;
    }
    return 0;
}
```

**[Floyd求最短环](https://www.luogu.com.cn/problem/P6175)**

```c++
#include<bits/stdc++.h>
using namespace std;
const int N=200;
typedef long long ll;
const int INF=0x7f7f7f7f;
ll g[N][N],dist[N][N];
int n,m;
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			if(i!=j)dist[i][j]=g[i][j]=INF;
	while(m--)
	{
		ll a,b,c;
		cin>>a>>b>>c;
		g[a][b]=g[b][a]=min(g[a][b],c);
		dist[a][b]=dist[b][a]=min(g[a][b],c);
	}
	ll ans=INF;
	for(int k=1;k<=n;k++)
	{
		for(int i=1;i<k;i++)
			for(int j=i+1;j<k;j++)
				ans=min(ans,dist[i][j]+g[i][k]+g[k][j]);
		for(int i=1;i<=n;i++)
			for(int j=1;j<=n;j++)
			{
				dist[i][j]=min(dist[i][j],dist[i][k]+dist[k][j]);
				dist[j][i]=dist[i][j];
			}
	}
	if(ans==INF)cout<<"No solution.";
	else cout<<ans;
	return 0;
}
```

### 最小生成树

**[Kruskal（稀疏图）(O(mlogm))](https://www.acwing.com/problem/content/861/)**

```c++
#include <bits/stdc++.h>
using namespace std;

struct Edge {
    int a, b, w;
    Edge(int a, int b, int w) : a(a), b(b), w(w) {}
    bool operator< (const Edge & rhs) {
        return this->w < rhs.w;
    }
};

vector<Edge> edges;
vector<int> fa;

int find(int x) {
    return fa[x] = (fa[x] == x ? x : find(fa[x]));
}

int n, m;

int kruskal() {
    int ans = 0, cnt = 1;
    for(int i = 0; i < m; i++) {
        int fx = find(edges[i].a);        
        int fy = find(edges[i].b);
        if(fx != fy) {
            cnt++;
            ans += edges[i].w;
            fa[fx] = fy;
        }
    }
    
    return cnt == n ? ans : -1;
}

int main() {
    cin >> n >> m;
    for(int i = 0; i < m; ++i) {
        int a, b, w; cin >> a >> b >> w;
        edges.emplace_back(a, b, w);
    }
    sort(edges.begin(), edges.end());
    
    fa.resize(n + 1);
    for(int i = 1; i <= n; ++i) fa[i] = i;
    
    int  t = kruskal();
    if(t == -1) cout << "impossible";
    else cout << t;
    
    return 0;
}
```

**[Prim(稠密图)(O(n^2))](https://www.acwing.com/problem/content/860/)**

```c++
#include<bits/stdc++.h>
using namespace std;
const int N=1e3,INF=0x3f3f3f3f;
int dist[N],g[N][N];//dist是顶点到任意一个树顶点的最短距离
bool st[N];
int n,m;
int prim()
{
    memset(dist,0x3f,sizeof dist);
    int res=0;//存最小生成树所有边长度之和
    for(int i=0;i<n;i++)
    {
        int t=-1;
        for(int j=1;j<=n;j++)//找集合外所有点中到集合距离最小的点
            if(!st[j]&&(t==-1||dist[t]>dist[j]))
                t=j;
        if(i&&dist[t]==INF)return INF;//不是第一个点而且最短距离都为INF，就不存在最小生成树
        if(i)res+=dist[t];//只要不是第一个点
        st[t]=1;
        //扫描顶点t的所有边，在以t为中心更新其他点到树的距离（这时候t已经在生成树里了，其他点到t距离就是到生成树距离）
        for(int j=1;j<=n;j++)dist[j]=min(dist[j],g[t][j]);
    }
    return res;
}
int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    cin>>n>>m;
    memset(g,0x3f,sizeof g);
    while(m--)
    {
        int a,b,c;
        cin>>a>>b>>c;
        g[a][b]=g[b][a]=min(g[a][b],c);
    }
    int t=prim();
    if(t==INF)cout<<"impossible";
   else cout<<t<<endl;
    return 0;
}
```



### 二分图

**[染色法判二分图(O(m+n))](https://www.acwing.com/problem/content/862/)**

```c++
#include<bits/stdc++.h>
using namespace std;

const int N=1e6+10,M=2e6+10;

int n,m;
int h[N],e[M],ne[M],idx;
int color[N];

bool dfs(int u,int c)//u为点编号，c为染色
{
    color[u]=c;
    for(int i=h[u];i!=-1;i=ne[i])//遍历和点连接的点
    {
        int j=e[i];
        if(!color[j])//没染色,那就染（3-c实现1染2，2染1）
        {
            if(!dfs(j,3-c))return 0;
        }
        else if(color[j]==c)return 0;//已经染色
    }
    return 1;
}
void add(int a,int b)
{
    e[idx]=b,ne[idx]=h[a],h[a]=idx++;
}
int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    cin>>n>>m;
    memset(h,-1,sizeof h);
    while(m--)
    {
        int a,b;
        cin>>a>>b;
        add(a,b);
        add(b,a);
    }
    bool flag=1;//染色是否有矛盾发生
    for( int i=1;i<=n;i++)
        if(!color[i])
        {
            if(!dfs(i,1))//dfs false有矛盾发生
            {
                flag=0;
                break;
            }
        }
    
    if(flag)puts("Yes");
    else puts("No");
}
```

**匈牙利算法二分图最大匹配图**

```c++
#include<bits/stdc++.h>
using namespace std;

const int N=510,M=100010;

int n1,n2,m;
int h[N],e[M],ne[M],idx;
int match[N];
bool st[N];

void add(int a,int b)
{
    e[idx]=b,ne[idx]=h[a],h[a]=idx++;
}
bool find(int x)
{
    for(int i=h[x];i!=-1;i=ne[i])//x是男的，j是妹子，遍历男的看上的所有妹子
    {
        int j=e[i];
        if(!st[j])
        {
            st[j]=1;
            if(match[j]==0||find(match[j]))//妹子没有匹配或者妹子原本匹配的男的有备胎
            {
                match[j]=x;
                return 1;
            }
        }
    }
    return 0;
}
int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    cin>>n1>>n2>>m;
    memset(h,-1,sizeof h);
    while(m--)
    {
        int a,b;
        cin>>a>>b;
        add(a,b);
    }
    int res=0;
    for(int i=1;i<=n1;i++)
    {
        memset(st,0,sizeof st);
        if(find(i))res++;
    }
    cout<<res<<endl;
    return 0;
}
```

### 拓扑排序

```c++

```



## 基础算法

### 高精

vector开O2优化才能和数组媲美

A+B

```c++
#include<bits/stdc++.h>
using namespace std;
//如果k进制，那么10都改成k就行了，传进去的时候注意改A~10,F~15;
vector<int>add(vector<int> &A,vector<int> &B)
{
    if(A.size()<B.size())return add(B,A);
    vector<int>c;
    int t=0;//一定要初始化为0
    for(int i=0;i<A.size();i++)//A+B+t
    {
        t+=A[i];
        if(i<B.size())t+=B[i];
        c.push_back(t%10);
        t/=10;
    }
    if(t)c.push_back(t);//处理最高位
    return c;
}
int main()
{
    string a,b;
    vector<int>A,B;
    cin>>a>>b;
    for(int i=a.size()-1;i>=0;i--)A.push_back(a[i]-'0');//逆序输入,方便进位
    for(int i=b.size()-1;i>=0;i--)B.push_back(b[i]-'0');
    auto c=add(A,B);
    for(int i=c.size()-1;i>=0;i--)cout<<c[i];//逆序输出
    return 0;
}
```

**A-B**

```c++
#include<bits/stdc++.h>
using namespace std;


void trimzero(vector<int> &A)//处理输入前的0和输出时的0
{
    while(A.size()>1&&A.back()==0)A.pop_back();
}
bool cmp(vector<int> &A,vector<int> &B)
{
    if(A.size()!=B.size())return A.size()>B.size();
    for(int i=A.size()-1;i>=0;i--)
        if(A[i]!=B[i])return A[i]>B[i];
    return 1;
}


vector<int>sub(vector<int> &A,vector<int> &B)
{
    vector<int>c;
    for(int i=0,t=0;i<A.size();i++)
    {
        t=A[i]-t;
        if(i<B.size())t-=B[i];
        c.push_back((t+10)%10);
        if(t<0)t=1;
        else t=0;
    }
    trimzero(c);
    return c;
}


int main()
{
    string a,b;
    cin>>a>>b;
    vector<int>A,B;
    for(int i=a.size()-1;i>=0;i--)A.push_back(a[i]-'0');
    for(int i=b.size()-1;i>=0;i--)B.push_back(b[i]-'0');
    trimzero(A);
    trimzero(B);
    if(cmp(A,B))
    {
        auto c=sub(A,B);
        for(int i=c.size()-1;i>=0;i--)cout<<c[i];
    }
    else
    {
        auto c=sub(B,A);
        cout<<"-";
        for(int i=c.size()-1;i>=0;i--)cout<<c[i];
    }
    return 0;
}
```

**A*b**

```c++
#include<bits/stdc++.h>
using namespace std;


void trimzero(vector<int> &A)
{
    while(A.size()>1&&A.back()==0)A.pop_back();
}
vector<int> mul(vector<int> &A,int b)
{
    vector<int>c;
    for(int i=0,t=0;i<A.size()||t;i++)
    {
        if(i<A.size())t+=A[i]*b;
        c.push_back(t%10);
        t/=10;
    }
    trimzero(c);
    return c;
}
int main()
{
    string a;
    int b;
    cin>>a>>b;
    vector<int>A;
    for(int i=a.size()-1;i>=0;i--)A.push_back(a[i]-'0');
    trimzero(A);
    auto c=mul(A,b);
    for(int i=c.size()-1;i>=0;i--)cout<<c[i];
    return 0;
}
```

**A/b**

```c++
#include<bits/stdc++.h>
using namespace std;


void trimzero(vector<int> &A)
{
    while(A.size()>0&&A.back()==0)A.pop_back();
}
vector<int>div(vector<int> &A,int b,int &r)
{
    vector<int>c;
    r=0;
    for(int i=A.size()-1;i>=0;i--)//出发比较特别从高位开始搞
    {
        r=r*10+A[i];
        c.push_back(r/b);
        r%=b;
    }

    reverse(c.begin(),c.end());
    trimzero(c);
    return c;
}
int main()
{
    string a;
    int b;
    vector<int>A;
    cin>>a>>b;
    for(int i=a.size()-1;i>=0;i--)A.push_back(a[i]-'0');
    int r;
    auto c=div(A,b,r);
    for(int i=c.size()-1;i>=0;i--)cout<<c[i];
    cout<<endl<<r<<endl;
    return 0;
}
```

**大数阶乘（vector太慢了，用数组）**

```c++
#include<bits/stdc++.h>
using namespace std;

int main()
{
    int n,ws;
    while(scanf("%d",&n)!=EOF)
    {
    	double s=0;
    	for(int i=1;i<=n;i++)s+=log10(i);
    	ws=int(s)+1;//求位数 
        int f[ws];
        memset(f,0,sizeof(f));
        int ans,jw,j;
        f[0]=1;
        for(int i=2;i<=n;i++)
        {
            int jw=0;
            for(j=0;j<ws;j++)
            {
                int ans=f[j]*i+jw;
                f[j]=ans%10;
                jw=ans/10;
            }
        }
        for(j=ws-1;j>=0;j--)printf("%d",f[j]); 
        printf("\n");
    }    
    return 0;
}
```




### 输入输出

#### **c++关闭同步**

```c++
int main() {
	ios::sync_with_stdio(false);
    cin.tie(0);
}
```

#### **__int128**（GCC)

```c++
inline __int128 read(){
    __int128 x = 0, f = 1;
    char ch = getchar();
    while(ch < '0' || ch > '9'){
        if(ch == '-')
            f = -1;
        ch = getchar();
    }
    while(ch >= '0' && ch <= '9'){
        x = x * 10 + ch - '0';
        ch = getchar();
    }
    return x * f;
}
inline void print(__int128 x){
    if(x < 0){
        putchar('-');
        x = -x;
    }
    if(x > 9)
        print(x / 10);
    putchar(x % 10 + '0');
}
```



### 二分

**二分的应用**

1. 数据范围大，数据量小，把数据存到普通数组，排序，二分查找下标，可以得到区间数据数量
2. 最大求最小，最小求最大
3. 区间gcd具有单调性，最大平均数，中位数，分数规划

**整数二分**

```c++
int bsearch_1(int l,int r)//第一个满足条件的值，即右半段
{
    while(l<r)
    {
        int mid=l+r>>1;
        if(check_1(mid))r=mid;//方便记忆，右边第一个
        else l=mid+1;//别忘记else
    }
    if(a[l]!=x)return -1;
    else return l;//不要写成return 1;
}


int bsearch_2(int l,int r)//最后一个满足条件的值，即左半段
{
    while(l<r)
    {
        int mid=(l+r+1) / 2;
        if(check_2(mid))l=mid;//方便记忆，左边最后一个
        else r=mid-1;//别忘记else
    }
    if(a[l]!=x)return -1;
    else return l;
}

```

**浮点数二分**

```c++
bool check(double x) {/* ... */} // 检查x是否满足某种性质


double bsearch_3(double l, double r)//输入l和r的时候保证l<r不要输入一个负数就反过来了不能写(-n,n)
{
    const double eps = 1e-6;   // eps 表示精度，取决于题目对精度的要求，一般比要求的两位有效数字
    while (r - l > eps)
    {
        double mid = (l + r) / 2;
        if (check(mid)) r = mid;
        else l = mid;
    }
    return l;
}
```

&emsp;

```c++
#include<bits/stdc++.h>
using namespace std;
const double eps=1e-7;
double y;
double f(double x)
{
	return 0.0001*x*x*x*x*x+0.003*x*x*x+0.5*x-3;
}
int main()
{
	while(scanf("%lf",&y)!=EOF)
	{
		double mid;
		double l=-20.0,r=20.0;
		while(l<=r)
		{
			mid=(l+r)/2.0;
			if(fabs(f(mid)-y)<1e-5)break;//如果直接数值型的可以这样处理保证精度
			if(f(mid)<y)l=mid;
			else r=mid;
		}
		printf("%.4lf\n",mid);
	}
	return 0;
}
```

**整数三分（凸函数）**

```c++
LL check(LL mid)//带入函数
{
	return ;
}
void solve()
{
	cin>>x>>y;
	LL l=0,r=min(x/2,y/3);
	while(l<r)
	{
		LL lmid=l+(r-l)/3;
		LL rmid=r-(r-l)/3;
		if(check(lmid)>check(rmid))r=rmid-1;
		else l=lmid+1;
	}
	cout<<check(l)<<endl;
}
```



### 排序

**归并排序+求逆序对**（交换重排，根据奇偶性判局面可达（可能是字符串，二维平面，数组序列））

```c++
#include<bits/stdc++.h>
using namespace std;


typedef long long ll;
const int N=1e6+10;


int n;
int q[N],tmp[N];

//i不会等于1只有l
ll merge_sort(int l,int r)
{
    if(l>=r)return 0;
    int mid=l+r>>1;
    ll res=merge_sort(l,mid)+merge_sort(mid+1,r);
    int k=0,i=l,j=mid+1;//i是l别打成1
    while(i<=mid&&j<=r)
    {
        if(q[i]<=q[j])tmp[k++]=q[i++];
        else
        {
            tmp[k++]=q[j++];
            res+=mid-i+1;//q[i]>q[j]，左区间剩下的所有数与右区间当前数成为逆序对
        }
    }
    while(i<=mid)tmp[k++]=q[i++];     //扫尾
    while(j<=r)tmp[k++]=q[j++];
    for(int i=l,j=0;i<=r;i++,j++)q[i]=tmp[j];//不要写成i=1
    return res;
}


int main()
{
    int n;
    cin>>n;
    for(int i=0;i<n;i++)cin>>q[i];
    cout<<merge_sort(0,n-1);
}
```





## DP

### 背包

#### 01背包

有时候可能二进制枚举/DFS更好

**二维**

```c++
#include<bits/stdc++.h>
using namespace std;

const int N=1e4+10;

int n,m;
int v[N],w[N];
int f[N][N];


int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)cin>>v[i]>>w[i];
    //所有状态f[0~n][0~m]
    //f[0][0~m]=0所以i就不从0开始了
    for(int i=1;i<=n;i++)
    {
        for(int j=0;j<=m;j++)
        {
            f[i][j]=f[i-1][j];//左边不含i，最大值就是f[i-1][j]
            if(j>=v[i])f[i][j]=max(f[i][j],f[i-1][j-v[i]]+w[i]);//装得下v[i]才有这种情况，第一个就是左边最大值，第二个就是右边最大值，>=不要打成>
        }
    }
    cout<<f[n][m]<<endl;
    return 0;
    
}
```

**一维**

```c++
#include<bits/stdc++.h>
using namespace std;

const int N=1e4+10;
int n,m;
int v[N],w[N];
int f[N];//有时候要开long long不然会爆

int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)cin>>v[i]>>w[i];

    for(int i=1;i<=n;i++)
        for(int j=m;j>=v[i];j--)
            f[j]=max(f[j],f[j-v[i]]+w[i]);
    cout<<f[m]<<endl;
    return 0;

}
```

#### 完全背包

**二维**

```c++
#include<bits/stdc++.h>
using namespace std;

const int N=1e4+10;

int n,m;
int v[N],w[N];
int f[N][N];

int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)cin>>v[i]>>w[i];
    
    for(int i=1;i<=n;i++)
        for(int j=0;j<=m;j++)
            for(int k=0;k*v[i]<=j;k++)
                f[i][j]=max(f[i][j],f[i-1][j-v[i]*k]+w[i]*k);
    cout<<f[n][m]<<endl;
    return 0;
    
```

**二维优化**

```c++
#include<bits/stdc++.h>
using namespace std;
const int N = 1010;
int f[N][N];
int v[N],w[N];
int main()
{
    int n,m;
    cin>>n>>m;
    for(int i = 1 ; i <= n ;i ++)cin>>v[i]>>w[i];


    for(int i = 1 ; i<=n ;i++)
        for(int j = 0 ; j<=m ;j++)
        {
            f[i][j] = f[i-1][j];
            if(j>=v[i])f[i][j]=max(f[i][j],f[i][j-v[i]]+w[i]);
        }
    cout<<f[n][m]<<endl;
}
```

**一维优化**

```c++
#include<bits/stdc++.h>
using namespace std;

const int N=1e4+10;

int n,m;
int v[N],w[N];//有时候要开long long不然会爆
int f[N];


int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)cin>>v[i]>>w[i];


    for(int i=1;i<=n;i++)
        for(int j=v[i];j<=m;j++)
            f[j]=max(f[j],f[j-v[i]]+w[i]);
    cout<<f[m]<<endl;
    return 0;
}
```

#### 多重背包

**暴力朴素**

```c++
#include<bits/stdc++.h>
using namespace std;


const int N=1e4+10;


int n,m;
int v[N],w[N],s[i];
int f[N][N];


int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)cin>>v[i]>>w[i]>>s[i];


    for(int i=1;i<=n;i++)
        for(int j=0;j<=m;j++)
            for(int k=0;k<=s[i]&&k*v[i]<=j;k++)
                f[i][j]=max(f[i][j],f[i][j-v[i]*k]+w[i]*k)
    cout<<f[n][m]<<endl;
    return 0;


}
```

**二进制优化**

```c++
#include<bits/stdc++.h>
using namespace std;

const int N=25000,M=2010;//N要拆出来所以1000*log2000

int n,m;
int v[N],w[N];
int f[N];
int main()
{
    cin>>n>>m;
    int cnt=0;
    for(int i=1;i<=n;i++)
    {
        int a,b,s;//体积，价值，个数
        cin>>a>>b>>s;
        int k=1;
        while(k<=s)
        {
            cnt++;
            v[cnt]=a*k;//k个物品打包
            w[cnt]=b*k;//k个物品打包
            s-=k;
            k*=2;    
        }    
        if(s>0)//补上c
        {
            cnt++;
            v[cnt]=a*s;
            w[cnt]=b*s;
        }        
    }    
    //01背包
    n=cnt;
    for(int i=1;i<=n;i++)
         for(int j=m;j>=v[i];j--)
             f[j]=max(f[j],f[j-v[i]]+w[i]);
             
    cout<<f[m]<<endl;
    return 0;
}
```

#### 分组背包

```c++
#include<bits/stdc++.h>
using namespace std;

const int N=110;

int n,m;
int v[N][N],w[N][N],s[N];//s表示第i组物品种类
int f[N];

int main()
{
    cin>>n>>m;//n组物品，m容量
    for(int i=1;i<=n;i++)
    {
        cin>>s[i];
        for(int j=0;j<s[i];j++)
            cin>>v[i][j]>>w[i][j];
    }
    
    for(int i=1;i<=n;i++)
        for(int j=m;j>=0;j--)//i-1推i逆序
            for(int k=0;k<s[i];k++)//有点像完全背包，k就是下标，注意自己是0开始还是1开始的。选第i组的第k件物品
                if(v[i][k]<=j)
                    f[j]=max(f[j],f[j-v[i][k]]+w[i][k]);
    
    cout<<f[m]<<endl;
    return 0;    
}
```

#### 背包方案数

**二维**

```C++
#include<bits/stdc++.h>
using namespace std;

const int N=1e4+10;
int w[N],f[N][N];
int main(){
        int n,m;    
        scanf("%d%d",&n,&m);
        for(int i=1;i<=n;i++)scanf("%d",&w[i]);
        for(int i=0;i<=n;i++)f[i][0]=1;//从0开始
        
        for(int i=1;i<=n;i++)
                for(int j=1;j<=m;j++)
                {
                        f[i][j]+=f[i-1][j];
                        if(j>=w[i])f[i][j]+=f[i-1][j-w[i]];
                }
        
        printf("%d",f[n][m]);
        return 0;
}
```

**一维**

```C++
#include<bits/stdc++.h>
using namespace std;


const int N=1e4+10;
int w[N],f[N];
int main()
{
    int n,m;    
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)scanf("%d",&w[i]);
    f[0]=1;    
    for(int i=1;i<=n;i++)
        for(int j=m;j>=w[i];j--)
            f[j]+=f[j-w[i]];
    
    printf("%d",f[m]);
    return 0;
}
```

### 数位DP

```c++
void init() // 根据题意做预处理,一般是组合数/dp。
{
    for(int i = 0; i <= 9; i ++) // 对第一位初始化
        f[1][i] = 1;

    // DP过程
}

int dp(int n)
{
    if(!n) return 1;
    vector<int> num;
    // 取出每一位数字，可以根据进制转化问题替换 10
    while(n) num.push_back(n % 10), n /= 10; 
    n = num.size();

    LL ans = 0;
    int last = 0;
    for(int i = n - 1; i >= 0; i --)
    {
        int x = num[i];

        // 分类讨论,关注分支(<x,=x)是否存在，操作是否存在
    }

    return ans;
}
```

### 树形DP

[285. 没有上司的舞会 - AcWing题库](https://www.acwing.com/problem/content/287/)

```c++
#include <bits/stdc++.h>
using namespace std;

vector<int> happy;
unordered_map<int, vector<int>> tree;
vector<bool> has_father;

vector<vector<int>> dp;

void dfs(int curr) {
    dp[curr][1] = happy[curr];
    for(auto son : tree[curr]) {
        dfs(son);
        // 递归计算完子树的答案，根据子树计算一当前节点为根的子树的答案
        dp[curr][0] += max(dp[son][1], dp[son][0]);
        dp[curr][1] += dp[son][0];
    }
}

int main() {
    int n; cin >> n;
    happy.resize(n + 1);
    has_father.resize(n + 1, false);
    dp.resize(n + 1, vector<int>(2, 0));
    for(int i = 1; i <= n; ++i) cin >> happy[i];

    for(int i = 1; i < n; ++i) {
        int son, fa;
        cin >> son >> fa;
        has_father[son] = true;
        tree[fa].push_back(son);
    }
    
    int root = 1;
    while(has_father[root]) root++;	// 找根
    
    dfs(root);
    
    cout << max(dp[root][0], dp[root][1]);
    
    return 0;
}
```



## 骗分

### 数据范围

* 无解的情况

* Yes/No

* 0、1

* 随机数

    ```c++
    #include <random>
    #include <iostream>
    
    using namespace std;
    
    int main() {
        int left = -10, right = 10;
        random_device seed; //硬件生成随机数种子
        ranlux48 e(seed()); //利用种子生成随机数引擎
        uniform_int_distribution d(left, right); //设置随机数范围，并为均匀分布
        int random = d(e); //随机数
        cout << random;
    }
    ```

    

### 暴力枚举

#### 子集

```

```



#### 组合数

[剑指 Offer II 080. 含有 k 个元素的组合 - 力扣（Leetcode）](https://leetcode.cn/problems/uUsW3B/description/)

```c++
class Solution {
public:
    vector<int> path;
    vector<vector<int>> ans;
    void dfs(int startIndex, int n, int k) {
        if(path.size() == k) {
            ans.push_back(path);
            return;
        }
        if(startIndex > n) {
            return;
        }

        for(int i = startIndex; i <= n; ++i) {
            path.push_back(i);
            dfs(i + 1, n, k);
            path.pop_back();
        }
    }

    vector<vector<int>> combine(int n, int k) {
        dfs(1, n, k);
        return ans;
    }
};
```



#### 排列

`next_permutation`

* 初始要是顺序的才打印所有全排列

```c++
sort(nums.begin(), nums.end());
do {
	// print
} while (next_permutation(nums.begin(), nums.end()));
```

[46. 全排列 - 力扣（Leetcode）](https://leetcode.cn/problems/permutations/description/)

```c++
class Solution {
public:
    vector<int> path;
    vector<vector<int>> ans;
    auto dfs(vector<int> & nums, vector<bool> & used) -> void {
        if(path.size() == nums.size()) {
            ans.push_back(path);
            return;
        }

        for(int i = 0; i < nums.size(); ++i) {
            if(used[i]) continue;
            path.push_back(nums[i]);
            used[i] = true;
            dfs(nums, used);
            used[i] = false;
            path.pop_back();
        }
    }
    vector<vector<int>> permute(vector<int>& nums) {
        vector<bool> used(nums.size(), false);
        dfs(nums, used);
        return ans;
    }
};
```



### 分块

[P3372 【模板】线段树 1 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P3372)

#### 预处理

下标都从 1 

```c++
// 具体地使用块状数组，我们要先划定出每个块所占据的范围：
int sq = sqrt(n);
for (int i = 1; i <= sq; ++i) {
    st[i] = n / sq * (i - 1) + 1; // st[i]表示i号块的第一个元素的下标
    ed[i] = n / sq * i; // ed[i]表示i号块的最后一个元素的下标
}

// 但是，数组的长度并不一定是一个完全平方数，所以这样下来很可能会漏掉一小块，我们把它们纳入最后一块中：
ed[sq] = n;

// 然后，我们为每个元素确定它所归属的块：
for (int i = 1; i <= sq; ++i)
    for (int j = st[i]; j <= ed[i]; ++j)
        bel[j] = i; // 表示j号元素归属于i块

// 最后，如果必要，我们再预处理每个块的大小：
for (int i = 1; i <= sq; ++i)
    size[i] = ed[i] - st[i] + 1;

```

#### 区间修改

单独一个 mark 标记数组

```c++
// 首先是区间修改，当x与y在同一块内时，直接暴力修改原数组和sum数组：
if (bel[x] == bel[y]) {
    for (int i = x; i <= y; ++i) {
        A[i] += k;
        sum[bel[i]] += k;
    }
} else {
	// 否则，先暴力修改左右两边的零散区间：
	for (int i = x; i <= ed[bel[x]]; ++i) {
        A[i] += k;
        sum[bel[i]] += k;
    }
    for (int i = st[bel[y]]; i <= y; ++i) {
        A[i] += k;
        sum[bel[i]] += k;
    }
    
    // 然后对中间的整块打上标记：
    for (int i = bel[x] + 1; i < bel[y]; ++i)
    mark[i] += k;
}

```

#### 区间查询

```c++
// 同样地，如果左右两边在同一块，直接暴力计算区间和。
if (bel[x] == bel[y]) {
    for (int i = x; i <= y; ++i) {
    	s += A[i] + mark[bel[i]]; // 注意要加上标记
    }
} else {
    // 同样地，如果左右两边在同一块，直接暴力计算区间和。
    for (int i = x; i <= ed[bel[x]]; ++i) {
    	s += A[i] + mark[bel[i]];
    }
    
    for (int i = st[bel[y]]; i <= y; ++i) {
        s += A[i] + mark[bel[i]];
    }
    
    // 再处理整块：
    for (int i = bel[x] + 1; i < bel[y]; ++i) {
        s += sum[i] + mark[i] * size[i]; // 注意标记要乘上块长
    }
}

```



### 打表

* 打表找规律，不一定要全部符合规律，大部分符合的也行
* 分段打表



