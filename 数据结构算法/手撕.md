# 手撕

## 字符串

### strcat

```c
char* mystrcat(char* dst, char* src) {
    char* res = dst;
    while (*dst != '\0') ++dst;
    while (*src != '\0') {
        *dst++ = *src++;
    }
    *dst = '\0';  // 添加结束符，不然后面有乱码！
    return res;
}
```

### strcmp

```c
int mystrcmp(char* str1, char* str2) {
    while (*str1 == *str2 && *str1 != '\0') {
        ++str1;
        ++str2;
    }
    return *str1 - *str2;
}

```

### strcpy

strcpy和memcpy主要有以下3方面的区别。
1、复制的内容不同。strcpy只能复制字符串，而memcpy可以复制任意内容，例如字符数组、整型、结构体、类等。
2、复制的方法不同。strcpy不需要指定长度，它遇到被复制字符的串结束符"\0"才结束，所以容易溢出。memcpy则是根据其第3个参数决定复制的长度。
3、用途不同。通常在复制字符串时用strcpy，而需要复制其他类型数据时则一般用memcpy

除了边界条件需要检查以外，还有一个容易被忽视的地方即其返回值一定要是目标内存地址，以支持所谓的链式拷贝。即：

```
strcpy(dest3, strcpy(dest2, strcpy(dest1, src1)));
```

```c
char* strcpy(char* dst, char* src) { // 内存重叠
    assert((dst != NULL && src != NULL));
    char* ret = dst;
    int size = strlen(src) + 1;
    // 这个dst的内存在src的范围内，即出现可内存重叠
    if (dst >= src && dst < src + size) {
        dst = dst + size - 1;
        src = src + size - 1;
        while (size--) {
            *dst-- = *src--;  // 将src的值从后向前赋值，赋给dst
        }
    } else {
        // 非自我赋值时候
        while (size--) {
            *dst++ = *src++;
        }
    }
    return ret;
}
```

### 实现char** strsplit(const chat* src, chat delim)

### 实现 atoi

[8. 字符串转换整数 (atoi)](https://leetcode-cn.com/problems/string-to-integer-atoi/)

请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 atoi 函数）。

函数 myAtoi(string s) 的算法如下：

* 读入字符串并丢弃无用的前导空格

* 检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。
* 读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。
* 将前面步骤读入的这些数字转换为整数（即，"123" -> 123， "0032" -> 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。
* 如果整数数超过 32 位有符号整数范围 [−2^31,  2^31 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −2^31 的整数应该被固定为 −2^31 ，大于 2^31 − 1 的整数应该被固定为 2^31 − 1 。
* 返回整数作为最终结果。

注意：

本题中的空白字符只包括空格字符 ' ' 。
除前导空格或数字后的其余字符串外，请勿忽略 任何其他字符。



ps: 对于逼近溢出临界的判断，比较巧妙，需要仔细体会，只要大于7，我们一律返回临界值
如果是正数 2,147,483,648，此时已经溢出,我们返回INT_MAX(2,147,483,647)
如果是负数-2,147,483,648, 此时没有溢出, 返回INT_MIN(-2,147,483,648),实际是它本身

```c++
#include <limits.h>

int myAtoi(const char *str) {
    int res = 0, sign = 1, i = 0;
    while (str[i] == ' ') i++;  // 忽略前导空格
    if (str[i] == '+' || str[i] == '-') {
        sign = 1 - 2 * (str[i++] == '-');
    }
    while (str[i] >= '0' && str[i] <= '9') {
        if (res > INT_MAX / 10 || (res == INT_MAX / 10 && str[i] - '0' > 7)) {
            return sign == 1 ? INT_MAX : INT_MIN;
        }
        res = 10 * res + (str[i++] - '0');
    }
    return sign * res;
}

```



### 大小写转化考虑异常

```c++
#include <iostream>
#include <stdexcept>
#include <algorithm>
#include <cassert>

// 将字符串转换为大写
std::string to_upper_case(const std::string& str) {
    std::string result(str.size(), ' ');
    std::transform(str.begin(), str.end(), result.begin(), [](char c) {
        if (c >= 'a' && c <= 'z') {
            return static_cast<char>(c - 'a' + 'A');
        } else {
            return c;
        }
    });
    return result;
}

// 将字符串转换为小写
std::string to_lower_case(const std::string& str) {
    std::string result(str.size(), ' ');
    std::transform(str.begin(), str.end(), result.begin(), [](char c) {
        if (c >= 'A' && c <= 'Z') {
            return static_cast<char>(c - 'A' + 'a');
        } else {
            return c;
        }
    });
    return result;
}

// 测试大小写转换函数
int main() {
    // 测试 to_upper_case 函数
    std::string s1 = "Hello, World!";
    std::string s2 = to_upper_case(s1);
    assert(s2 == "HELLO, WORLD!");

    std::string s3 = "123";
    try {
        std::string s4 = to_upper_case(s3);
    } catch (const std::invalid_argument& e) {
        std::cout << "Caught exception: " << e.what() << "\n";
    }

    // 测试 to_lower_case 函数
    std::string s5 = "Hello, World!";
    std::string s6 = to_lower_case(s5);
    assert(s6 == "hello, world!");

    std::string s7 = "123";
    try {
        std::string s8 = to_lower_case(s7);
    } catch (const std::invalid_argument& e) {
        std::cout << "Caught exception: " << e.what() << "\n";
    }

    std::cout << "All tests passed!\n";
    return 0;
}
```

这个实现中，我们使用了 `std::transform` 算法来对字符串中的每个字符进行变换。如果字符是小写字母，则将它转换为大写字母；如果字符是大写字母，则将它转换为小写字母；如果字符不是字母，则保持不变。如果转换的字符串中包含非字母字符，则抛出 `std::invalid_argument` 异常。

在测试代码中，我们测试了 `to_upper_case` 和 `to_lower_case` 函数的正确性，并使用 `try...catch` 块来处理异常情况，确保程序不会崩溃。





### 实现 string

```c++
#include <cstring>

class String {
public:
    // 默认构造函数
    String() : data(nullptr), length(0) {}

    // 构造函数
    String(const char* str) {
        length = strlen(str);
        data = new char[length + 1];
        strcpy(data, str);
    }

    // 拷贝构造函数
    String(const String& other) : length(other.length) {
        data = new char[length + 1];
        strcpy(data, other.data);
    }

    // 移动构造函数
    String(String&& other) noexcept : data(other.data), length(other.length) {
        other.data = nullptr;
        other.length = 0;
    }

    // 析构函数
    ~String() {
        delete[] data;
    }

    // 拷贝赋值运算符重载
    String& operator=(const String& other) {
        if (this != &other) {
            delete[] data;
            length = other.length;
            data = new char[length + 1];
            strcpy(data, other.data);
        }
        return *this;
    }

    // 移动赋值运算符重载
    String& operator=(String&& other) noexcept {
        if (this != &other) {
            delete[] data;
            data = other.data;
            length = other.length;
            other.data = nullptr;
            other.length = 0;
        }
        return *this;
    }

private:
    char* data;     // 字符串内容
    size_t length;  // 字符串长度
};
```



## 内存

### memcpy

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// 实现 memcpy 函数，处理空指针和内存重叠的情况
void* my_memcpy(void* dest, const void* src, size_t n) {
    if (dest == NULL || src == NULL) {
        // 如果源地址或目标地址为 NULL，则返回 NULL
        return NULL;
    } else if (dest == src) {
        // 如果源地址和目标地址相同，则不需要进行复制
        return dest;
    } else if (dest > src && dest < (const char*)src + n) {
        // 如果目标地址在源地址和源地址+n 之间，则需要从后往前复制
        const char* s = (const char*)src + n;
        char* d = (char*)dest + n;
        while (n--) {
            *(--d) = *(--s);
        }
    } else {
        // 否则，直接从前往后复制
        memcpy(dest, src, n);
    }
    return dest;
}

// 测试 memcpy 函数
int main() {
    char s1[] = "Hello, World!";
    char s2[20] = {0};
    my_memcpy(s2, s1, strlen(s1) + 1);
    printf("%s\n", s2);

    char s3[20] = {0};
    my_memcpy(s3 + 2, s1, strlen(s1) + 1);
    printf("%s\n", s3);

    char s4[20];
    my_memcpy(s4, s4 + 1, 10);
    for (int i = 0; i < 10; i++) {
        printf("%d ", (int)s4[i]);
    }
    printf("\n");

    char* s5 = NULL;
    char s6[20] = {0};
    my_memcpy(s6, s5, 10);
    if (s6[0] == 0) {
        printf("memcpy with NULL pointer works\n");
    } else {
        printf("memcpy with NULL pointer fails\n");
    }

    return 0;
}

```





### memmove

memmove 和 memcpy 的区别

* memmove 会检查内存重叠是否，但 memcpy 不会
* 若目标内存地址头部与源内存地址尾部重叠，正序拷贝时会破坏源内存数据
* 当源内存区域的尾部与目标内存区域的头部重叠时，memmove 会采用倒序拷贝的策略
* 即如下图所示，前两种情况 memmove 采用正序拷贝，第三种情况采用倒序拷贝

![memcpy_vs_memmove](https://img-blog.csdnimg.cn/0d80e75a8f47450eb297e1117d6a91f0.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATG91aXN0YXJr,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)

一句话概括：检测内存是否重叠，无重叠则正序逐字节拷贝，重叠则倒序逐字节拷贝。

函数接口：
跟 memcpy 思路一样，`void* memmove(void* dst, const void* src, unsigned int count)`

内存重叠判断：

* 目标内存地址在源内存地址之前，可以正序拷贝：dst <= src
* 目标内存地址在源内存地址之后，但不重叠，可以正序拷贝：dst >= (char *)src + count
* 其他情况，采用倒序拷贝

主体部分：

* 正序拷贝的写法和 memcpy 相同
* 倒序拷贝分两步，先偏移两个指针 dst = (char *)dst + count - 1; src = (char*)src + count - 1;
* 然后和正序拷贝一样用一个 while 循环逐字节拷贝，区别在于指针移动方向不同

```c
void* memmove(void* dst, const void* src, unsigned int count)
{
    void* ret = dst;
    if ( dst <= src || dst >= (char *)src + count )
    {
        while (count--)
        {
            *(char *)dst = *(char *)src;
            dst = (char *)dst + 1;
            src = (char *)src + 1;
        }
    }
    else
    {
        dst = (char *)dst + count - 1;
        src = (char *)src + count - 1;
        while ( count-- )
        {
            *(char *)dst = *(char *)src;
            dst = (char *)dst - 1;
            src = (char *)src - 1;
        }
    }
    return ret;
}

```

* 第 4 行：内存重叠的检查条件必须不能写错！
* 其余手撕代码重点与 memcpy 相同

### 返回一个指定字节大小的内存，函数返回值代表成功与否

```c++
#include <iostream>
#include <cstdlib>
#include <cstring>

// 分配指定字节大小的内存
bool allocate_memory(void** ptr, size_t size) {
    if (ptr == nullptr) {
        return false;
    }
    *ptr = std::malloc(size);
    if (*ptr == nullptr) {
        return false;
    }
    std::memset(*ptr, 0, size);
    return true;
}

// 释放内存
void free_memory(void* ptr) {
    std::free(ptr);
}

// 测试分配内存函数
int main() {
    // 分配 10 字节的内存
    void* ptr = nullptr;
    bool success = allocate_memory(&ptr, 10);
    if (success) {
        std::cout << "Allocated 10 bytes of memory at address " << ptr << "\n";
        std::memset(ptr, 1, 10);
        free_memory(ptr);
    } else {
        std::cout << "Failed to allocate memory\n";
    }

    // 分配 0 字节的内存
    void* ptr2 = nullptr;
    success = allocate_memory(&ptr2, 0);
    if (success) {
        std::cout << "Allocated 0 bytes of memory at address " << ptr2 << "\n";
        free_memory(ptr2);
    } else {
        std::cout << "Failed to allocate memory\n";
    }

    // 分配 1 GB 的内存
    void* ptr3 = nullptr;
    success = allocate_memory(&ptr3, 1'000'000'000);
    if (success) {
        std::cout << "Allocated 1 GB of memory at address " << ptr3 << "\n";
        free_memory(ptr3);
    } else {
        std::cout << "Failed to allocate memory\n";
    }

    return 0;
}
```



### 实现智能指针

#### shared_ptr

```c++
#include <atomic>

template<typename T>
class shared_ptr {
private:
    T* ptr;                          // 指向堆内存的指针
    std::atomic<int>* count;         // 使用 std::atomic 类型的整数指针进行原子操作
public:
    // 构造函数，初始化指针和引用计数
    explicit shared_ptr(T* p = nullptr) : ptr(p), count(new std::atomic<int>(1)) {}
    
    // 拷贝构造函数，拷贝指针和引用计数，并将引用计数加1
    shared_ptr(const shared_ptr<T>& sp) : ptr(sp.ptr), count(sp.count) {
        ++(*count);
    }
    
    // 赋值操作符，释放原指针内存并更新指针和引用计数，将引用计数加1
    shared_ptr<T>& operator=(const shared_ptr<T>& sp) {
        if (this != &sp) {   // 避免自我赋值
            if (--(*count) == 0) {  // 原指针已没有其他 shared_ptr 引用
                delete ptr;
                delete count;
            }
            ptr = sp.ptr;
            count = sp.count;
            ++(*count);
        }
        return *this;
    }
    
    // 析构函数，将引用计数减1，如果引用计数为0，释放指针内存和整数指针
    ~shared_ptr() {
        if (--(*count) == 0) {
            delete ptr;
            delete count;
        }
    }
    
    // 解引用操作符，返回指针指向的对象
    T& operator*() const { return *ptr; }
    
    // 成员访问操作符，返回指针本身
    T* operator->() const { return ptr; }
    
    // 返回当前有多少个 shared_ptr 对象共享同一个指针
    int use_count() const { return *count; }
};

```



## 数据结构

### LFU

#### LFU

[460. LFU 缓存 - 力扣（Leetcode）](https://leetcode.cn/problems/lfu-cache/solutions/)

```c++
struct Node {
    int key, val, freq;
    Node(int k, int v, int f) : key(k), val(v), freq(f) {}
};

class LFUCache {
    int minfreq, capacity;
    unordered_map<int, list<Node>::iterator> key_table;
    unordered_map<int, list<Node>> freq_table;
public:
    LFUCache(int capacity) : capacity(capacity) {
        minfreq = 0;
        key_table.clear();
        freq_table.clear();
    }
    
    int get(int key) {
        if(capacity == 0) return -1;        
        // 我们能通过索引 key 在 key_table 中找到缓存在 freq_table 中的链表的内存地址，如果不存在直接返回 -1
        auto it = key_table.find(key);
        if(it == key_table.end()) return -1;

        // 否则我们能获取到对应缓存的相关信息，这样我们就能知道缓存的键值还有使用频率，直接返回 key 对应的值即可
        list<Node>::iterator node = it->second;
        int val = node->val, freq = node->freq;


        // 注意到 get 操作后这个缓存的使用频率加一了，所以我们需要更新缓存在哈希表 freq_table 中的位置。
        // 已知这个缓存的键 key，值 value，以及使用频率 freq，那么该缓存应该存放到 freq_table 中 freq + 1 索引下的链表中。    

        freq_table[freq].erase(node);
        // 如果当前链表为空，我们需要在哈希表中删除，且更新minFreq
        if(freq_table[freq].size() == 0) {
            freq_table.erase(freq);
            if(minfreq == freq) minfreq += 1;
        }

        // 插入到 freq + 1 中
        // 为什么是插入到链表头，为了保证缓存在当前链表中从链表头到链表尾的插入时间是有序的，为下面的删除操作服务。
        freq_table[freq + 1].push_front(Node(key, val, freq + 1));
        key_table[key] = freq_table[freq + 1].begin();
        return val;
    }
    
    void put(int key, int value) {
        // 先通过索引 key在 key_table 中查看是否有对应的缓存
        auto it = key_table.find(key);
        if(it != key_table.end()) {
            // 如果有的话，其实操作等价于 get(key) 操作，唯一的区别就是我们需要将当前的缓存里的值更新为 value。

            list<Node>::iterator node = it->second;
            int freq = node->freq;

            freq_table[freq].erase(node);
            if(freq_table[freq].size() == 0) {
                freq_table.erase(freq);
                if(minfreq == freq) minfreq += 1;
            }

            freq_table[freq + 1].push_front(Node(key, value, freq + 1));
            key_table[key] = freq_table[freq + 1].begin();
        } else {
            // 如果没有的话，相当于是新加入的缓存，如果缓存已经到达容量，需要先删除最近最少使用的缓存，再进行插入。
            
            if(key_table.size() >= capacity) {
                // 删除操作，由于我们实时维护了 minFreq，所以我们能够知道 freq_table 里目前最少使用频率的索引，同时因为我们保证了链表中从链表头到链表尾的插入时间是有序的
                // 所以 freq_table[minFreq] 的链表中链表尾的节点即为使用频率最小且插入时间最早的节点，我们删除它同时根据情况更新 minFreq ，整个时间复杂度均为 O(1)。
                auto deleteNode = freq_table[minfreq].back();
                int deleteNodeKey = deleteNode.key;
                freq_table[minfreq].pop_back();
                if(freq_table[minfreq].size() == 0) {
                    freq_table.erase(minfreq);
                }

                key_table.erase(deleteNodeKey);

            }

            // 考虑插入，由于是新插入的，所以缓存的使用频率一定是 1，所以我们将缓存的信息插入到 freq_table 中 1 索引下的列表头即可，同时更新 key_table[key] 的信息，以及更新 minFreq = 1。
            minfreq = 1;
            freq_table[1].push_front(Node(key, value, 1));
            key_table[key] = freq_table[1].begin();
        }
    }
};

/**
 * Your LFUCache object will be instantiated and called as such:
 * LFUCache* obj = new LFUCache(capacity);
 * int param_1 = obj->get(key);
 * obj->put(key,value);
 */
```



#### 带衰减的 LFU

### LRU

#### LRU

[剑指 Offer II 031. 最近最少使用缓存 - 力扣（Leetcode）](https://leetcode.cn/problems/OrIXps/)

```c++
struct Node {
    Node * prev;
    Node * next;
    int key;
    int value;
    Node() = default;
    Node(int k, int v) : key(k), value(v), prev(nullptr), next(nullptr) {}
};

class LRUCache {
private:
    unordered_map<int, Node*> cache;
    int capacity;     
    Node * head;
    Node * tail;
public:
    LRUCache(int capacity) : capacity(capacity) {
        head = new Node();
        tail = new Node();
        head->next = tail;
        tail->prev = head;
    }
    
    int get(int key) {
        if(!cache.count(key)) return -1;
        Node * node = cache[key];
        int value = node->value;

        // 从原来位置移除
        node->prev->next = node->next;
        node->next->prev = node->prev;
        
        // 放到链表头
        node->next = head->next;
        head->next->prev = node;
        node->prev = head;
        head->next = node;

        return value;
    }
    
    void put(int key, int value) {
        if(cache.count(key)) {
            Node * node = cache[key];
            node->value = value;
            
            // 从原来位置移除
            node->prev->next = node->next;
            node->next->prev = node->prev;

            // 放到链表头
            node->next = head->next;
            head->next->prev = node;
            node->prev = head;
            head->next = node;
        } else {
            Node * node = new Node(key, value);

            // 满了, 删除最后一个
            if(cache.size() >= capacity) {
                Node * lastNode = tail->prev;

                int value = lastNode->value;
                cache.erase(value);

                lastNode->prev->next = lastNode->next;
                lastNode->next->prev = lastNode->prev;
            } 

            node->next = head->next;
            head->next->prev = node;
            node->prev = head;
            head->next = node;

            cache[key] = node;
        }
    }
};

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache* obj = new LRUCache(capacity);
 * int param_1 = obj->get(key);
 * obj->put(key,value);
 */
```



#### 带衰减的 LRU



#### LRU 应用场景



#### LRU 与 LFU 区别

* LRU（The Least Recently Used，最近最久未使用算法）
    * LRU算法的思想是：**如果一个数据在最近一段时间没有被访问到，那么可以认为在将来它被访问的可能性也很小。因此，当空间满时，最久没有访问的数据最先被置换（淘汰）**。
* LFU（Least Frequently Used ，最近最少使用算法）
    * [LFU](https://www.zhihu.com/search?q=LFU&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A"240796142"})算法的思想是：**如果一个数据在最近一段时间很少被访问到，那么可以认为在将来它被访问的可能性也很小。因此，当空间满时，最小频率访问的数据最先被淘汰**。



### 哈希表

#### 手撕哈希表 C语言

```cpp
#include <stdio.h>
#include <stdlib.h>

#define SUCCESS 1
#define UNSUCCESS 0
#define OVERFLOW -1
#define OK 1
#define ERROR -1
#define MAXNUM 9999  // 用于初始化哈希表的记录 key

typedef int Status;
typedef int KeyType;

// 哈希表中的记录类型
typedef struct {
    KeyType key;
} RcdType;

// 哈希表类型
typedef struct {
    RcdType *rcd;
    int size;
    int count;
    int *tag;
} HashTable;

// 哈希表每次重建增长后的大小
int hashsize[] = {11, 31, 61, 127, 251, 503};
int index = 0;

// 初始哈希表
Status InitHashTable(HashTable &H, int size) {
    int i;
    H.rcd = (RcdType *)malloc(sizeof(RcdType) * size);
    H.tag = (int *)malloc(sizeof(int) * size);
    if (NULL == H.rcd || NULL == H.tag) return OVERFLOW;
    KeyType maxNum = MAXNUM;
    for (i = 0; i < size; i++) {
        H.tag[i] = 0;
        H.rcd[i].key = maxNum;
    }
    H.size = size;
    H.count = 0;
    return OK;
}

// 哈希函数：除留余数法
int Hash(KeyType key, int m) { return (3 * key) % m; }

// 处理哈希冲突：线性探测
void collision(int &p, int m) { p = (p + 1) % m; }

// 在哈希表中查询
Status SearchHash(HashTable H, KeyType key, int &p, int &c) {
    p = Hash(key, H.size);
    int h = p;
    c = 0;
    while ((1 == H.tag[p] && H.rcd[p].key != key) || -1 == H.tag[p]) {
        collision(p, H.size);
        c++;
    }

    if (1 == H.tag[p] && key == H.rcd[p].key)
        return SUCCESS;
    else
        return UNSUCCESS;
}

// 打印哈希表
void printHash(HashTable H) {
    int i;
    printf("key : ");
    for (i = 0; i < H.size; i++) printf("%3d ", H.rcd[i].key);
    printf("\n");
    printf("tag : ");
    for (i = 0; i < H.size; i++) printf("%3d ", H.tag[i]);
    printf("\n\n");
}

// 函数声明：插入哈希表
Status InsertHash(HashTable &H, KeyType key);

// 重建哈希表
Status recreateHash(HashTable &H) {
    RcdType *orcd;
    int *otag, osize, i;
    orcd = H.rcd;
    otag = H.tag;
    osize = H.size;

    InitHashTable(H, hashsize[index++]);
    // 把所有元素，按照新哈希函数放到新表中
    for (i = 0; i < osize; i++) {
        if (1 == otag[i]) {
            InsertHash(H, orcd[i].key);
        }
    }
    return OK;
}

// 插入哈希表
Status InsertHash(HashTable &H, KeyType key) {
    int p, c;
    if (UNSUCCESS == SearchHash(H, key, p, c)) {  // 没有相同key
        if (c * 1.0 / H.size < 0.5) {             // 冲突次数未达到上线
            // 插入代码
            H.rcd[p].key = key;
            H.tag[p] = 1;
            H.count++;
            return SUCCESS;
        } else
            recreateHash(H);  // 重构哈希表
    }
    return UNSUCCESS;
}

// 删除哈希表
Status DeleteHash(HashTable &H, KeyType key) {
    int p, c;
    if (SUCCESS == SearchHash(H, key, p, c)) {
        // 删除代码
        H.tag[p] = -1;
        H.count--;
        return SUCCESS;
    } else
        return UNSUCCESS;
}

int main() {
    printf("-----哈希表-----\n");
    HashTable H;
    int i;
    int size = 11;
    KeyType array[8] = {22, 41, 53, 46, 30, 13, 12, 67};
    KeyType key;

    // 初始化哈希表
    printf("初始化哈希表\n");
    if (SUCCESS == InitHashTable(H, hashsize[index++])) printf("初始化成功\n");

    // 插入哈希表
    printf("插入哈希表\n");
    for (i = 0; i <= 7; i++) {
        key = array[i];
        InsertHash(H, key);
        printHash(H);
    }

    // 删除哈希表
    printf("删除哈希表中key为12的元素\n");
    int p, c;
    if (SUCCESS == DeleteHash(H, 12)) {
        printf("删除成功，此时哈希表为：\n");
        printHash(H);
    }

    // 查询哈希表
    printf("查询哈希表中key为67的元素\n");
    if (SUCCESS == SearchHash(H, 67, p, c)) printf("查询成功\n");

    // 再次插入，测试哈希表的重建
    printf("再次插入，测试哈希表的重建：\n");
    KeyType array1[8] = {27, 47, 57, 47, 37, 17, 93, 67};
    for (i = 0; i <= 7; i++) {
        key = array1[i];
        InsertHash(H, key);
        printHash(H);
    }

    getchar();
    return 0;
}
```

#### c++ 实现 unordered_map

```c++
#define MAX_LEN 100000  // the amount of buckets

class MyHashMap {
   private:
    vector<pair<int, int>> map[MAX_LEN];  // hash map implemented by array

    /** Returns the corresponding bucket index. */
    int getIndex(int key) { return key % MAX_LEN; }

    /** Search the key in a specific bucket. Returns -1 if the key does not
     * existed. */
    int getPos(int key, int index) {
        // Each bucket contains a vector. Iterate all the elements in the bucket
        // to find the target key.
        for (int i = 0; i < map[index].size(); ++i) {
            if (map[index][i].first == key) {
                return i;
            }
        }
        return -1;
    }

   public:
    /** Initialize your data structure here. */
    MyHashMap() {}

    /** value will always be positive. */
    void put(int key, int value) {
        int index = getIndex(key);
        int pos = getPos(key, index);
        if (pos < 0) {
            map[index].push_back(make_pair(key, value));
        } else {
            map[index][pos].second = value;
        }
    }

    /** Returns the value to which the specified key is mapped, or -1 if this
     * map contains no mapping for the key */
    int get(int key) {
        int index = getIndex(key);
        int pos = getPos(key, index);
        if (pos < 0) {
            return -1;
        } else {
            return map[index][pos].second;
        }
    }

    /** Removes the mapping of the specified value key if this map contains a
     * mapping for the key */
    void remove(int key) {
        int index = getIndex(key);
        int pos = getPos(key, index);
        if (pos >= 0) {
            map[index].erase(map[index].begin() + pos);
        }
    }
};

/**
 * Your MyHashMap object will be instantiated and called as such:
 * MyHashMap obj = new MyHashMap();
 * obj.put(key,value);
 * int param_2 = obj.get(key);
 * obj.remove(key);
 */
```

#### C++ 实现 unordered_set

```c++
#define MAX_LEN 100000          // the amount of buckets
class MyHashSet {
private:
    vector<int> set[MAX_LEN];   // hash set implemented by array
    //这里就是vector<int>数组
    /** Returns the corresponding bucket index. */
    int getIndex(int key) {
        return key % MAX_LEN;
    }
    
    /** Search the key in a specific bucket. Returns -1 if the key does not existed. */
    int getPos(int key, int index) {
        // Each bucket contains a list. Iterate all the elements in the bucket to find the target key.
        for (int i = 0; i < set[index].size(); ++i) {
            if (set[index][i] == key) {
                return i;
            }
        }
        return -1;
    }
public:
    /** Initialize your data structure here. */
    MyHashSet() {
        
    }
    
    void add(int key) {
        int index = getIndex(key);
        int pos = getPos(key, index);
        if (pos < 0) {
            // Add new key if key does not exist.
            set[index].push_back(key);
        }
    }
    
    void remove(int key) {
        int index = getIndex(key);
        int pos = getPos(key, index);
        if (pos >= 0) {
            // Remove the key if key exists.
            set[index].erase(set[index].begin() + pos);
        }
    }
    
    /** Returns true if this set did not already contain the specified element */
    bool contains(int key) {
        int index = getIndex(key);
        int pos = getPos(key, index);
        return pos >= 0;
    }
};

/**
 * Your MyHashSet object will be instantiated and called as such:
 * MyHashSet obj = new MyHashSet();
 * obj.add(key);
 * obj.remove(key);
 * bool param_3 = obj.contains(key);
 */
```



### 手撕 vector

```c++
#include <iostream>
#include <cstring>
#include <algorithm>
#include <cassert>

// 定义 vector 类
template <typename T>
class vector {
public:
    // 默认构造函数，初始化为空 vector
    vector() : m_size(0), m_capacity(0), m_data(nullptr) {}

    // 构造函数，创建指定大小的 vector，元素默认初始化为默认值
    vector(size_t size) : m_size(size), m_capacity(size) {
        m_data = new T[size];
    }

    // 构造函数，创建指定大小的 vector，所有元素初始化为指定值
    vector(size_t size, const T& value) : vector(size) {
        for (size_t i = 0; i < size; i++) {
            m_data[i] = value;
        }
    }

    // 析构函数，释放 vector 占用的内存
    ~vector() {
        delete[] m_data;
    }

    // 在 vector 末尾添加一个元素
    void push_back(const T& value) {
        if (m_size == m_capacity) {
            // 如果当前元素个数等于容量，则需要扩容
            reserve(m_capacity == 0 ? 1 : m_capacity * 2);
        }
        m_data[m_size] = value;
        m_size++;
    }

    // 删除 vector 末尾的一个元素
    void pop_back() {
        if (m_size > 0) {
            m_size--;
        }
    }

    // 扩容 vector，如果指定的容量大于当前容量，则需要进行扩容
    void reserve(size_t capacity) {
        if (capacity > m_capacity) {
            T* new_data = new T[capacity];
            std::memcpy(new_data, m_data, sizeof(T) * m_size);
            delete[] m_data;
            m_data = new_data;
            m_capacity = capacity;
        }
    }

    // 返回当前 vector 中元素的个数
    size_t size() const {
        return m_size;
    }

    // 返回当前 vector 的容量
    size_t capacity() const {
        return m_capacity;
    }

    // 判断当前 vector 是否为空
    bool empty() const {
        return m_size == 0;
    }

    // 访问指定位置的元素，返回 const 引用
    const T& operator[](size_t index) const {
        return m_data[index];
    }

    // 访问指定位置的元素，返回引用
    T& operator[](size_t index) {
        return m_data[index];
    }

    // 清空 vector，将元素个数设为 0
    void clear() {
        m_size = 0;
    }

    // 改变 vector 的大小，如果指定的大小大于当前容量，则需要先扩容，然后使用默认值填充多出来的元素
    void resize(size_t size) {
        if (size > m_capacity) {
            reserve(size);
        }
        if (size > m_size) {
            std::fill(m_data + m_size, m_data + size, T());
        }
        m_size = size;
    }

    // 改变 vector 的大小，如果指定的大小大于当前容量，则需要先扩容，然后使用指定值填充多出来的元素
    void resize(size_t size, const T& value) {
        if (size > m_capacity) {
            reserve(size);
        }
        if (size > m_size) {
            std::fill(m_data + m_size, m_data + size, value);
        }
        m_size = size;
    }

private:
    T* m_data; // 指向元素的指针
    size_t m_size; // 元素个数
    size_t m_capacity; // 容量
};


// 测试 vector 类
int main() {
    // 创建空 vector
    vector<int> v1;
    assert(v1.size() == 0);
    assert(v1.capacity() == 0);
    assert(v1.empty());

    // 在 vector 末尾添加元素
    v1.push_back(1);
    v1.push_back(2);
    v1.push_back(3);
    assert(v1.size() == 3);
    assert(v1.capacity() == 4);
    assert(!v1.empty());
    assert(v1[0] == 1);
    assert(v1[1] == 2);
    assert(v1[2] == 3);

    // 删除 vector 末尾的元素
    v1.pop_back();
    assert(v1.size() == 2);
    assert(v1.capacity() == 4);
    assert(!v1.empty());
    assert(v1[0] == 1);
    assert(v1[1] == 2);

    // 修改 vector 中的元素
    v1[1] = 3;
    assert(v1.size() == 2);
    assert(v1.capacity() == 4);
    assert(!v1.empty());
    assert(v1[0] == 1);
    assert(v1[1] == 3);

    // 创建指定大小的 vector，所有元素初始化为默认值
    vector<int> v2(3);
    assert(v2.size() == 3);
    assert(v2.capacity() == 3);
    assert(!v2.empty());
    assert(v2[0] == 0);
    assert(v2[1] == 0);
    assert(v2[2] == 0);

    // 创建指定大小的 vector，所有元素初始化为指定值
    vector<int> v3(3, 1);
    assert(v3.size() == 3);
    assert(v3.capacity() == 3);
    assert(!v3.empty());
    assert(v3[0] == 1);
    assert(v3[1] == 1);
    assert(v3[2] == 1);

    // 清空 vector
    v1.clear();
    assert(v1.size() == 0);
    assert(v1.capacity() == 4);
    assert(v1.empty());

    // 改变 vector 的大小，使用默认值填充多出来的元素
    v1.resize(3);
    assert(v1.size() == 3);
    assert(v1.capacity() == 4);
    assert(!v1.empty());
    assert(v1[0] == 0);
    assert(v1[1] == 0);
    assert(v1[2] == 0);

    // 改变 vector 的大小，使用指定值填充多出来的元素
    v1.resize(5, 1);
    assert(v1.size() == 5);
    assert(v1.capacity() == 5);
    assert(!v1.empty());
    assert(v1[0] == 0);
    assert(v1[1] == 0);
    assert(v1[2] == 0);
    assert(v1[3] == 1);
    assert(v1[4] == 1);

    std::cout << "All tests passed!\n";
    return 0;
}
```



### 建立二叉树



## 进制转换

```

```



## 大小端判断

端存储：字数据的高字节存储在低地址中

小端存储：字数据的低字节存储在低地址中

例如：32bit的数字0x12345678

**所以在Socket编程中，往往需要将操作系统所用的小端存储的IP地址转换为大端存储，这样才能进行网络传输**

小端模式中的存储方式为：

![img](https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.4.2/202102/1564134200013.png)

大端模式中的存储方式为：

![img](https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.4.2/202102/1564134220855.png)

了解了大小端存储的方式，如何在代码中进行判断呢？下面介绍两种判断方式：

**方式一：使用强制类型转换**-这种法子不错

```c++
#include <iostream>
using namespace std;
int main()
{
    int a = 0x1234;
    //由于int和char的长度不同，借助int型转换成char型，只会留下低地址的部分
    char c = (char)(a);
    if (c == 0x12)
        cout << "big endian" << endl;
    else if(c == 0x34)
        cout << "little endian" << endl;
}
```

**方式二：巧用union联合体**

```c++
#include <iostream>
using namespace std;
//union联合体的重叠式存储，endian联合体占用内存的空间为每个成员字节长度的最大值
union endian
{
    int a;
    char ch;
};
int main()
{
    endian value;
    value.a = 0x1234;
    //a和ch共用4字节的内存空间
    if (value.ch == 0x12)
        cout << "big endian"<<endl;
    else if (value.ch == 0x34)
        cout << "little endian"<<endl;
}
```

###

## 实现 sqrt

[69. x 的平方根](https://leetcode-cn.com/problems/sqrtx/)

### 方法一：袖珍计算器算法

「袖珍计算器算法」是一种用指数函数 exp 和对数函数 ln 代替平方根函数的方法。我们通过有限的可以使用的数学函数，得到我们想要计算的结果。

我们将 $\sqrt{x} $ 写成幂的形式 $x^{1/2} $

 ，再使用自然对数 e 进行换底，即可得到

$\sqrt{x} = x^{1/2} = (e ^ {\ln x})^{1/2} = e^{\frac{1}{2} \ln x}$

**注意：** 由于计算机无法存储浮点数的精确值,有误差.例如当 x=2147395600 时，$e^{\frac{1}{2} \ln x} $的计算结果与正确值 46340相差 $10^{-11} $ ，这样在对结果取整数部分时，会得到 46339 这个错误的结果。

因此在得到结果的整数部分ans 后，我们应当找出ans 与 ans+1 中哪一个是真正的答案。

```c++
class Solution {
public:
    int mySqrt(int x) {
        if (x == 0) {
            return 0;
        }
        int ans = exp(0.5 * log(x));
        return ((long long)(ans + 1) * (ans + 1) <= x ? ans + 1 : ans);
    }
};
```

### 方法二：二分查找

由于 x 平方根的整数部分 ans 是满足 $k^2 \leq x$的最大 k 值，因此我们可以对 k 进行二分查找，从而得到答案。

二分查找的下界为 0，上界可以粗略地设定为 x。在二分查找的每一步中，我们只需要比较中间元素 mid 的平方与 x 的大小关系，并通过比较的结果调整上下界的范围。由于我们所有的运算都是整数运算，不会存在误差。

```c++
int mySqrt(int x) {
        // 试一试二分查找是否能够解决啦啦啦
        // k * k <= x 找最大的k
        int left = 0, right = x;
        // [left, right]
        int ans = 0;
        while (left <= right) {
            int mid = left + (right - left >> 1);
            if (static_cast<long long>(mid) * mid > x) {
                right = mid - 1;
            } else {
                ans = mid;
                left = mid + 1;
            } 
        }
        return ans;
    }
```

### 方法三：牛顿迭代

牛顿迭代法是一种可以用来快速求解函数**零点**的方法。

为了叙述方便，我们用 C 表示待求出平方根的那个整数。

显然，C 的平方根就是函数$y = f(x) = x^2 - C$ 的零点。

![fig1](https://assets.leetcode-cn.com/solution-static/69/69_fig1.png)

算法

我们选择x0 = C作为初始值。

在每一步迭代中，我们通过当前的交点xi,找到图像上Pi (xi, xi^2^ - C)

然后作切线，斜率f^'^'(xi) = 2xi, 经过点Pi 与x轴相交。

切线方程 y = 2xi x - (xi^2^ + C), y = 0即新的交点

Pi+1 ( 1/2 (xi + C / xi) ,0)

**迭代到何时才算结束**？

每一次迭代后，我们都会距离零点更进一步，所以当相邻两次迭代得到的交点非常接近时，我们就可以断定。一般来说，可以判断相邻两次迭代的结果的差值是否小于一个极小的非负数 $\epsilon$，其中 $\epsilon$ 一般可以取 $10^{-6}$

```c++
class Solution {
public:
    int mySqrt(int x) {
        if (x == 0) {
            return 0;
        }

        double C = x, x0 = x;
        while (true) {
            double xi = 0.5 * (x0 + C / x0);
            if (fabs(x0 - xi) < 1e-7) {
                break;
            }
            x0 = xi;
        }
        return int(x0);
    }
};
```







## 多线程

### 生产者消费者

CPP20 STL-Cookbook

单生产者单消费者

[CPP-20-STL-Cookbook/producer-consumer.cpp at main · PacktPublishing/CPP-20-STL-Cookbook (github.com)](https://github.com/PacktPublishing/CPP-20-STL-Cookbook/blob/main/chap09/producer-consumer.cpp)

```c++
//  producer-consumer.cpp
//  as of 2022-03-29 bw [bw.org]

#include <format>
#include <iostream>
#include <deque>
#include <tuple>
#include <condition_variable>
#include <thread>

using std::format;
using std::cout;
using std::mutex;
using std::thread;

using namespace std::chrono_literals;
namespace this_thread = std::this_thread;

using guard_t = std::lock_guard<std::mutex>;
using lock_t = std::unique_lock<std::mutex>;

constexpr size_t num_items{ 10 };
constexpr auto delay_time{ 200ms };

std::deque<size_t> q{};
std::mutex mtx{};
std::condition_variable cond{};
bool finished{};

void producer() {
    for(size_t i{}; i < num_items; ++i) {
        this_thread::sleep_for(delay_time);
        guard_t x{ mtx };
        q.push_back(i);
        cond.notify_all();
    }

    guard_t x{ mtx };
    finished = true;
    cond.notify_all();
}

void consumer() {
    while(!finished) {
        lock_t lck{ mtx };
        cond.wait(lck, []{ return !q.empty() || finished; });
        while(!q.empty()) {
            cout << format("Got {} from the queue\n", q.front());
            q.pop_front();
        }
    }
}

int main() {
    thread t1{ producer };
    thread t2{ consumer };
    t1.join();
    t2.join();
    cout << "finished!\n";
}
```

多生产者多消费者

[CPP-20-STL-Cookbook/multi-producer-consumer.cpp at main · PacktPublishing/CPP-20-STL-Cookbook (github.com)](https://github.com/PacktPublishing/CPP-20-STL-Cookbook/blob/main/chap09/multi-producer-consumer.cpp)

```c++
//  multi-producer-consumer.cpp
//  as of 2022-03-06 bw [bw.org]

#include <format>
#include <iostream>
#include <list>
#include <string>
#include <deque>
#include <thread>
#include <future>
#include <mutex>
#include <condition_variable>
#include <chrono>

using std::format;
using std::cout;
using std::string;
using std::list;
using std::mutex;
using std::unique_lock;
using std::async;
using std::future;
using std::condition_variable;

using namespace std::chrono_literals;
namespace this_thread = std::this_thread;

constexpr auto delay_time{ 50ms };
constexpr auto consumer_wait{ 100ms };
constexpr size_t queue_limit{ 5 };
constexpr size_t num_items{ 15 };
constexpr size_t num_producers{ 3 };
constexpr size_t num_consumers{ 5 };

std::deque<string> qs{};
mutex q_mutex{};
condition_variable cv_producer{};
condition_variable cv_consumer{};
bool production_complete{};

void producer(const size_t id) {
    for(size_t i{}; i < num_items; ++i) {
        this_thread::sleep_for(delay_time * id);
        unique_lock<mutex> lock(q_mutex);
        cv_producer.wait(lock, [&]{ return qs.size() < queue_limit; });
        qs.push_back(format("pid {}, qs  {}, item {:02}\n", id, qs.size(), i + 1));
        cv_consumer.notify_all();
    }
}

void consumer(const size_t id) {
    while(!production_complete) {
        unique_lock<mutex> lock(q_mutex);
        cv_consumer.wait_for(lock, consumer_wait, [&]{ return !qs.empty(); });
        if(!qs.empty()) {
            cout << format("cid {}: {}", id, qs.front());
            qs.pop_front();
        }
        cv_producer.notify_all();
    }
}

int main() {
    list<future<void>> producers;
    list<future<void>> consumers;

    for(size_t i{}; i < num_producers; ++i) {
        producers.emplace_back(async(producer, i));
    }

    for(size_t i{}; i < num_consumers; ++i) {
        consumers.emplace_back(async(consumer, i));
    }
    
    for(auto& f : producers) f.wait();
    production_complete = true;
    cout << "producers done.\n";

    for(auto& f : consumers) f.wait();
    cout << "consumers done.\n";
}
```



### 手搓一个模拟死锁的代码

```C
#include <pthread.h>
#include <unistd.h>
#include <stdio.h>

pthread_mutex_t m_mutex1, m_mutex2;
int A = 0, B = 0;

void* threadFunc1(void* args) {
    pthread_mutex_lock(&m_mutex1);
    A = 1;
 	printf("thread 1 write source A\n");
 	usleep(100);

    pthread_mutex_lock(&m_mutex2);
    B = 1;
	printf("thread 1 write source B\n");
 
 //解锁，实际上是跑不到这里的，因为前面已经死锁了
    pthread_mutex_unlock(&m_mutex2);
    pthread_mutex_unlock(&m_mutex1);

    return NULL;
}

void* threadFunc2(void* args) {
    pthread_mutex_lock(&m_mutex2);
    B = 1;
	printf("thread 2 write source B\n");
	usleep(100);

    pthread_mutex_lock(&m_mutex1);
    A = 1;
	printf("thread 2 write source A\n");
 
    //解锁，实际上是跑不到这里的，因为前面已经死锁了
    pthread_mutex_unlock(&m_mutex1);
    pthread_mutex_unlock(&m_mutex2);

    return NULL;
}

int main() {
    if(pthread_mutex_init(&m_mutex1, 0) != 0) {
        printf("init mutex 1 failed\n");
        return -1;
    }
    if(pthread_mutex_init(&m_mutex2, 0) != 0) {
        printf("init mutex 2 failed\n");
        return -1;
    }

    pthread_t hThread1, hThread2;
    if(pthread_create(&hThread1, NULL, &threadFunc1, NULL) != 0) {
        printf("create thread1 failed\n");
        return -1;
    }
    if(pthread_create(&hThread2, NULL, &threadFunc2, NULL) != 0) {
        printf("create thread1 failed\n");
        return -1;
    }

    while(1) {
        sleep(1);
    }

    pthread_mutex_destroy(&m_mutex1);
    pthread_mutex_destroy(&m_mutex2);

    return 0;
}
```

### 线程池

```c++
#include <condition_variable>
#include <functional>
#include <future>
#include <iostream>
#include <mutex>
#include <queue>
#include <stdexcept>
#include <thread>
#include <vector>

// 线程池类
class ThreadPool {
   public:
    // 构造函数，默认线程数为 CPU 核心数
    explicit ThreadPool(
        size_t thread_count = std::thread::hardware_concurrency())
        : stop(false) {
        // 创建指定数目的工作线程
        for (size_t i = 0; i < thread_count; ++i) {
            threads.emplace_back([this] {
                for (;;) {
                    std::function<void()> task;
                    {
                        std::unique_lock<std::mutex> lock(this->queue_mutex);
                        // 等待任务队列不为空或线程池停止的条件变量
                        this->condition.wait(lock, [this] {
                            return this->stop || !this->tasks.empty();
                        });
                        if (this->stop && this->tasks.empty()) return;
                        task = std::move(this->tasks.front());
                        this->tasks.pop();
                    }
                    task();
                }
            });
        }
    }

    // 析构函数，等待所有任务执行完成并停止工作线程
    ~ThreadPool() {
        {
            std::unique_lock<std::mutex> lock(queue_mutex);
            stop = true;
        }
        condition.notify_all();
        for (std::thread &worker : threads) worker.join();
    }

    // 向线程池中添加任务，返回一个 std::future 对象
    template <class F, class... Args>
    auto enqueue(F &&f, Args &&...args)
        -> std::future<typename std::result_of<F(Args...)>::type> {
        using return_type = typename std::result_of<F(Args...)>::type;

        // 将要执行的函数和参数绑定，封装成一个 std::packaged_task 对象
        auto task = std::make_shared<std::packaged_task<return_type()>>(
            std::bind(std::forward<F>(f), std::forward<Args>(args)...));

        // 获取 std::future 对象
        std::future<return_type> res = task->get_future();
        {
            std::unique_lock<std::mutex> lock(queue_mutex);

            // 线程池停止时，禁止添加新的任务
            if (stop) throw std::runtime_error("enqueue on stopped ThreadPool");

            // 将任务封装成 std::function<void()> 对象，加入到任务队列中
            tasks.emplace([task]() { (*task)(); });
        }
        // 通知一个等待的工作线程，有新的任务加入到任务队列中
        condition.notify_one();
        return res;
    }

   private:
    // 线程池中的工作线程
    std::vector<std::thread> threads;

    // 任务队列
    std::queue<std::function<void()>> tasks;

    // 同步互斥信号量
    std::mutex queue_mutex;
    std::condition_variable condition;

    // 是否停止线程池
    bool stop;
};

// 测试线程池
int main() {
    // 创建线程池，包含默认线程数目的线程
    ThreadPool pool;

    // 添加 8 个任务到线程池中
    std::vector<std::future<int>> results;
    for (int i = 0; i < 10; ++i) {
        results.emplace_back(pool.enqueue([i]() {
            std::cout << "Task " << i << " starts\n";
            std::this_thread::sleep_for(std::chrono::milliseconds(100));
            std::cout << "Task " << i << " ends\n";
            return i * i;
        }));
    }

    std::this_thread::sleep_for(std::chrono::milliseconds(500));

    // 等待所有任务完成
    for (auto &&result : results) std::cout << result.get() << ' ';
    std::cout << std::endl;

    return 0;
}
```







### LeetCode 多线程

#### 按序打印

#### 交替打印 FooBar



#### 打印零与奇偶数

#### H2O 生成

#### 设计有限阻塞队列

#### 交替打印字符串

#### 哲学家进餐

#### 多线程网页爬虫

#### 红绿灯路口



### BoundedBlockingQueue

```c++
#include <queue>
#include <mutex>
#include <condition_variable>
#include <chrono>
#include <thread>
#include <iostream>
#include <vector>
#include <algorithm>

template <typename T>
class BoundedBlockingQueue {
public:
    BoundedBlockingQueue(int limit, int waitMs) : m_limit(limit), m_waitMs(waitMs) {}

    void push(const T& obj) {
        std::unique_lock<std::mutex> lock(m_mutex);
        // 如果队列已满，等待直到有空位
        m_notFull.wait(lock, [this]() { return m_queue.size() < m_limit; });
        m_queue.push(obj);
        // 通知一个等待在队列空的线程
        m_notEmpty.notify_one();
    }

    bool pop(T& data) {
        std::unique_lock<std::mutex> lock(m_mutex);
        // 如果队列为空，等待直到有数据
        if (!m_notEmpty.wait_for(lock, std::chrono::milliseconds(m_waitMs),
                                  [this]() { return !m_queue.empty(); })) {
            // 等待超时，返回false
            return false;
        }
        data = m_queue.front();
        m_queue.pop();
        // 通知一个等待在队列满的线程
        m_notFull.notify_one();
        return true;
    }

private:
    std::queue<T> m_queue;  // 队列
    std::mutex m_mutex;  // 互斥锁
    std::condition_variable m_notEmpty;  // 非空条件变量
    std::condition_variable m_notFull;  // 非满条件变量
    int m_limit;  // 队列最大长度
    int m_waitMs;  // 等待超时时间
};

int main () {
    BoundedBlockingQueue<int> queue(30, 1000);
    std::vector<std::thread> producers;
    for (int i = 0; i < 10; i++) {
        producers.emplace_back([&](int i) {
            for(int j = 0; j < 20; ++j) {
                queue.push(i * 100 + j);
            }
        }, i);
    }

    std::vector<int> ans;
    std::thread consumerThread([&]() {
        int data;
        for(int i = 0; i <= 200; ++i) {
            if(!queue.pop(data)) {
                std::cout << "pop false" << std::endl;
            } else {
                ans.push_back(data);
            }
        }
    });
    for (auto& t : producers) {
        t.join();
    }
    consumerThread.join();

    sort(ans.begin(), ans.end());
    std::cout << ans.size() << std::endl;
    for(int x : ans) std::cout << x << ", ";
    return 0;
}
```



### 手撕读写锁

```C++
// C++11
#include <mutex>
#include <condition_variable>

// 读写锁类的定义
class RWLock {
public:
    RWLock() : read_count(0), write_count(0) {}

    // 读操作加锁函数
    void read_lock() {
        std::unique_lock<std::mutex> lock(mutex);
        // 如果有写操作正在进行，则等待
        while (write_count > 0) {
            read_condition.wait(lock);
        }
        // 增加读操作计数器
        ++read_count;
    }

    // 读操作解锁函数
    void read_unlock() {
        std::unique_lock<std::mutex> lock(mutex);
        // 减少读操作计数器
        --read_count;
        // 如果最后一个读操作结束，唤醒一个正在等待的写操作
        if (read_count == 0) {
            write_condition.notify_one();
        }
    }

    // 写操作加锁函数
    void write_lock() {
        std::unique_lock<std::mutex> lock(mutex);
        // 增加写操作计数器
        ++write_count;
        // 如果有任何读操作或写操作正在进行，则等待
        while (read_count > 0 || write_count > 1) {
            write_condition.wait(lock);
        }
    }

    // 写操作解锁函数
    void write_unlock() {
        std::unique_lock<std::mutex> lock(mutex);
        // 减少写操作计数器
        --write_count;
        // 如果最后一个写操作结束，唤醒所有正在等待的读操作
        if (write_count == 0) {
            read_condition.notify_all();
        } else {
            write_condition.notify_one();
        }
    }

private:
    std::mutex mutex;   // 互斥锁，用于保证线程安全
    std::condition_variable read_condition;    // 读条件变量，用于等待写操作完成
    std::condition_variable write_condition;   // 写条件变量，用于等待读操作和写操作完成
    int read_count;     // 读操作计数器
    int write_count;    // 写操作计数器
};

```

C++14 直接 `shared_mutex`

```c++
#include <shared_mutex>

// 读写锁类的定义
class RWLock {
public:
    // 读操作加锁函数
    void read_lock() {
        mutex.lock_shared();
    }

    // 读操作解锁函数
    void read_unlock() {
        mutex.unlock_shared();
    }

    // 写操作加锁函数
    void write_lock() {
        mutex.lock();
    }

    // 写操作解锁函数
    void write_unlock() {
        mutex.unlock();
    }

private:
    std::shared_mutex mutex;   // 读写锁，用于保证线程安全
};

```



### 事件驱动模型 epoll







