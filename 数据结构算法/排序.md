# 排序

## 基本概念

有些人可能不知道什么是稳定排序、原地排序、时间复杂度、空间复杂度，我这里先简单解释一下：

1、稳定排序：如果 a 原本在 b 的前面，且 a == b，排序之后 a 仍然在 b 的前面，则为稳定排序。

2、非稳定排序：如果 a 原本在 b 的前面，且 a == b，排序之后 a 可能不在 b 的前面，则为非稳定排序。

3、原地排序：原地排序就是指在排序过程中不申请多余的存储空间，只利用原来存储待排数据的存储空间进行比较和交换的数据排序。

4、非原地排序：需要利用额外的数组来辅助排序。

5、时间复杂度：一个算法执行所消耗的时间。

6、空间复杂度：运行完一个算法所需的内存大小

**十大排序一图总览**

![img](https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205072325169.png)

十大排序中的稳定排序

* 冒泡排序
* 插入排序
* 归并排序
* 基数排序

十大排序中的非稳定排序

* 选择排序 （selection sort）— $O(n^2) $
* 希尔排序 （shell sort）— $O(n log n) $
* 堆排序 （heapsort）— $O(n log n) $
* 快速排序 （quicksort）— $O(n log n)$

## 冒泡排序 

### 一、原理

* 遍历比较相邻两个元素，小的放前面，大的放前面，不符合就交换这两个元素。如果两个元素相等，不交换，稳定排序
* 一轮遍历下来能够确定最后一个元素会是最大的元素，下一个就不用考虑最后一个元素了，反复执行直到没有任何一对数字需要比较

### 二、复杂度

时间复杂度：$O(N^2)$

### 三、实现

#### 普通数组

```cpp
void bubbleSort(vector<int>& a, int n) {
 for (auto i = 0; i < n; ++i) {
  for (int j = 0; j < n - i - 1; ++j) {
   if (a[j] > a[j + 1])
    swap(a[j], a[j + 1]);
  }
 }
}
```

#### 普通数组优化

```c++
void bubbleSort(vector<int>& nums) {
    int n = nums.size();
    bool flag = false;
    for (int i = 0; i < n - 1; ++i) {//i = 0 起，循环了n - 1趟，更符合规范理解
        flag = false;   // 根据是否发生交换来判断是有序，如果没交换就是有序了，不用继续循环
        for (int j = 0; j < n - 1 - i; ++j) {
            if (nums[j] > nums[j + 1]) {
                swap(nums[j], nums[j + 1]);
                flag = true;
            }
        }
        if (!flag) { break; }
    }
}
```

#### 单链表

```c++
Node *BubbleSort(Node *phead)
{

 Node * p = phead;
 Node * q = phead->next;
 /*有几个数据就-1；比如x 个i<x-1*/
 for(int i=0;i<5;i++)
 { 
  while((q!=NULL)&&(p!=NULL))
  { 
   if(p->data>q->data)
   {
    /*头结点和下一节点的交换，要特殊处理，更新新的头head*/
    if (p == phead)
    {
     p->next = q->next;
     q->next = p;
     head = q;
     phead = q;
     /*这里切记要把p,q换回来，正常的话q应该在p的前面，进行的是p,q的比较
     *但是经过指针域交换之后就变成q,p.再次进行下一次比较时，
     *就会变成q,p的数据域比较。假如原本p->data > q->data,则进行交换。变成q->data和p->data比较，
     *不会进行交换，所以排序就会错误。有兴趣的可以调试下。
     */ 
     Node*temp=p; 
     p=q;
     q=temp;  
    }
    /*处理中间过程，其他数据的交换情况，要寻找前驱节点if (p != phead)*/
    else 
    {
     /*p，q的那个在前，那个在后。指针域的连接画图好理解一点*/
     if (p->next == q)
     {
      /*寻找p的前驱节点*/
      Node *ppre = FindPreNode(p);
      /*将p的下一个指向q的下一个*/
      p->next = q->next;
      /*此时q为头结点，让q的下一个指向p，连接起来*/
      q->next = p;
      /*将原来p的前驱节点指向现在的q，现在的q为头结点*/
      ppre->next = q;
      Node*temp=p; 
      p=q; 
      q=temp;
     }
     else if (q->next == p)
     {
      Node *qpre = FindPreNode(q);
      q->next = p->next;
      p->next = q;
      qpre->next = p;
      Node*temp=p;
      p=q; 
      q=temp;
      }         
    }  
   }
   /*地址移动*/
   p = p->next;
   q = q->next;
  }
  /*进行完一轮比较后，从头开始进行第二轮*/
  p = phead;
  q = phead->next; 
 }
 
 head = phead;
 return head;
}
```

## 插入排序 

### 一、原理

* 插入排序是在一个已经有序的小序列的基础上，一次插入一个元素。
* 比较是从有序序列的末尾开始，也就是想要插入的元素和已经有序的最大者开始比起，如果比它大则直接插入在其后面，否则一直往前找直到找到它该插入的位置。
* 如果碰见一个和插入元素相 等的，那么插入元素把想插入的元素放在相等元素的后面，插入排序是稳定的

1. 从第一个元素开始，该元素可以认为已经被排序
2. 取出下一个元素，在已经排序的元素序列中从后向前扫描
3. 如果该元素（已排序）大于新元素，将该元素移到下一位置
4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置
5. 将新元素插入到该位置后
6. 重复步骤2~5



### 二、复杂度

* 时间复杂度：$O(N^2)$
* 空间复杂度：$O(1)$



### 三、实现

#### 普通数组

```cpp
void insertionSort(vector<int>& a, int n) {//{ 9,1,5,6,2,3 }
 for (int i = 1; i < n; ++i) {
  if (a[i] < a[i - 1]) {   //若第i个元素大于i-1元素，直接插入。小于的话，移动有序表后插入
   int j = i - 1;
   int x = a[i];     //复制为哨兵，即存储待排序元素
   //a[i] = a[i - 1];           //先后移一个元素，可以不要这一句，跟循环里面的功能重复了
   while (j >= 0 && x < a[j]) {   //查找在有序表的插入位置,还必须要保证j是>=0的 因为a[j]要合法
    a[j + 1] = a[j];
    j--;     //元素后移
   }
   a[j + 1] = x;     //插入到正确位置
  }
 }
}
```

#### 单链表

```c++
/*不好理解可以调试下看下具体过程*/
Node *InsertSort(Node *phead)  
{  
 /*为原链表剩下用于直接插入排序的节点头指针*/  
    Node *unsort; 
 /*临时指针变量：插入节点*/
    Node *t;  
 /*临时指针变量*/  
    Node *p; 
 /*临时指针变量*/  
    Node *sort; 
 /*原链表剩下用于直接插入排序的节点链表：可根据图12来理解。*/  
    unsort = phead->next; 
 /*只含有一个节点的链表的有序链表：可根据图11来理解。*/  
    head->next = NULL; 
   /*遍历剩下无序的链表*/ 
    while (unsort != NULL)  
    {  
        /*注意：这里for语句就是体现直接插入排序思想的地方*/
  /*无序节点在有序链表中找插入的位置*/  
  /*跳出for循环的条件：
  *1.sort为空，此时，sort->data < t->data，p存下位置，应该放在有序链表的后面
  *2.sort->data > t->data ，跳出循环时，t->data放在有序链表sort的前面
  *3.sort为空 sort->data > t->data，也插入在sort前面的位置
  */  
  /*q为有序链表*/
        for (t = unsort, sort = phead; ((sort != NULL) && (sort->data < t->data)); p = sort, sort = sort->next); 
      
      /*退出for循环，就是找到了插入的位置插入位置要么在前面，要么在后面*/  
     /*注意：按道理来说，这句话可以放到下面注释了的那个位置也应该对的，但是就是不能。原因：你若理解了上面的第3条，就知道了。*/  
       /*无序链表中的第一个节点离开，以便它插入到有序链表中。*/
     unsort = unsort->next;    
  /*插在第一个节点之前*/ 
  /*sort->data > t->data*/
  /*sort为空 sort->data > t->data*/
        if (sort == phead)  
        {  
   /*整个无序链表给phead*/
            phead = t;  
        }  
  /*p是sort的前驱，这样说不太确切，当sort到最后时，for里面有个sort = sort->next，
  *就会把sort置空，所以要用p暂存上一次sort的值。而且执行判断sort->data < t->data时，用的也是上一次的sort
  */
  /*sort后面插入*/
  /*sort遍历到了最后，此时，sort->data < t->data,sort和p都为最后一个元素。*/ 
        else  
        {  
            p->next = t;  
        }  
  /*if处理之后，t为无序链表，因为要在phead前插入。这里先把t赋值给phead，再把t的next指向sort，
  *就完成了在sort之前插入小的元素，很巧妙的一种方法
  *else处理完之后，sort存放的是sort的下一次，真正的sort存放在p中。不满足条件跳出循环时，判断的是下一次的sort，
  但是我们要用的插入的位置为上一次的sort，所以要记录下sort上一次的位置
  */
  /*完成插入动作*/
  /*当sort遍历完成为空时，t->next就是断开后面的元素（sort为空）*/
  /*当sort不为空时，sort->data > t->data，sort存放的元素比t要大，放在后面，t->next就是再链接起来sort*/
        t->next = sort;   
        /*unsort = unsort->next;*/  
    }  
 head = phead;
    return phead;  
}  
```

## 归并排序

### 一、原理

分治思想：大问题划分为小问题，求解小问题，将小问题结果合并为大问题的结果

1、把长度为n的输入序列分成两个长度为n/2的子序列；

2、对这两个子序列分别采用归并排序；

3、 将两个排序好的子序列合并成一个最终的排序序列。



归并排序是稳定排序



### 二、复杂度

* 最坏 $O(NlogN)$
* 平均 $O(NlogN)$



### 三、实现

#### 递归版本

```c++
void mergeSortCore(vector<int>& data, vector<int>& dataTemp, int low, int high) {

 if (low >= high) return;
 int len = high - low, mid = low + len / 2;
 int start1 = low, end1 = mid, start2 = mid + 1, end2 = high;
 mergeSortCore(data, dataTemp, start1, end1);
 mergeSortCore(data, dataTemp, start2, end2);
 int index = low;
 while (start1 <= end1 && start2 <= end2) {
  dataTemp[index++] = data[start1] < data[start2] ? data[start1++] : data[start2++];
 }

 while (start1 <= end1) {
  dataTemp[index++] = data[start1++];
 }


 while (start2 <= end2) {
  dataTemp[index++] = data[start2++];
 }

 for (index = low; index <= high; ++index) {
  data[index] = dataTemp[index];
 }
}


void mergeSort(vector<int>& data) {
 int len = data.size();
 vector<int> dataTemp(len, 0);
 mergeSortCore(data, dataTemp, 0, len - 1);
}

```

#### 非递归版本

```c++
void mergeSort(vector<int>& data) {
 int len = data.size();
 vector<int> dataTemp(len, 0);
 for (int seg = 1; seg < len; seg += seg) {
  for (int start = 0; start < len; start += seg + seg) {

   int low = start, mid = min(start + seg, len), high = min(start + seg + seg, len);
   int index = low, start1 = low, end1 = mid, start2 = mid, end2 = high;
   
   while (start1 < end1 && start2 < end2) {
    dataTemp[index++] = data[start1] < data[start2] ? data[start1++] : data[start2++];
   }

   while (start1 < end1) {
    dataTemp[index++] = data[start1++];
   }


   while (start2 < end2) {
    dataTemp[index++] = data[start2++];
   }

  }
  swap(data, dataTemp);
 }

 for (auto a : data)
  cout << a << " "; 
}

```

#### 单链表

<https://leetcode.cn/problems/7WHec2/>

自顶向下归并排序

* 快慢指针找链表中点，分解成两个链表
    * 递归终止条件
        * head 为空返回 nullptr
        * 只有一个节点返回 head
* 对两个有序链表归并排序
* 合并两个有序链表：dummyHead

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* sortList(ListNode* head) {
        if(head == nullptr) return nullptr;
        else if(head->next == nullptr) return head;

        ListNode * mid = getMiddle(head);
        cout << mid->val << endl;
        ListNode * l1 = head;
        ListNode * l2 = mid->next;
        mid->next = nullptr;

        return mergeSortedList(sortList(l1), sortList(l2));
    }

    ListNode * getMiddle(ListNode * head) {
        ListNode * slow = head;
        ListNode * fast = head;
        // 0 1 2 3
        // 0 1 2 3 4
        while(fast->next && fast->next->next) {
            slow = slow->next;
            fast = fast->next->next;
        }
        return slow;
    }

    ListNode * mergeSortedList(ListNode * l1, ListNode * l2) {
        ListNode * dummyHead = new ListNode();
        ListNode * curr = dummyHead;
        while(l1 && l2) {
            if(l1->val < l2->val) {
                curr->next = l1;
                l1 = l1->next;
            } else {
                curr->next = l2;
                l2 = l2->next;
            }
            curr = curr->next;
        }

        curr->next = l1 ? l1 : l2;

        return dummyHead->next;
    }
};
```

## 选择排序

### 一、原理

选择排序是给每个位置选择当前元素最小的

1. 在未排序序列中找到最小（大）元素，存放到排序序列的起始位置
2. 从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾
3. 以此类推，直到所有元素均排序完毕
4. 非稳定排序，原地排序



### 二、复杂度

* 时间复杂度：$O(N^2)$
* 空间复杂度： $O(1)$

### 三、实现

#### 普通数组

```c++
void selectSort(vector<int>& nums) {
	int len = nums.size();
    int minIndex = 0;
    for (int i = 0; i < len; ++i) {
  		minIndex = i;
  		for (int j = i + 1; j < len; ++j) {
   			if (nums[j] < nums[minIndex]) minIndex = j;
  		}
  		swap(nums[i], nums[minIndex]);
 	}
}
```

#### 单链表

```c++

```

## 堆排序

### 一、原理

堆是具有以下性质的完全二叉树：

* 每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆
* 堆排序是不稳定算法。在交换数据的时候比较的是父节点和子节点之间的数据，如果存在两个值相等的兄弟节点，他们之间的顺序也可能在排序之后发生变化。

### 二、复杂度

时间复杂度： $O(NlogN)$



堆排序是唯一同时能够最优的利用时间和空间的排序方法，最坏的情况下也能保证线性对数的时间复杂性和恒定的空间

 但是实际开发中，快排要比堆排序的性能好，有以下几点：

 1. 堆排序数据访问的方式没有快排合并排序那么友好。对于快排和合并排序来说我们的数据时顺序访问的，而对于堆排序来说我们是跳着访问的，无法实现局部顺序访问，因此无法利用缓存。
 2. 对于同样的数据，在堆排序过程中数据交换的次数要多于快排。对于基于比较的算法来说，排序的过程基本由两部分组成即比较和交换。堆排序第一步是建堆，因此可能会打乱数据原有的顺序造成数据有序度降低，进而增加很多比较次数。

 但是，堆排序在空间利用十分紧张的地方比如嵌入式系统或者低成本的移动设备中很流行。



### 三、实现







## 快速排序

### 一、原理

快速排序用的是分治的思想，即通过选取一个pivot将数组分成两个子数组 A 和 B，子数组 A 中的元素均小于等于 pivot，子数组B中的元素均大于等于 pivot 中的元素。这个时候对于两个子数组A和B而言，每一个子数组又是一个数组需要选取一个pivot进行排序，这就是递归的思想。



1. 初始化 $i = 0, j = n - 1, prior = A[0]$
2. 从 $j$ 处从右往左扫描$(j--)$，直到找到第一个 $A[j] < prior$ 的位置，令 $A[i]= A[j]$
3. 从 $i$ 处从左向右开始扫描 $(i++)$, 直到找到第一个 $A[i] > prior$ 的位置，令 $A[j] = A[i]$
4. 重复 $(2),(3)$ 直到 $i = j$，令 $A[i] = prior$，快速排序完成



### 二、复杂度

* 平均时间复杂度：$O(nlog_2 n)$
* 最佳时间复杂度：$O(nlog_2 n)$
* 最差时间复杂度：$O(n^2)$
* 空间复杂度：根据实现方式的不同而不同



[快速排序时间复杂度分析 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/341201904)

经过上述**一趟快速排序，我们只确定了一个元素的最终位置**，我们最终需要经过 $n$ 趟快速排序才能将一个含有 $n$ 个数据元素的序列排好序，下面我们来分析其时间复杂度



设 $n$ 为待排序数组中元素的个数，$T(n)$ 为算法需要的时间复杂度

$T(n) = \left\{  
             \begin{array}{**lr**}  
             D(1), & n \leq 1\\  
             D(n) + T(I_1) + T(I_2), & n \textgreater 1\\  
             \end{array}  
\right. $

其中 $D(n)=n−1$ ,是一趟快排需要的比较次数，一趟快排结束后将数组分成两部分 $I_1$ 和 $I_2$



最好情况：每一次划分都正好将数组分成长度相等的两半

$T(n) = \left\{  
             \begin{array}{**lr**}  
             D(1), & n \leq 1\\  
             D(n) + T(n / 2) + T(n / 2), & n \textgreater 1\\  
             \end{array}  
\right. $



最坏情况：每一次划分都将数组划分 $0$ 和 $n - 1$ 两部分

$T(n) = \left\{  
             \begin{array}{**lr**}  
             D(1), & n \leq 1\\  
             D(n) + T(0) + T(n - 1), & n \textgreater 1\\  
             \end{array}  
\right. $



平均时间复杂度：任意一种划分情况出现的概率相等





 因此对于快速排序来说主要由两部分组成：第一部分是获取pivot的`partition`函数和进行快排递归的`quicksort`函数

 ```c++
 
 //这个函数主要是求pivot的
 int partition(int *a, int left, int right){
     //首先要随机选取一个pivot，这样做是为了根据pivot分成两个子数组数组。一下三种选择方式均可以
     int pivot = a[left];
     int pivot = a[right];
     int pivot = a[left + (right - left) / 2];//这样做是为了防止数组越界
     int pivot_index = left/right/left + (right - left) / 2
     //两个指针移动，当同时指到一个元素时候就退出循环
     //切记，必须从右边开始找！！！！
     while(left < right){
          while(a[right] >= pivot && left < right){
             right--;
         }
         while(a[left] <= pivot && left < right){
             left++;
         }
         if(left < right){
          swap(a[left], a[right]);            
         }
     }
     //这一步是为了将选取的pivot值放在中间，保证左边的子数组均比pivot小，右边的子数组均比pivot大
     //这一步也是交换元素,交换选取pivot的索引和left的索引所对应的值
     a[povit_index] = a[left];
     a[left] = povit;
     return left;
     /*优化的写法：：
     int pivot = a[left];
     while(left<right){
         while(left<right&&a[right]<=pivot)right--;
         a[left] = a[right];
         while(left<right&&a[left]>=pivot)left++;
         a[right] = a[left];
     }
     a[left] = pivot;
     return left;
     */
 }
 void quicksort(int *a, int left, int right){
     //边界条件判断
     if(left >= right){
         return;
     }
     int pivot = partition();
     quicksort(a, left, pivot - 1);
     quicksort(a, pivot +1, right);
 }
 ```

 **总结：**对上面代码，写的时候有几个地方需要注意：

 1. 在写内循环的时候，一定要先从右边开始写！！切记！！
 2. 当子数组中有小于pivot的时候和有大于pivot的时候，这个时候交换是正常的，将大小对调位置。但是，，我们最后退出大循环也要交换一次，这次交换是为了划分两个子数组，一个比pivot小，一个比pivot大。

* ##### 性能分析

 对于每一个数组，数值中的每一个元素都和一个定值进行比较，这样表明内循环很简洁。

  * 时间复杂度

  |   平均情况   | 最坏情况 |   最好情况   |
  | :----------: | :------: | :----------: |
  | $O(nlog_2n)$ | $O(n^2)$ | $O(nlog_2n)$ |

  对于快速排序算法来说最理想的情况时partition函数能做到最平衡的划分，即每次选取的pivot值都能将数组对半分，这样划分到最后使得每个部分只包含一个或者零个元素。但是缺点也很明显，即在划分函数partition极度不平衡的时候效率会很低。比如说第一次选取的pivot是最小元素，第二次选取的pivot是第二小的元素等等，这样会导致一个大数组切分n-1次。

  * 空间复杂度

  |  平均情况   | 最坏情况 |    最好情况     |
  | :---------: | :------: | :-------------: |
  | $O(log_2n)$ |  $O(n)$  | $O(log_2(n+1))$ |

  快速排序用到了递归，可以发现最好情况或者平均情况，将待排序数组每次对半分是最好的，这样的话就是logn，但是最坏的情况就是12345这种类型，基本上每次都要调栈，调大概n-1次。

  * 稳定性

  想一种情况，比如递增排序，右边有两个相同元素均小于pivot，这个时候调换到左边后相对位置会发生变化。所以是不稳定的。

* ##### 改进算法

  * 切换到插入排序

  对于小数组来说，插入排序要比快速排序效率高，因为当数组比较小的时候还是会递归。所以当递归划分的子数组较小的时候可以使用插入排序来进行。或者直接用宏排序来写。

  * 选取pivot的时候更优。一种选取方法是取前三个值的平均值，这样保证pivot比较均匀从统计学概率上来讲。或者选取中位数。
  
      

### 快排有什么优缺点

#### 为什么都在用快排而不是归并，堆？

**问：我们知道，快排平均复杂度为nlogn，最坏时间复杂度为$n^2$，而归并排序最坏才是nlogn。那么为什么还是用快排多，用归并少呢？**

我觉得原因有以下几个：

1. 首先了解O的含义，即O(nlgon)的O。大O符号又称为渐进符号，在数学上表示一个函数的渐进行为的符号，描述一个函数数量级的渐进下界，不考虑首项系数和低阶项。比如说有一个规模n的算法花费时间$T(n)=n^2+2n+c$，可以看到当n增大的时候$n^2$开始占据主导地位，因此$O(n)=n^2$。在实际的生产生活中我们所用的n并没有达到那么大的规模，因此这个2n+c这个点是不可以忽略的。

2. 快速排序一般是原地排序，不需要创建任何的辅助数组来保存临时变量。而归并排序需要用到两个额外的数组进行存储，同时将数组合并成为一个也会花费点时间。

3. 就常数项来说，快排< 归并 < 堆

 <img src="https://cdn.jsdelivr.net/gh/luogou/cloudimg/data/20211210114013.png" alt="image-20211210114012869" style="zoom:80%;" />

**问：什么场景下用归并比用快排好？**

当对连链表结构进行排序的时候，归并排序比快排高效。因为链表的存储空间时分散的，必须到每个节点的地址再连接起来，这就导致快排依靠数组的优势不存在了。同时归并使用链表结构的话，直接连接就行，不需要额外的辅助空间。

### 三、实现

#### 递归版本

```

```

#### 非递归版本

```

```

#### 栈实现快排

```

```

#### 队列实现快排

```

```

#### 单链表快排

```c++
int *QuickSort(Node* pBegin, Node* pEnd)
{
    if(pBegin == NULL || pEnd == NULL || pBegin == pEnd)
        return 0;
 
    //定义两个指针
    Node* p1 = pBegin;
    Node* p2 = pBegin->next;
    int pivot = pBegin->data;

 //每次只比较小的，把小的放在前面。经过一轮比较后，被分成左右两部分。其中p1指向中值处，pbegin为pivot。
    while(p2 != NULL)/* && p2 != pEnd->next */
 {
        if(p2->data < pivot)
  {
            p1 = p1->next;
            if(p1 != p2)
   {
                SwapData(&p1->data, &p2->data);
         }
       }
        p2 = p2->next;
   }
   /*此时pivot并不在中间，我们要把他放到中间，以他为基准，把数据分为左右两边*/
    SwapData(&p1->data, &pBegin->data);
    //此时p1是中值节点
 //if(p1->data >pBegin->data)
    QuickSort(pBegin, p1);
 //if(p1->data < pEnd->data)
    QuickSort(p1->next, pEnd);

}
```

#### 稳定的快速排序

```

```

## 希尔排序

### 一、原理

希尔排序可以说是插入排序的一种变种。无论是插入排序还是冒泡排序，如果数组的最大值刚好是在第一位，要将它挪到正确的位置就需要 n - 1 次移动。也就是说，原数组的一个元素如果距离它正确的位置很远的话，则需要与相邻元素交换很多次才能到达正确的位置，这样是相对比较花时间了。

希尔排序就是为了加快速度简单地改进了插入排序，交换不相邻的元素以对数组的局部进行排序。

希尔排序的思想是采用插入排序的方法，先让数组中任意间隔为 h 的元素有序，刚开始 h 的大小可以是 h = n / 2,接着让 h = n / 4，让 h 一直缩小，当 h = 1 时，也就是此时数组中任意间隔为1的元素有序，此时的数组就是有序的了。

为方便理解我还准备了图片：

![img](https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205072324235.gif)

如果还是不懂的话我还给你准备了优质的文章讲解：<https://mp.weixin.qq.com/s/4kJdzLB7qO1sES2FEW0Low>

```cpp
void shellSortCore(vector<int>& nums, int gap, int i) {
 int inserted = nums[i];
 int j;
    //  插入的时候按组进行插入
 for (j = i - gap; j >= 0 && inserted < nums[j]; j -= gap) {
  nums[j + gap] = nums[j];
 }
 nums[j + gap] = inserted;
}

void shellSort(vector<int>& nums) {
 int len = nums.size();
    //进行分组，最开始的时候，gap为数组长度一半
 for (int gap = len / 2; gap > 0; gap /= 2) {
        //对各个分组进行插入分组
  for (int i = gap; i < len; ++i) {
            //将nums[i]插入到所在分组正确的位置上
   shellSortCore(nums,gap,i);
  }
 }

 for (auto a : nums) {
  cout << a << "";
 }

}
```

## 计数排序

计数排序统计小于等于该元素值的元素的个数i，于是该元素就放在目标数组的索引i位（i≥0）。

* 计数排序基于一个假设，待排序数列的所有数均为整数，且出现在（0，k）的区间之内。
* 如果 k（待排数组的最大值） 过大则会引起较大的空间复杂度，一般是用来排序 0 到 100 之间的数字的最好的算法，但是它不适合按字母顺序排序人名。
* 计数排序不是比较排序，排序的速度快于任何比较排序算法。

**算法思想**：

1. 找出待排序的数组中最大和最小的元素；
2. 统计数组中每个值为 i 的元素出现的次数，存入数组 C 的第 i 项；
3. 对所有的计数累加（从 C 中的第一个元素开始，每一项和前一项相加）；
4. 向填充目标数组：将每个元素 i 放在新数组的第 C[i] 项，每放一个元素就将 C[i] 减去 1；

![计数排序](https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205072324770.gif)

代码

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

// 计数排序
void CountSort(vector<int>& vecRaw, vector<int>& vecObj)
{
 // 确保待排序容器非空
 if (vecRaw.size() == 0)
  return;

 // 使用 vecRaw 的最大值 + 1 作为计数容器 countVec 的大小
 int vecCountLength = (*max_element(begin(vecRaw), end(vecRaw))) + 1;
 vector<int> vecCount(vecCountLength, 0);

 // 统计每个键值出现的次数
 for (int i = 0; i < vecRaw.size(); i++)
  vecCount[vecRaw[i]]++;
 
 // 后面的键值出现的位置为前面所有键值出现的次数之和
 for (int i = 1; i < vecCountLength; i++)
  vecCount[i] += vecCount[i - 1];

 // 将键值放到目标位置
 for (int i = vecRaw.size(); i > 0; i--) // 此处逆序是为了保持相同键值的稳定性
  vecObj[--vecCount[vecRaw[i - 1]]] = vecRaw[i - 1];
}

int main()
{
 vector<int> vecRaw = { 0,5,7,9,6,3,4,5,2,8,6,9,2,1 };
 vector<int> vecObj(vecRaw.size(), 0);

 CountSort(vecRaw, vecObj);

 for (int i = 0; i < vecObj.size(); ++i)
  cout << vecObj[i] << "  ";
 cout << endl;

 return 0;
}
```

## 桶排序

将值为i的元素放入i号桶，最后依次把桶里的元素倒出来。

**算法思想**：

1. 设置一个定量的数组当作空桶子。
2. 寻访序列，并且把项目一个一个放到对应的桶子去。
3. 对每个不是空的桶子进行排序。
4. 从不是空的桶子里把项目再放回原来的序列中。

![桶排序](https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205072324235.gif)

```php
function bucketSort(arr, bucketSize) {
    if (arr.length === 0) {
      return arr;
    }
 
    var i;
    var minValue = arr[0];
    var maxValue = arr[0];
    for (i = 1; i < arr.length; i++) {
      if (arr[i] < minValue) {
          minValue = arr[i];                // 输入数据的最小值
      } else if (arr[i] > maxValue) {
          maxValue = arr[i];                // 输入数据的最大值
      }
    }
 
    // 桶的初始化
    var DEFAULT_BUCKET_SIZE = 5;            // 设置桶的默认数量为5
    bucketSize = bucketSize || DEFAULT_BUCKET_SIZE;
    var bucketCount = Math.floor((maxValue - minValue) / bucketSize) + 1;
    var buckets = new Array(bucketCount);
    for (i = 0; i < buckets.length; i++) {
        buckets[i] = [];
    }
 
    // 利用映射函数将数据分配到各个桶中
    for (i = 0; i < arr.length; i++) {
        buckets[Math.floor((arr[i] - minValue) / bucketSize)].push(arr[i]);
    }
 
    arr.length = 0;
    for (i = 0; i < buckets.length; i++) {
        insertionSort(buckets[i]);                      // 对每个桶进行排序，这里使用了插入排序
        for (var j = 0; j < buckets[i].length; j++) {
            arr.push(buckets[i][j]);
        }
    }

    return arr;
}
```

## 基数排序

一种多关键字的排序算法，可用桶排序实现。

**算法思想**：

1. 取得数组中的最大数，并取得位数；
2. arr为原始数组，从最低位开始取每个位组成radix数组；
3. 对radix进行计数排序（利用计数排序适用于小范围数的特点）

![基数排序](https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205072325422.gif)

代码

```cpp
int maxbit(int data[], int n) //辅助函数，求数据的最大位数
{
    int maxData = data[0];  ///< 最大数
    /// 先求出最大数，再求其位数，这样有原先依次每个数判断其位数，稍微优化点。
    for (int i = 1; i < n; ++i)
    {
        if (maxData < data[i])
            maxData = data[i];
    }
    int d = 1;
    int p = 10;
    while (maxData >= p)
    {
        //p *= 10; // Maybe overflow
        maxData /= 10;
        ++d;
    }
    return d;
/*    int d = 1; //保存最大的位数
    int p = 10;
    for(int i = 0; i < n; ++i)
    {
        while(data[i] >= p)
        {
            p *= 10;
            ++d;
        }
    }
    return d;*/
}
void radixsort(int data[], int n) //基数排序
{
    int d = maxbit(data, n);
    int *tmp = new int[n];
    int *count = new int[10]; //计数器
    int i, j, k;
    int radix = 1;
    for(i = 1; i <= d; i++) //进行d次排序
    {
        for(j = 0; j < 10; j++)
            count[j] = 0; //每次分配前清空计数器
        for(j = 0; j < n; j++)
        {
            k = (data[j] / radix) % 10; //统计每个桶中的记录数
            count[k]++;
        }
        for(j = 1; j < 10; j++)
            count[j] = count[j - 1] + count[j]; //将tmp中的位置依次分配给每个桶
        for(j = n - 1; j >= 0; j--) //将所有桶中记录依次收集到tmp中
        {
            k = (data[j] / radix) % 10;
            tmp[count[k] - 1] = data[j];
            count[k]--;
        }
        for(j = 0; j < n; j++) //将临时数组的内容复制到data中
            data[j] = tmp[j];
        radix = radix * 10;
    }
    delete []tmp;
    delete []count;
}
 
```



## C++ sort 排序

* 数据量大时采用快速排序，分段归并排序
* 一旦分段后数据量小于某个门槛（16）为了避免快排递归调用带来过大的额外负荷，改用插入排序
* 如果递归过深，改用堆排序
