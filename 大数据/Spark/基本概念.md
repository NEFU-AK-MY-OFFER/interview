https://blog.csdn.net/qq_40522090/article/details/139738474

# Spark 基本概念

## 简述什么是Spark ？
Spark 是一个开源的大数据处理框架，它被设计来进行高速度、通用性和易用性的大规模数据处理。Spark 最初由加州大学伯克利分校的AMPLab 开发，后来成为Apache软件基金会的顶级项目。

Spark 的主要特点包括：

快速性：Spark 使用了内存计算技术，相较于Hadoop的MapReduce，它能更快地处理大规模数据集。这是因为MapReduce在数据处理过程中频繁地将中间结果写入磁盘，而Spark尽可能地将数据保留在内存中处理，从而大幅度提高了处理速度。

易用性：Spark 提供了易于使用的APIs，支持多种编程语言，如Scala、Python和Java。这使得开发人员可以用他们熟悉的语言快速编写分布式数据处理任务。

通用性：Spark 不仅支持批量数据处理（类似于MapReduce），还支持流处理、图计算、机器学习等多种计算模式。这意味着同一个框架可以用于不同类型的数据处理需求，提高了开发和管理的效率。

高容错性：通过RDD（弹性分布式数据集）的概念，Spark 能够容错。如果某个节点执行失败，Spark 可以重新计算丢失的数据，保证处理过程的稳定性。

举个例子，Spark 被广泛应用于实时数据分析。假设一个电商平台想要实时分析用户的点击流数据来做个性化推荐。在这种场景下，Spark的快速数据处理能力可以实时处理海量数据，同时其机器学习库（MLlib）可以辅助进行用户行为分析，从而实现即时的个性化推荐。

## 简述Spark部署模式 ？
Spark 支持多种部署模式，以适应不同的计算环境。主要的部署模式包括：

本地模式：在这种模式下，Spark 集群运行在单个机器上，通常用于开发和测试。在这种模式下，所有的 Spark 组件都运行在同一个 JVM 进程中。

独立模式：这是 Spark 的标准集群部署模式，不依赖于外部的集群管理器。在这种模式下，你需要手动启动 Spark 的 Master 和 Worker 节点。它适合于专门为 Spark 或小型到中型集群配置的环境。

YARN 模式：在这种模式下，Spark 运行在 YARN（Yet Another Resource Negotiator）上，YARN 是 Hadoop 的资源管理器。这种模式允许 Spark 与其他基于 YARN 的应用共享集群资源。

Mesos 模式：Apache Mesos 是一个通用的集群管理器，可以运行 Spark 和其他应用。在 Mesos 模式下，Mesos 负责分配资源给 Spark。

Kubernetes 模式：近年来逐渐流行，可以在 Kubernetes 集群上运行 Spark。Kubernetes 提供了容器编排和管理，使 Spark 可以更灵活地部署和扩展。

各种部署模式都有自己的适用场景。例如，本地模式适合开发和测试，独立模式适合专门为 Spark 配置的小型集群，YARN 模式适合已有 Hadoop 集群的环境，Mesos 和 Kubernetes 模式适合需要更复杂资源调度和管理的大型应用。在实际应用中，选择合适的部署模式取决于具体的资源管理需求、集群环境和应用场景。

## 简述Spark主要功能与特性 ？
Spark是一个强大的分布式数据处理系统，主要用于大数据处理和分析。它的主要功能与特性包括：

快速处理：Spark使用了先进的DAG（有向无环图）执行引擎，可以实现快速的数据处理。它可以比传统的Hadoop MapReduce快上数倍。

易于使用：Spark提供了丰富的API，支持Scala、Java、Python和R语言，使得编写大数据应用更加简单。

支持多种计算模式：Spark不仅支持批处理，还支持流处理、交互式查询（Spark SQL）、机器学习（MLlib）和图处理（GraphX）。

内存计算：Spark的一个显著特点是它能够将数据存储在内存中，这大大加快了迭代算法和交互式数据挖掘的速度。

容错性：即使在节点失败的情况下，Spark也能保证数据的容错性和一致性，通过RDD（弹性分布式数据集）的概念实现数据的恢复。

可伸缩性：Spark可以在从几台机器到几千台机器的集群上运行，具有很好的水平伸缩性。

应用场景示例：

实时数据处理：例如，使用Spark Streaming对社交媒体数据进行实时分析，以监测品牌声誉或即时趋势。
机器学习：利用MLlib进行大规模机器学习，如推荐系统或预测模型。
数据仓库：通过Spark SQL进行大数据仓库的建设和复杂查询，支持数据挖掘和报告。
图形处理：使用GraphX对社交网络或交通网络进行图形分析和计算。
Spark的这些特性使得它非常适用于需要快速处理大量数据的场景，尤其是在数据分析和机器学习领域。

## 简述Spark对MapReduce优势 ？
Spark 相对于 MapReduce 的优势主要体现在以下几个方面：

内存计算：Spark 最大的优势是它的内存计算能力。MapReduce 在处理每个阶段的数据时，都需要读写磁盘，这导致了大量的磁盘I/O开销和较长的处理时间。而Spark能将数据存储在内存中，减少了磁盘I/O，从而显著提高了数据处理速度。

计算优化：Spark 提供了高级的DAG（有向无环图）执行引擎，可以对任务流程进行优化。这意味着Spark能更智能地安排任务的执行顺序和数据的传输方式，而MapReduce的执行计划相对简单且固定。

易用性：Spark 提供了更丰富、更高层次的API，比如DataFrame和Dataset API，使得编写分布式数据处理程序更加简单。而MapReduce的API相对底层，编写起来更加复杂。

多样的数据处理模式：Spark 不仅支持批处理（类似MapReduce），还支持流处理、机器学习、图处理等多种数据处理模式。这意味着可以用同一个框架来处理不同类型的数据处理任务，而MapReduce主要用于批处理。

容错机制：虽然MapReduce和Spark都有很好的容错性，但Spark通过RDD实现的容错机制更加高效。它可以在内存中快速恢复丢失的数据，而MapReduce需要重新执行整个任务，这会导致更长的恢复时间。

例如，在进行大规模数据分析时，使用Spark可以显著减少数据处理的时间，提高效率。在实时数据流处理方面，Spark的流处理能力也远远超过MapReduce，能更好地满足实时数据分析的需求。

## 简述Spark的任务执行流程 ？
Spark 的任务执行流程可以分为以下几个主要步骤：

创建 RDD（弹性分布式数据集）：Spark 程序的第一步通常是创建一个 RDD，这可以通过读取外部数据源（如 HDFS、S3等）或将现有的 Scala/Java/Python 集合转换为 RDD 来实现。

RDD 转换：创建 RDD 后，可以对其进行各种转换操作，如 map、filter、reduceByKey 等。这些转换是惰性执行的，也就是说，它们只有在需要结果的时候才会执行。

行动操作：要触发实际的计算，需要调用行动操作（action），如 collect、count、saveAsTextFile 等。行动操作会触发 Spark 作业的提交。

作业调度：当行动操作被调用时，Spark 上下文会提交一个作业。Spark 会将作业分解为一系列阶段（stage），阶段之间由宽依赖（例如 Shuffle）分隔。

任务分配：在每个阶段内，Spark 会根据分区数创建任务（task）。这些任务会被分配到集群中的不同节点上执行。

任务执行：各节点上的执行器（executor）开始执行任务。这包括读取数据、执行 RDD 转换和行动操作，并将结果返回给 Spark 上下文。

Shuffle 过程：如果操作需要跨分区移动数据（如 reduceByKey），则会进行 Shuffle 过程。Shuffle 是一个复杂的过程，涉及跨节点的数据传输。

结果返回：最终，结果会被发送回到发起行动操作的 Spark 上下文，或者被写入到外部存储系统中。

整个过程中，Spark 会尽量在内存中处理数据以提高效率，但也支持磁盘备份以处理大数据集。例如，一个典型的应用场景是数据聚合：首先通过 map 操作来转换数据，然后通过 reduceByKey 来进行聚合操作，最后使用 collect 或其他行动操作来获取最终结果。这个流程涵盖了从数据读取、处理到结果获取的整个过程。

## 简述Spark的运行流程 ？
Spark 的运行流程大致可以分为以下几个步骤：

初始化：Spark 应用的运行始于初始化一个 SparkContext 对象。这个对象负责与 Spark 集群进行通信，同时也是用户和 Spark 功能之间的主要接口。

读取数据：Spark 通过 SparkContext 读取数据源（比如 HDFS、本地文件系统等）中的数据，并将其转换为 RDD（弹性分布式数据集）或 DataFrame（用于结构化数据处理的抽象模型）。这是数据处理的起点。

转换操作：在数据加载到 Spark 之后，可以对其执行各种转换操作（如 map、filter、join 等）。这些操作不会立即执行，而是构建了一个转换操作的链。

行动操作：当应用执行一个行动操作（如 count、collect、save 等）时，Spark 会触发实际的数据处理。行动操作是转换操作链的终点，它们会导致数据被真正处理。

任务调度：执行行动操作时，SparkContext 会向集群管理器（如 YARN、Mesos 或 Spark 自身的 Standalone 模式）提交任务。集群管理器负责在集群中分配资源。

DAG 计划和任务执行：Spark 内部的 DAG 调度器会将作业分解成多个阶段，每个阶段包含多个任务。这些任务被分配到集群的不同节点上执行。

结果处理：作业完成后，结果会返回到 Spark 应用。如果是行动操作（如 collect），结果会返回到驱动程序；如果是保存操作（如 saveAsTextFile），结果会被写入到指定的存储系统。

资源释放：任务完成后，SparkContext 会关闭，释放其占用的资源。

例如，一个数据分析任务可能需要从 HDFS 加载数据，对数据进行过滤和聚合操作，然后计算结果并保存回 HDFS。在这个过程中，Spark 负责数据的读取、转换操作的定义、计算任务的分发和执行，以及最终结果的保存。

## 简述Spark的作业运行流程是怎么样的 ？
Spark 的作业运行流程主要包括以下几个步骤：

创建SparkContext：首先，需要创建一个SparkContext实例。SparkContext是Spark应用的入口点，它负责与Spark集群进行通信，并且协调集群中的资源。

加载和转换数据：接下来，使用SparkContext来加载数据，这些数据可以来自不同的数据源，如HDFS、数据库等。加载后的数据会被转换成RDD（弹性分布式数据集）。然后可以对这些RDD应用各种转换操作（如map、filter等）来进行数据处理。

行动操作：在对数据进行转换后，需要执行行动操作（如collect、count、save等）来触发实际的计算。Spark中的转换操作是惰性的，只有在执行行动操作时才会真正开始计算。

任务调度：当行动操作被触发时，SparkContext会向集群管理器（如YARN、Mesos或Spark自身的集群管理器）提交作业。集群管理器负责资源的分配。

DAG调度：Spark的DAG调度器会将作业分解为多个阶段，每个阶段由多个任务组成。这些任务会被打包发送到集群上的不同节点进行执行。

任务执行：在集群节点上，任务开始执行。如果任务需要读取数据，它们会从HDFS或其他存储系统中读取。任务在执行过程中可能会在内存中缓存数据，以便快速访问。

结果返回：任务执行完毕后，结果会被发送回驱动程序（即运行SparkContext的程序）。如果是行动操作需要返回数据到驱动程序的，如collect，那么相关数据会被传输回来；如果是行动操作不需要返回数据，如save，那么作业就此结束。

关闭SparkContext：最后，作业完成后，需要关闭SparkContext来释放资源。

例如，在一个电商网站的日志分析场景中，可能会使用Spark来处理和分析用户的访问日志。首先，SparkContext创建后，日志文件会被加载为RDD，然后进行一系列的转换操作（如过滤特定的页面访问，统计访问次数等），最后通过行动操作触发计算并得到结果。整个过程涉及了数据的加载、转换、计算和结果的获取等多个阶段。

## 简述Spark源码中的任务调度 ？
在 Spark 源码中，任务调度是一个复杂且核心的功能。它负责管理和分配计算资源，确保任务高效执行。任务调度大致可以分为以下几个主要部分：

DAG（有向无环图）调度器：Spark 首先将用户程序转换成一个 DAG，其中节点代表 RDD 的转换操作，边代表 RDD 之间的依赖关系。DAG 调度器的作用是将这个 DAG 分解成多个阶段（Stage）。每个阶段包含一组可以并行执行的任务。

任务划分：DAG 调度器会根据宽依赖（例如，Shuffle 操作导致的依赖）将 DAG 划分为不同的阶段。每个阶段内的任务是相对独立的，可以并行执行。

任务队列：划分好的任务会被放入任务队列中。Spark 维护了几个不同的任务队列，用于管理不同优先级和类型的任务。

任务调度策略：Spark 提供了多种任务调度策略，比如 FIFO（先进先出）、FAIR（公平调度）等。调度策略决定了哪些任务先执行，哪些后执行。

资源分配：任务被调度后，需要在集群中的节点上执行。Spark 调度器会与集群管理器（如 YARN、Mesos 或 Kubernetes）通信，请求必要的资源来运行任务。

任务执行：一旦资源分配完成，任务就被发送到相应的 Spark Executor 执行。Executor 运行任务，并将结果返回给调度器。

错误处理和重试机制：在任务执行过程中，如果发生错误（如节点故障），调度器会根据设定的策略重新调度任务到其他节点上执行。

结果汇总：所有阶段完成后，最终结果会被汇总并返回给用户程序。

在整个任务调度过程中，Spark 通过精细的资源管理和高效的调度策略来优化任务执行，确保高性能和高可靠性。例如，在处理大型数据集时，Spark 能够动态调整资源分配和任务调度，以适应不同阶段的计算和内存需求。

## 简述Spark作业调度 ？
Spark作业调度是指在Spark应用程序中，如何高效地组织和管理作业的执行流程。它主要涉及以下几个方面：

DAG调度：Spark作业首先被转化为一个有向无环图（DAG），其中的节点表示RDD的转换操作，边表示数据的依赖关系。DAG调度器（DAGScheduler）根据这个图来决定任务（Tasks）的执行顺序。

阶段划分：DAGScheduler将DAG划分为多个阶段（Stages）。一个阶段包含了可以并行执行的任务集合，通常是直到遇到一个宽依赖（例如shuffle操作）为止。

任务调度与分配：每个阶段被划分成多个任务，这些任务由TaskScheduler负责调度。TaskScheduler负责

简述spark部署模式(资源调度模式) ？
Spark 支持多种部署模式，也称为资源调度模式。这些模式定义了如何在集群中分配和管理资源。主要的部署模式包括：

本地模式（Local Mode）：

这是最简单的模式，用于开发和测试。
在这种模式下，Spark 的所有组件都运行在同一台机器上（即单个JVM）。
它不涉及任何的网络通信，适合快速试验和调试。
独立集群模式（Standalone Mode）：

Spark 有自己的集群管理器，用于管理其自身集群资源。
在这种模式下，你需要手动启动 Spark 的所有服务，包括一个 Master 服务器和多个 Worker 节点。
适用于专门为 Spark 应用准备的环境。
Apache Mesos：

Mesos 是一种通用的集群管理器，可以运行各种分布式应用。
Spark 支持在 Mesos 上运行，Mesos 负责资源分配和任务调度。
这种模式适用于希望在同一集群上运行多种服务的环境。
Hadoop YARN：

YARN（Yet Another Resource Negotiator）是 Hadoop 2.x 的资源管理组件。
Spark 可以在 YARN 上运行，利用 YARN 进行资源管理和任务调度。
这种模式适合已经有 Hadoop 集群的环境，可以与其他 Hadoop 生态系统应用共享资源。
Kubernetes：

Kubernetes 是一个开源的容器编排系统，用于自动部署、扩展和管理容器化应用。
Spark 支持在 Kubernetes 上运行，可以利用 Kubernetes 的弹性伸缩、服务发现和资源管理等特性。
适用于希望在云环境或容器化环境中运行 Spark 的场景。
每种模式都有其适用的场景和优势。选择哪种部署模式取决于你的具体需求、现有的基础设施和资源管理策略。例如，如果你已经有一个 Hadoop 集群，那么选择 YARN 模式可能更合适；如果你正在使用 Kubernetes 管理容器化应用，那么 Kubernetes 模式会是一个很好的选择。

简述Spark的使用场景 ？
Spark的应用场景非常广泛，主要可以概括为以下几个方面：

大数据处理与分析：Spark能够快速处理和分析大规模数据集，适用于数据挖掘、日志分析、用户行为分析等场景。例如，互联网公司可以使用Spark分析用户点击流数据，从而优化网站布局和推荐算法。

实时数据处理：利用Spark Streaming，Spark可以处理实时数据流。这适用于需要实时数据分析的场景，如社交媒体趋势分析、实时交通监控、在线广告投放等。

机器学习与数据科学：通过MLlib，Spark提供了丰富的机器学习算法，适合进行大规模的机器学习任务。这包括建立预测模型、用户画像、推荐系统等应用。

图形数据处理：通过GraphX，Spark能够处理大规模的图形数据。这适用于社交网络分析、网络拓扑分析、复杂关系挖掘等场景。

数据仓库增强：Spark可以与传统的数据仓库结合使用，增强其处理能力，特别是在处理大规模数据集时的性能提升方面。企业可以使用Spark来进行复杂的数据仓库查询和大数据分析。

科学计算：Spark也适用于科学研究中的大规模数值计算，比如基因组学数据分析、物理模拟等领域。

总之，Spark因其高效的数据处理能力、多样的数据处理模式和丰富的生态系统，成为了处理大数据、实时数据分析、机器学习等多种应用场景的首选平台。

## 简述Spark on Standalone运行过程 ？
在 Spark Standalone 模式下的运行过程涉及以下几个关键步骤：

启动集群：首先，需要启动 Spark 集群。这包括启动一个 Master 节点和多个 Worker 节点。Master 节点负责整个集群的资源管理和调度，而 Worker 节点提供资源来执行应用程序。

提交应用程序：用户通过 Spark 提交命令（如 spark-submit）来提交应用程序。在这个过程中，可以指定应用程序的资源需求（如内存和核心数）和其他配置。

资源分配：Master 节点接收到应用程序后，根据其资源需求和集群的当前资源状况分配资源。资源分配后，Master 会为应用程序启动一个或多个 Executor。

Executor 启动：在 Worker 节点上，根据 Master 的指示，启动 Executor 进程。每个 Executor 会被分配一定数量的核心和内存资源。

任务执行：应用程序的代码开始在 Executor 上执行。这通常涉及到读取数据、处理数据和写入结果。Executor 之间可能需要通过网络进行数据传输，尤其是在执行 Shuffle 操作时。

资源使用和调整：在应用程序运行期间，Master 节点会持续监控资源使用情况，并根据需要进行调整，以确保资源的有效利用。

作业完成：应用程序完成后，Executor 会将结果返回给用户程序，并释放占用的资源。Master 节点会更新资源状态，准备接受新的应用程序提交。

在 Spark Standalone 模式下，所有资源调度和管理都是由 Spark 自身完成的，不依赖于外部的资源管理系统。这种模式适合于专门为 Spark 配置的集群，特别是在不需要与其他类型的大数据应用共享资源时。例如，一个数据分析团队可能会使用 Spark Standalone 模式来运行数据处理和分析作业，因为这种模式可以简化配置和管理，使团队能够更专注于数据处理逻辑本身。

## 简述Spark on YARN运行过程 ？
在 Spark on YARN（Yet Another Resource Negotiator）模式下的运行过程涉及 Spark 应用和 YARN 集群的协作。具体过程如下：

初始化 Spark 应用：

首先，开发者编写的 Spark 应用程序通过初始化 SparkContext 来启动。
SparkContext 在与 YARN 交互时，会向 YARN 提出资源请求，用于运行应用。
应用提交：

开发者将 Spark 应用程序提交到 YARN 集群。这通常通过命令行工具完成，例如使用 spark-submit 命令。
提交应用时，需要指定运行模式为 YARN。
资源请求和分配：

YARN 的 ResourceManager 接收到应用提交请求后，开始为应用分配所需资源。
这包括启动 ApplicationMaster（Spark 应用的主控进程）和分配执行任务的 NodeManager（节点管理器）。
启动 ApplicationMaster：

ApplicationMaster 是运行在 YARN 集群中的一个容器，负责管理 Spark 作业的执行和资源协调。
它向 ResourceManager 请求运行任务所需的资源（比如 CPU、内存）。
任务调度和执行：

ApplicationMaster 根据作业的需求，向 ResourceManager 请求更多的资源来启动 Executor。
Executor 是运行在 YARN 的 NodeManager 上的进程，负责执行 Spark 作业中的任务。
Spark 作业被分解成多个任务，这些任务由 Executor 执行。
数据处理：

Executor 开始执行任务，处理数据。这可能涉及从 HDFS 或其他存储系统读取数据，执行转换和行动操作。
在处理过程中，ApplicationMaster 监控任务执行情况，并与 ResourceManager 交互以调整资源分配。
作业完成和资源释放：

一旦 Spark 作业完成，Executor 将结果返回给 ApplicationMaster。
ApplicationMaster 将最终结果返回给客户端（驱动程序），并向 ResourceManager 通知作业完成。
随后，ApplicationMaster 和 Executor 释放它们所占用的资源，YARN 会回收这些资源。
例如，在一个数据分析项目中，你可能需要使用 Spark on YARN 来处理大量存储在 HDFS 中的数据。在这种场景下，YARN 负责在集群中有效地分配和管理资源，而 Spark 负责执行复杂的数据处理任务。通过这种合作，Spark on YARN 能够高效地进行大规模数据处理。

## 简述YARN-Client 与 YARN-Cluster 区别 ？
在Apache Spark中，当使用YARN（Yet Another Resource Negotiator）作为资源管理器时，可以选择两种不同的模式来提交和运行应用程序：YARN-Client模式和YARN-Cluster模式。这两种模式的主要区别在于驱动程序（Driver）的运行位置和应用程序的提交方式：

YARN-Client模式：

驱动程序位置：在YARN-Client模式中，Spark驱动程序运行在提交作业的客户端机器上，而不是在YARN集群中。
资源管理：驱动程序与YARN ResourceManager通信来分配资源，但是它本身并不占用集群中的资源。
适用场景：这种模式适合于交互式和调试应用程序，因为可以直接在客户端看到驱动程序的输出，更方便进行问题的诊断和调试。
YARN-Cluster模式：

驱动程序位置：在YARN-Cluster模式下，Spark驱动程序实际上是作为一个YARN应用程序的一部分在集群的某个节点上运行的。
资源管理：驱动程序在集群中占用资源，与其他应用程序一样通过YARN进行资源的分配和管理。
适用场景：这种模式适用于生产环境和长时间运行的应用程序，特别是当不需要频繁地查看驱动程序输出或进行交互式探索时。
综上所述，选择YARN-Client模式还是YARN-Cluster模式取决于应用程序的需求和使用场景。YARN-Client模式更适合开发和调试，而YARN-Cluster模式更适合生产环境和需要高效资源利用的场景。

## 简述Spark的yarn-cluster涉及的参数有哪些 ？
在 Spark 中使用 YARN 集群模式（yarn-cluster）时，有多个参数可以配置，这些参数影响着 Spark 作业的行为和性能。主要的参数包括：

资源相关参数：

spark.executor.memory：每个 Executor 的内存大小。
spark.executor.cores：每个 Executor 使用的核心数。
spark.executor.instances：启动的 Executor 实例数。
spark.yarn.am.memory：Application Master 的内存大小。
spark.yarn.am.cores：Application Master 使用的核心数。
部署相关参数：

spark.yarn.jars：指定 Spark 应用所需的 jars 路径。
spark.yarn.archive：用来指定包含所有依赖的 zip 或 tar 文件。
spark.yarn.dist.files：需要传输到 YARN 集群的文件列表。
动态资源分配参数（如果启用）：

spark.dynamicAllocation.enabled：是否启用动态资源分配。
spark.dynamicAllocation.minExecutors：动态分配的最小 Executor 数。
spark.dynamicAllocation.maxExecutors：动态分配的最大 Executor 数。
spark.dynamicAllocation.initialExecutors：初始 Executor 数。
spark.dynamicAllocation.executorIdleTimeout：Executor 空闲超时时间。
网络和序列化参数：

spark.serializer：用于 RDD 序列化的类。
spark.network.timeout：网络超时设置。
spark.rpc.askTimeout 或 spark.rpc.lookupTimeout：RPC 通信超时。
应用名称和队列：

spark.app.name：Spark 应用的名称。
spark.yarn.queue：YARN 队列名称，用于提交作业。
这些参数可以在 spark-submit 命令中通过 --conf 选项设置，或者在 Spark 应用的配置文件中指定。正确配置这些参数对于优化 Spark 作业的性能和资源利用非常重要。例如，调整 Executor 的内存和核心数可以帮助更高效地处理大数据集，而启用动态资源分配可以根据作业的实际需求自动调整资源使用，从而提高集群的整体效率。

由于内容太多，更多内容以链接形势给大家，点击进去就是答案了

16. 简述Spark提交job的流程 ？

17. 简述Spark的阶段划分流程 ？

18. 简述Spark处理数据的具体流程 ？

19. 简述Spark join的分类 ？

20. 简述Spark map join的实现原理 ？

21. 简述Spark ShuGle及其优缺点 ？

23. 简述SparkContext 与 SparkSession之间的区别是什么 ？

24. 简述什么情况下会产生Spark ShuGle ？

25. 简述为什么要Spark ShuGle ？

26. 简述Spark为什么适合迭代处理 ？

27. 简述Spark数据倾斜问题，如何定位，解决方案 ？

28. Spark的stage如何划分？在源码中是怎么判断属于ShuGle Map Stage或Result Stage的 ？

29. 简述Spark join在什么情况下会变成窄依赖 ？

30. 简述Spark的内存模型（ 重要详细 ） ？

31. 简述Spark中7种存储级别 ？

32. 简述Spark分哪几个部分（模块）？分别有什么作用（做什么，自己用过哪些，做过什么） ？

33. RDD的宽依赖和窄依赖，举例一些算子 ？

34. Spark SQL的GroupBy会造成窄依赖吗 ？

35. 简述GroupBy是行动算子吗 ？

36. 简述Spark的宽依赖和窄依赖，为什么要这么划分 ？

37. Spark中的Transform和Action，为什么Spark要把操作分为Transform 和Action？常用的列举一些，说下算子原理 ？

38. 简述Spark的哪些算子会有shuGle过程 ？

41. 简述Spark的Job、Stage、Task分别介绍下，如何划分 ？

42. 简述Application 、job、Stage、task之间的关系 ？

43. 简述Stage内部逻辑 ？

44. 简述为什么要根据宽依赖划分Stage ？

45. 简述为什么要划分Stage ？

46. 简述Stage的数量等于什么 ？

47. 简述对RDD、DAG 和Task的理解 ？

48. 简述DAG为什么适合Spark ？

49. 简述Spark的DAG以及它的生成过程 ？

50. 简述DAGScheduler如何划分？

51. 简述Spark容错机制（ 重点 ） ？

53. 简述Executor如何内存分配 ？

54. 简述Spark的batchsize，怎么解决小文件合并问题 ？

55. 简述Spark参数（性能）调优 ？

56. 简述Spark怎么基于内存计算的 ？

60. 简述Spark广播变量的实现和原理 ？

61. 简述reduceByKey和groupByKey的区别和作用 ？

62. 简述reduceByKey和reduce的区别 ？

63. 简述使用reduceByKey出现数据倾斜怎么办 ？

64. 简述Spark SQL的执行原理 ？

65. 简述Spark checkpoint ？

66. 简述Spark SQL与DataFrame的使用 ？

67. 简述HashPartitioner和RangePartitioner的实现 ？

68. 简述Spark的水塘抽样 ？

69. 简述DAGScheduler、TaskScheduler、SchedulerBackend实现原理 ？

70. 简述Spark client提交application后，接下来的流程 ？

71. 简述Spark的几种部署方式（详解） ？

72. 简述在Yarn-client情况下，Driver此时在哪 ？

73. 简述Spark的cluster模式有什么好处 ？

74. 简述Driver怎么管理executor ？

75. 简述Spark的map和flatmap的区别 ？

76. 简述map和mapPartition的区别 ？

78. 简述DataFrame的cache和persist的区别 ？

81. 简述Spark输出文件的个数，如何合并小文件 ？

82. 简述Spark的driver是怎么驱动作业流程的 ？

83. 简述Spark SQL的劣势 ？

84. 简述Spark Streaming和Structed Streaming ？

85. 简述Spark为什么比Hadoop速度快 ？

86. 简述Spark Streaming的双流join的过程，怎么做的 ？

87. 简述Spark怎么保证数据不丢失 ？

88. 简述Spark SQL如何使用UDF ？

89. 简述Spark实现wordcount ？

91. 简述Spark SQL读取文件，内存不够使用，如何处理 ？

92. 简述Spark的lazy体现在哪里 ？

93. 简述Spark中的并行度等于什么 ？

94. 简述Spark运行时并行度的设置 ？

95. 简述Spark SQL的数据倾斜解决方案 ？

96. 简述Spark的RDD和partition的联系 ？

97. 简述Spark 3.0特性 ？

98. 简述Spark计算的灵活性体现在哪里 ？

100. 简述解释 Spark 中的 Accumulator 共享变量 ？

