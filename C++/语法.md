# 语法

## 问题

### 变量

* 定义和声明的区别
* 初始化和赋值的区别
* 全局变量与局部变量区别
* 形参与实参区别
* 说说静态局部变量，全局变量，局部变量的特点，以及使用场景
* 两个相互依赖的全局变量怎么初始化

### struct

* C++ 中struct的拷贝？
* 说说 C++中 struct 和 class 的区别，和 C struct 的区别
* struct 和 union 的区别？
* 结构体变量比较是否相等

### 引用、指针

* 说说数组和指针的区别？
* 说说C++中函数指针和指针函数的区别，函数指针应用场景？
* 简述C++有几种传值方式，之间的区别是什么？
* 说说使用指针需要注意什么，谈谈野指针、空悬指针？
* 指针与引用的区别？
* C++中NULL和nullptr区别？
* 指针加减计算要注意什么？
* 从汇编层去解释一下引用？
* 一个指针占多少字节？
* char a,char a[],`char *a`,``char*[]``,`char **a` 之间的区别
* 谈谈 sizeof
* 谈谈 void*

### const

* 简述常量指针和指针常量区别
* 顶层 const 和 底层 const
* const 的作用
* mutable 关键字

### define

* 说一下你理解的 ifdef endif代表着什么？

* define 与 const 的区别

* define 与 typedef 的区别

* define 与 inline 的区别

* define 与 函数 的区别

* 谈谈 assert()

* 用#define声明一个常数，表明1年中有多少秒（忽略闰年问题）？

* 宏实现比较大小，以及两个数中的最小值

### inline

* 内联函数优缺点
* 说说内联函数和函数的区别，内联函数的作用。
* 说说内联函数和宏函数的区别
* 为什么不能把所有的函数写成内联函数?

### static

* static 的作用
* 全局遍历和 static 变量的区别
* 谈谈 static 变量初始化时机
* static 线程安全问题

### 类型转换

* 隐式转换，如何消除隐式转换？

* 谈谈 static_cast

* 谈谈 reinterpret_cast

* 谈谈 const_cast

* 谈谈 dynamic_cast

* 继承机制中对象之间如何转换？指针和引用之间如何转换？

* 谈谈 RTTI 机制

### 字符串

* strcpy函数和strncpy函数的区别？哪个函数更安全？
* string和char*的区别
* string 和 `vector<char>`
* 知道const char* 与string之间的关系是什么吗？
* printf 和 cout 区别
* 谈谈 std::string

## 回答

### 变量

#### 定义和声明的区别

**如果是指变量的声明和定义：** 从编译原理上来说，声明是仅仅告诉编译器，有个某类型的变量会被使用，但是编译器并不会为它分配任何内存。而定义就是分配了内存。

**如果是指函数的声明和定义：** 声明：一般在头文件里，对编译器说：这里我有一个函数叫function() 让编译器知道这个函数的存在。 定义：一般在源文件里，具体就是函数的实现过程 写明函数体。

* 声明仅仅是把变量的声明的位置及类型提供给编译器，并不分配内存空间；定义要在定义的地方为其分配存储空间。
* 相同变量可以在多处声明（外部变量extern），但只能在一处定义。

#### 初始化和赋值的区别

* 对于简单类型来说，初始化和赋值没什么区别
* 对于类和复杂数据类型来说，初始化调用拷贝构造函数，赋值调用重载的赋值操作符函数

#### 全局变量与局部变量区别

生命周期不同：全局变量随主程序创建和创建，随主程序销毁而销毁；局部变量在局部函数内部，甚至局部循环体等内部存在，退出就不存在；

使用方式不同：通过声明后全局变量在程序的各个部分都可以用到；局部变量分配在堆栈区，只能在局部使用。

操作系统和编译器通过内存分配的位置可以区分两者，全局变量分配在全局数据段并且在程序开始运行的时候被加载。局部变量则分配在堆栈里面 。

#### 形参与实参区别

* 形参变量只有在被调用时才分配内存单元，在调用结束时， 即刻释放所分配的内存单元。因此，形参只有在函数内部有效。 函数调用结束返回主调函数后则不能再使用该形参变量。
* 实参可以是常量、变量、表达式、函数等， 无论实参是何种类型的量，在进行函数调用时，它们都必须具有确定的值， 以便把这些值传送给形参。 因此应预先用赋值，输入等办法使实参获得确定值，会产生一个临时变量。
* 实参和形参在数量上，类型上，顺序上应严格一致， 否则会发生“类型不匹配”的错误。
* 函数调用中发生的数据传送是单向的。 即只能把实参的值传送给形参，而不能把形参的值反向地传送给实参。 因此在函数调用过程中，形参的值发生改变，而实参中的值不会变化。
* 当形参和实参不是指针类型时，在该函数运行时，形参和实参是不同的变量，他们在内存中位于不同的位置，形参将实参的内容复制一份，在该函数运行结束的时候形参被释放，而实参内容不会改变。

#### **说说静态局部变量，全局变量，局部变量的特点，以及使用场景**

**首先从作用域考虑**：C++里作用域可分为6种：全局，局部，类，语句，命名空间和文件作用域。

* 全局变量：全局作用域，可以通过extern作用于其他非定义的源文件。
* 静态全局变量 ：全局作用域+文件作用域，所以无法在其他文件中使用。
* 局部变量：局部作用域，比如函数的参数，函数内的局部变量等等。
* 静态局部变量 ：局部作用域，只被初始化一次，直到程序结束。

**从所在空间考虑**：除了局部变量在栈上外，其他都在静态存储区。因为静态变量都在静态存储区，所以下次调用函数的时候还是能取到原来的值。

**生命周期**： 局部变量在栈上，出了作用域就回收内存；而全局变量、静态全局变量、静态局部变量都在静态存储区，直到程序结束才会回收内存。

**使用场景**：从它们各自特点就可以看出各自的应用场景，不再赘述。

#### 两个相互依赖的全局变量怎么初始化

### struct

#### 说说 C++中 struct 和 class 的区别，和 C struct 的区别

struct 一般用于描述一个数据结构集合，而 class 是对一个对象数据的封装；

struct 中默认的访问控制权限是 public 的，而 class 中默认的访问控制权限是 private 的，例如：

```c++
struct A {  int iNum; }  // 默认访问控制权限是 public 
class B {  int iNum; }  // 默认访问控制权限是 private
```

在继承关系中，struct 默认是公有继承，而 class 是私有继承；

class 关键字可以用于定义模板参数，就像 typename，而 struct 不能用于定义模板参数，例如：

```c++
template<typename T, typename Y> // 可以把typename 换成 class
int Func(const T& t, const Y& y) {    //TODO }
```

C++ 中的 struct 是对 C 中的 struct 进行了扩充，它们在声明时的区别如下：

|          | **C**                  | **C++**                  |
| -------- | ---------------------- | ------------------------ |
| 成员函数 | 不能有                 | 可以                     |
| 静态成员 | 不能有                 | 可以                     |
| 访问控制 | 默认public，不能修改   | public/private/protected |
| 继承关系 | 不可以继承             | 可从类或者其他结构体继承 |
| 初始化   | 不能直接初始化数据成员 | 可以                     |

使用时的区别：C 中使用结构体需要加上 struct 关键字，或者对结构体使用 typedef 取别名，而 C++ 中可以省略 struct 关键字直接使用

```c++
struct Student{  
 int  iAgeNum;  
 string strName; 
} 
typedef struct Student Student2; //C中取别名  
struct Student stu1; // C 中正常使用 
Student2 stu2;   // C 中通过取别名的使用 
Student stu3;   // C++ 中使用
```

#### struct 和 union 的区别？

结构体struct：把不同类型的数据组合成一个整体。struct里每个成员都有自己独立的地址。sizeof(struct)是内存对齐后所有成员长度的加和。（引申出[内存对齐](#说一说内存对齐)的问题）

共同体union：各成员共享一段内存空间, 一个union变量的长度等于各成员中最长的长度，以达到节省空间的目的。所谓的共享不是指把多个成员同时装入一个union变量内, 而是指该union变量可被赋予任一成员值,但每次只能赋一种值, 赋入新值则冲去旧值。 sizeof(union)是最长的数据成员的长度。

> 总结： struct和union都是由多个不同的数据类型成员组成, 但在任何同一时刻, union中只存放了一个被选中的成员, 而struct的所有成员都存在。在struct中，各成员都占有自己的内存空间，它们是同时存在的。一个struct变量的总长度等于所有成员长度之和。**在Union中，所有成员不能同时占用它的内存空间，它们不能同时存在。**Union变量的长度等于最长的成员的长度。对于union的不同成员赋值, 将会对其它成员重写, 原来成员的值就不存在了, 而对于struct的不同成员赋值是互不影响的。

### 引用、指针

#### 说说数组和指针的区别？

* 数组在内存中是连续存放的，开辟一块连续的内存空间；数组所占存储空间：sizeof（数组名）；数组大小：sizeof(数组名)/sizeof(数组元素数据类型)；
* 用运算符sizeof 可以计算出数组的容量（字节数）。sizeof(p),p 为指针得到的是一个指针变量的字节数，而不是p 所指的内存容量。
* 编译器为了简化对数组的支持，实际上是利用指针实现了对数组的支持。具体来说，就是将表达式中的数组元素引用转换为指针加偏移量的引用。
* 在向函数传递参数的时候，如果实参是一个数组，那用于接受的形参为对应的指针。也就是传递过去是数组的首地址而不是整个数组，能够提高效率；
* 在使用下标的时候，两者的用法相同，都是原地址加上下标值，不过数组的原地址就是数组首元素的地址是固定的，指针的原地址就不是固定的。

（1）数组：数组是用于储存多个相同类型数据的集合。 数组名是首元素的地址。

（2）指针：指针相当于一个变量，但是它和不同变量不一样，它存放的是其它变量在**内存中的地址**。 指针名指向了内存的首地址。

区别：

（1）**赋值**：同类型指针变量可以相互赋值；数组不行，只能一个一个元素的赋值或拷贝

（2）**存储方式**：

  数组：数组在内存中是连续存放的，开辟一块连续的内存空间。数组是根据数组的下进行访问的，数组的存储空间，不是在静态区就是在栈上。

  指针：指针很灵活，它可以指向任意类型的数据。指针的类型说明了它所指向地址空间的内存。由于指针本身就是一个变量，再加上它所存放的也是变量，所以指针的存储空间不能确定。

（3）**求sizeof**：

  数组所占存储空间的内存大小：sizeof（数组名）/sizeof（数据类型）

  在32位平台下，无论指针的类型是什么，sizeof（指针名）都是4，在64位平台下，无论指针的类型是什么，sizeof（指针名）都是8。

（4）**初始化**：

```plaintext
// 数组 
int a[5] = { 0 }; 
char b[] = "Hello"; // 按字符串初始化，大小为6 
char c[] = { 'H','e','l','l','o','\0' }; // 按字符初始化 
int* arr = new int[10]; // 动态创建一维数组  
// 指针 
// 指向对象的指针 
int* p = new int(0); delete p; 
// 指向数组的指针 
int* p1 = new int[10]; delete[] p1; 
// 指向类的指针：
string* p2 = new string; delete p2; 
// 指向指针的指针（二级指针） 
int** pp = &p; **pp = 10;
```

（5）指针操作：

  数组名的指针操作

```plaintext
int a[3][4];   
int (*p)[4];  //该语句是定义一个数组指针，指向含4个元素的一维数组 
p = a;    //将该二维数组的首地址赋给p，也就是a[0]或&a[0][0] 
p++;          //该语句执行过后，也就是p=p+1；p跨过行a[0][]指向了行
a[1][]               //所以数组指针也称指向一维数组的指针，亦称行指针。 
//访问数组中第i行j列的一个元素，有几种操作方式： 
//*(p[i]+j)、*(*(p+i)+j)、(*(p+i))[j]、p[i][j]。其中，优先级：()>[]>*。 
//这几种操作方式都是合法的。
```

指针变量的数据操作：

```plaintext
char *str = "hello,douya!";
str[2] = 'a';
*(str+2) = 'b';
//这两种操作方式都是合法的。
```

**数组名和指针的区别**

假设数组int a[10]; int [*p](10) = &a;其中：

* a是数组名，是数组首元素地址，+1表示地址值加上一个int类型的大小，如果a的值是0x00000001，加1操作后变为0x00000005。*(a + 1) = a[1]。
* &a是数组的指针，其类型为int [*](10)（就是前面提到的数组指针），其加1时，系统会认为是数组首地址加上整个数组的偏移（10个int型变量），值为数组a尾元素后一个元素的地址。
* 若(int *)p ，此时输出*p时，其值为a[0]的值，因为被转为int *类型，解引用时按照int类型大小来读取。
* 二者均可通过增减偏移量来访问数组中的元素。
* 数组名不是真正意义上的指针，可以理解为常指针，所以数组名没有自增、自减等操作。
* **当数组名当做形参传递给调用函数后，就失去了原有特性，退化成一般指针，多了自增、自减操作，但sizeof运算符不能再得到原数组的大小了。**

#### 说说C++中函数指针和指针函数的区别，函数指针的应用场景

**定义不同** 指针函数本质是一个函数，其返回值为指针。 函数指针本质是一个指针，其指向一个函数。

**写法不同**

```c++
指针函数：int *fun(int x,int y);
函数指针：int (*fun)(int x,int y);
```

**函数指针的声明方法**

int (*pf)(const int&, const int&); (1)

上面的pf就是一个函数指针，指向所有返回类型为int，并带有两个const int&参数的函数。注意*pf两边的括号是必须的，否则上面的定义就变成了：

int *pf(const int&, const int&); (2)

而这声明了一个函数pf，其返回类型为int *， 带有两个const int&参数。

**用法不同**

```c++
//指针函数示例
typedef struct _Data{
    int a;
    int b;
}Data;
//指针函数
Data* f(int a,int b){
    Data * data = new Data;
    //...
    return data;
}
int main(){
    //调用指针函数
    Data * myData = f(4,5);
    //Data * myData = static_cast<Data*>(f(4,5));
   //...
}

//函数指针示例
int add(int x,int y){
    return x+y;
}
//函数指针
int (*fun)(int x,int y);
//赋值
fun = add;
//调用
cout << "(*fun)(1,2) = " << (*fun)(1,2) ;
//输出结果
//(*fun)(1,2) =  3
```

函数指针的**应用场景**：**回调**（callback）

我们调用别人提供的 API函数(Application Programming Interface,应用程序编程接口)，称为Call；如果别人的库里面调用我们的函数，就叫Callback。

回调函数的作用

* 当发生某种事件时，系统或其他函数将会自动调用你定义的一段函数；
* 回调函数就相当于一个中断处理函数，由系统在符合你设定的条件时自动调用。为此，你需要做三件事：1，声明；2，定义；3，设置触发条件，就是在你的函数中把你的回调函数名称转化为地址作为一个参数，以便于系统调用；
* 回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用为调用它所指向的函数时，我们就说这是回调函数；
* 因为可以把调用者与被调用者分开。调用者不关心谁是被调用者，所有它需知道的，只是存在一个具有某种特定原型、某些限制条件（如返回值为int）的被调用函数。

```c++
//以库函数qsort排序函数为例，它的原型如下：
void qsort(void *base,//void*类型，代表原始数组
           size_t nmemb, //第二个是size_t类型，代表数据数量
           size_t size, //第三个是size_t类型，代表单个数据占用空间大小
           int(*compar)(const void *,const void *)//第四个参数是函数指针
          );
//第四个参数告诉qsort，应该使用哪个函数来比较元素，即只要我们告诉qsort比较大小的规则，它就可以帮我们对任意数据类型的数组进行排序。在库函数qsort调用我们自定义的比较函数，这就是回调的应用。

//示例
int num[100];
int cmp_int(const void* _a , const void* _b){//参数格式固定
    int* a = (int*)_a;    //强制类型转换
    int* b = (int*)_b;
    return *a - *b;　　
}
qsort(num,100,sizeof(num[0]),cmp_int); //回调
```

#### 简述C++有几种传值方式，之间的区别是什么？

* 值传递：形参即使在函数体内值发生变化，也不会影响实参的值；
* 引用传递：形参在函数体内值发生变化，会影响实参的值；
* 指针传递：在指针指向没有发生改变的前提下，形参在函数体内值发生变化，会影响实参的值；

* 需要返回函数内局部变量的内存的时候用指针。使用指针传参需要开辟内存，用完要记得释放指针，不然会内存泄漏。而返回局部变量的引用是没有意义的
* 对栈空间大小比较敏感（比如递归）的时候使用引用。使用引用传递不需要创建临时变量，开销要更小
* 类对象作为参数传递的时候使用引用，这是C++类对象传递的标准方式
* 值传递用于对象时，整个对象会拷贝一个副本，这样效率低；而引用传递用于对象时，不发生拷贝行为，只是绑定对象，更高效；指针传递同理，但不如引用传递安全。

```c++
//代码示例
#include <iostream>
using namespace std;

void testfunc(int a, int *b, int &c){//形参a值发生了改变，但是没有影响实参i的值；但形参*b、c的值发生了改变，影响到了实参*j、k的值
    a += 1;
    (*b) += 1;
    c += 1;
    printf("a= %d, b= %d, c= %d\n",a,*b,c);//a= 2, b= 2, c= 2
}
int main(){
       int i = 1;
    int a = 1;
    int *j = &a;
    int k = 1;
    testfunc(i, j, k);
    printf("i= %d, j= %d, k= %d\n",i,*j,k);//i= 1, j= 2, k= 2
    return 0;
}
```

对比值传递，引用传参的好处：

1）在函数内部可以对此参数进行修改

2）提高函数调用和运行的效率（因为没有了传值和生成副本的时间和空间消耗）

如果函数的参数实质就是形参，不过这个形参的作用域只是在函数体内部，也就是说实参和形参是两个不同的东西，要想形参代替实参，肯定有一个值的传递。函数调用时，值的传递机制是通过“形参=实参”来对形参赋值达到传值目的，产生了一个实参的副本。即使函数内部有对参数的修改，也只是针对形参，也就是那个副本，实参不会有任何更改。函数一旦结束，形参生命也宣告终结，做出的修改一样没对任何变量产生影响。

用引用作为返回值最大的好处就是在内存中不产生被返回值的副本。

但是有以下的限制：

1）不能返回局部变量的引用。因为函数返回以后局部变量就会被销毁

2）不能返回函数内部new分配的内存的引用。虽然不存在局部变量的被动销毁问题，可对于这种情况（返回函数内部new分配内存的引用），又面临其它尴尬局面。例如，被函数返回的引用只是作为一 个临时变量出现，而没有被赋予一个实际的变量，那么这个引用所指向的空间（由new分配）就无法释放，造成memory leak

3）可以返回类成员的引用，但是最好是const。因为如果其他对象可以获得该属性的非常量的引用，那么对该属性的单纯赋值就会破坏业务规则的完整性。

\1) 使用引用参数的主要原因有两个：

程序员能修改调用函数中的数据对象

通过传递引用而不是整个数据–对象，可以提高程序的运行速度

\2) 一般的原则： 对于使用引用的值而不做修改的函数：

如果数据对象很小，如内置数据类型或者小型结构，则按照值传递；

如果数据对象是数组，则使用指针（唯一的选择），并且指针声明为指向const的指针；

如果数据对象是较大的结构，则使用const指针或者引用，已提高程序的效率。这样可以节省结构所需的时间和空间；

如果数据对象是类对象，则使用const引用（传递类对象参数的标准方式是按照引用传递）；

\3) 对于修改函数中数据的函数：

如果数据是内置数据类型，则使用指针

如果数据对象是数组，则只能使用指针

如果数据对象是结构，则使用引用或者指针

如果数据是类对象，则使用引用

#### 说说使用指针需要注意什么，谈谈野指针、空悬指针？

* 定义指针时，先初始化为NULL。
* 用malloc或new申请内存之后，应该**立即检查**指针值是否为NULL。防止使用指针值为NULL的内存。
* 不要忘记为数组和动态内存**赋初值**。防止将未被初始化的内存作为右值使用。
* 避免数字或指针的下标**越界**，特别要当心发生“多1”或者“少1”操作
* 动态内存的申请与释放必须配对，防止**内存泄漏**
* 用free或delete释放了内存之后，立即将指针**设置为NULL**，防止“野指针”

```c++
int *p = NULL; //初始化置NULL
p = (int *)malloc(sizeof(int)*n); //申请n个int内存空间  
assert(p != NULL); //判空，防错设计
p = (int *) realloc(p, 25);//重新分配内存, p 所指向的内存块会被释放并分配一个新的内存地址
free(p);  
p = NULL; //释放后置空

int *p1 = NULL; //初始化置NULL
p1 = (int *)calloc(n, sizeof(int)); //申请n个int内存空间同时初始化为0 
assert(p1 != NULL); //判空，防错设计
free(p1);  
p1 = NULL; //释放后置空

int *p2 = NULL; //初始化置NULL
p2 = new int[n]; //申请n个int内存空间  
assert(p2 != NULL); //判空，防错设计
delete []p2;  
p2 = nullptr; //释放后置空  
```

**悬空指针**
指向已删除（或释放）的内存位置的指针称为悬空指针。指针用作悬空指针有三种不同的方式

①内存分配：

![img](https://img-blog.csdnimg.cn/img_convert/4ab1bf0c2530e260194f401a4b630339.png)

②函数调用：

![img](https://img-blog.csdnimg.cn/img_convert/58f4f9adfba08fee9fc1620cb3e4cb3d.png)

如果x是静态变量，则不会出现问题（或p不会悬空）。

![img](https://img-blog.csdnimg.cn/img_convert/729fc06abcb17dcd2bfa68388a2f995d.png)

输出：5

变量超出范围

![img](https://img-blog.csdnimg.cn/img_convert/5c21703c696b543112c26fae4fd79f93.png)

**无效指针**
无效指针是一种特定的指针类型– void * –指向存储中某个数据位置的指针，它没有任何特定的类型。空是指类型。基本上，它指向的数据类型可以是任何类型。如果我们将char数据类型的地址分配给void指针，它将成为char指针，如果是int数据类型，则将成为int指针，依此类推。任何指针类型都可以转换为空指针，因此可以指向任何值。

（1）void指针不能被取消引用。但是，可以使用类型转换void指针来完成

（2）由于缺少具体的值和大小，因此无法对void指针进行指针算术运算。

例子：

![img](https://img-blog.csdnimg.cn/img_convert/fafd4a3732242e45a68c567ae4ab857e.png)

输出：

整数变量为= 4

浮动变量是= 5.500000

**空指针**
NULL指针是没有指向任何内容的指针。如果没有将地址分配给指针的情况，则可以简单地使用NULL。

![img](https://img-blog.csdnimg.cn/img_convert/f6bee4184adb94e62e955009765d10ba.png)

输出 ：

ptr的值为（null）

注意

（1）NULL与未初始化的指针–未初始化的指针存储未定义的值。空指针存储定义的值，但是环境定义的值不是任何成员或对象的有效地址。

（2）NULL vs void 指针–空指针是一个值，而空指针是一个类型

**野指针**
尚未初始化为任何值（甚至不是NULL）的指针称为野生指针。可以将指针初始化为一个非NULL垃圾值，该值可能不是有效地址。

![img](https://img-blog.csdnimg.cn/img_convert/066666e600e5cef427107b1e0f6eb665.png)

#### 指针与引用的区别？

* 指针是一个变量，存储的是一个地址，引用跟原来的变量实质上是同一个东西，是原变量的别名
* 指针可以有多级，引用只有一级
* 指针可以为空，引用不能为NULL且在定义时必须初始化
* 指针在初始化后可以改变指向，而引用在初始化之后不可再改变
* sizeof指针得到的是本指针的大小，sizeof引用得到的是引用所指向变量的大小
* 当把指针作为参数进行传递时，也是将实参的一个拷贝传递给形参，两者指向的地址相同，但不是同一个变量，在函数中改变这个变量的指向不影响实参，而引用却可以。
* 引用本质是一个指针，同样会占4字节内存；指针是具体变量，需要占用存储空间（，具体情况还要具体分析）。
* 引用在声明时必须初始化为另一变量，一旦出现必须为typename refname &varname形式；指针声明和定义可以分开，可以先只声明指针变量而不初始化，等用到时再指向具体变量。
* 引用一旦初始化之后就不可以再改变（变量可以被引用为多次，但引用只能作为一个变量引用）；指针变量可以重新指向别的变量。
* 不存在指向空值的引用，必须有具体实体；但是存在指向空值的指针。

#### 指针加减计算要注意什么？

**1)** 指针参数传递本质上是值传递，它所传递的是一个地址值。

值传递过程中，被调函数的形式参数作为被调函数的局部变量处理，会在栈中开辟内存空间以存放由主调函数传递进来的实参值，从而形成了实参的一个副本（替身）。

值传递的特点是，被调函数对形式参数的任何操作都是作为局部变量进行的，不会影响主调函数的实参变量的值（形参指针变了，实参指针不会变）。

**2)** 引用参数传递过程中，被调函数的形式参数也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。

被调函数对形参（本体）的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量（根据别名找到主调函数中的本体）。

因此，被调函数对形参的任何操作都会影响主调函数中的实参变量。

**3)** 引用传递和指针传递是不同的，虽然他们都是在被调函数栈空间上的一个局部变量，但是任何对于引用参数的处理都会通过一个间接寻址的方式操作到主调函数中的相关变量。

而对于指针传递的参数，如果改变被调函数中的指针地址，它将应用不到主调函数的相关变量。如果想通过指针参数传递来改变主调函数中的相关变量（地址），那就得使用指向指针的指针或者指针引用。

**4)** 从编译的角度来讲，程序在编译时分别将指针和引用添加到符号表上，符号表中记录的是变量名及变量所对应地址。

指针变量在符号表上对应的地址值为指针变量的地址值，而引用在符号表上对应的地址值为引用对象的地址值（与实参名字不同，地址相同）。

符号表生成之后就不会再改，因此指针可以改变其指向的对象（指针变量中的值可以改），而引用对象则不能修改。

指针加减本质是对其所指地址的移动，移动的步长跟指针的类型是有关系的，因此在涉及到指针加减运算需要十分小心，加多或者减多都会导致指针指向一块未知的内存地址，如果再进行操作就会很危险。

举个例子：

```plaintext
#include <iostream>
using namespace std;

int main()
{
    int *a, *b, c;
    a = (int*)0x500;
    b = (int*)0x520;
    c = b - a;
    printf("%d\n", c); // 8
    a += 0x020;
    c = b - a;
    printf("%d\n", c); // -24
    return 0;
}
```

首先变量a和b都是以16进制的形式初始化，将它们转成10进制分别是1280（5*16^2=1280）和1312（5*16^2+2*16=1312)， 那么它们的差值为32，也就是说a和b所指向的地址之间间隔32个位，但是考虑到是int类型占4位，所以c的值为32/4=8

a自增16进制0x20之后，其实际地址变为1280 + 2*16*4 = 1408，（因为一个int占4位，所以要乘4），这样它们的差值就变成了1312 - 1280 = -96，所以c的值就变成了-96/4 = -24

遇到指针的计算，**需要明确的是指针每移动一位，它实际跨越的内存间隔是指针类型的长度，建议都转成10进制计算，计算结果除以类型长度取得结果**

#### C++ 中 NULL 和 nullptr 区别？

算是为了与C语言进行兼容而定义的一个问题吧

NULL来自C语言，一般由宏定义实现，而 nullptr 则是C++11的新增关键字。**在C语言中，NULL被定义为(void\*)0,而在C++语言中，NULL则被定义为整数0**。编译器一般对其实际定义如下：

```C
#ifdef __cplusplus
#define NULL 0
#else
#define NULL ((void *)0)
#endif
```

在C++中指针必须有明确的类型定义。但是将NULL定义为0带来的另一个问题是无法与整数的0区分。因为C++中允许有函数重载，所以可以试想如下函数定义情况：

```c++
#include <iostream>
using namespace std;

void fun(char* p) {
    cout << "char*" << endl;
}

void fun(int p) {
    cout << "int" << endl;
}

int main()
{
    fun(NULL);
    return 0;
}
//输出结果：int
```

那么**在传入NULL参数时，会把NULL当做整数0来看，如果我们想调用参数是指针的函数，该怎么办呢?。nullptr在C++11被引入用于解决这一问题，nullptr可以明确区分整型和指针类型，能够根据环境自动转换成相应的指针类型，但不会被转换为任何整型，所以不会造成参数传递错误。**

nullptr的一种实现方式如下：

```c++
const class nullptr_t{
public:
    template<class T>  inline operator T*() const{ return 0; }
    template<class C, class T> inline operator T C::*() const { return 0; }
private:
    void operator&() const;
} nullptr = {};
```

以上通过模板类和运算符重载的方式来对不同类型的指针进行实例化从而解决了(void*)指针带来参数类型不明的问题，**另外由于nullptr是明确的指针类型，所以不会与整形变量相混淆。**但nullptr仍然存在一定问题，例如：

```c++
#include <iostream>
using namespace std;

void fun(char* p) {
    cout<< "char* p" <<endl;
}
void fun(int* p) {
    cout<< "int* p" <<endl;
}

void fun(int p) {
    cout<< "int p" <<endl;
}
int main() {
    fun((char*)nullptr);//语句1
    fun(nullptr);//语句2
    fun(NULL);//语句3
    return 0;
}
//运行结果：
//语句1：char* p
//语句2:报错，有多个匹配
//3：int p
```

在这种情况下存在对不同指针类型的函数重载，此时如果传入nullptr指针则仍然存在无法区分应实际调用哪个函数，这种情况下必须显示的指明参数类型。

#### 从汇编层去解释一下引用？

```assembly
9:      int x = 1;

00401048  mov     dword ptr [ebp-4],1

10:     int &b = x;

0040104F   lea     eax,[ebp-4]

00401052  mov     dword ptr [ebp-8],eax
```

x的地址为ebp-4，b的地址为ebp-8，因为栈内的变量内存是从高往低进行分配的，所以b的地址比x的低。

lea eax,[ebp-4] 这条语句将x的地址ebp-4放入eax寄存器

 mov dword ptr [ebp-8],eax 这条语句将eax的值放入b的地址

ebp-8中上面两条汇编的作用即：将x的地址存入变量b中，这不和将某个变量的地址存入指针变量是一样的吗？所以从汇编层次来看，的确引用是通过指针来实现的。

#### 一个指针占多少字节？

在16题中有提到sizeof（str）的值为8，是在64位的编译环境下的，指针的占用大小为8字节；

而在32位环境下，指针占用大小为4字节。

一个指针占内存的大小跟编译环境有关，而与机器的位数无关。

还有疑问的，可以自行打开Visual Studio编译器自己实验一番。

#### char a,char a[],char *a,char*[],char **a 之间的区别

1. char a

 > 定义了一个存储空间，存储的是char类型的变量

2. char a[]

 > 是一个字符数组，数组中的每一个元素是一个char类型的数据

3. char *a

 > **字符串的本质（在计算机眼中）是其第一个字符的地址，c和c++中操作字符串是通过内存中其存储的首地址来完成的**
 >
 > 对于char a[]来说a代表的是数组的首地址，那么对char *a来说a代表的也是字符串的首地址
 >
 > 因此char a[]和char *a可以放到一块看，这两个没有本质区别。
 >
 > 但是要注意对于char s[]和char* a我们可以有`s=a`，但不能有`a=s`，因为创建数组的时候s的地址不为空已经确定，但是a是一个空指针，不能将非空的地址指向空指针

4. char *a[]

 > *的优先级是低于[]的，因此要先看a[]再看*
 >
 > 因此这是一个char数组，数组中的每一个元素都是指针，这些指针指向char类型
 >
 > `char *a[ ] = {"China","French","America","German"}`

5. char **a

 > 两个**代表相同的优先级，因此从右往左看，即`char*(*a)`
 >
 > char *a不就是一个字符串数组，a代表首地址。那么char* (*a)就是和char*a[]一样的数据结构

#### 谈谈 sizeof

> **sizeof的定义**
>
> sizeof是C语言的一种单目操作符，它并不是函数。**sizeof操作符以字节形式给出了其操作数所占存储空间的大小。**操作数可以是一个表达式或括在括号内的类型名。操作数所占存储空间的大小由操作数的类型决定。作用就是返回一个对象或者类型所占的内存字节数。sizeof在头文件中typedef为unsigned int，其值在编译时即计算好了，参数可以是数组、指针、类型、对象、函数等。它的功能是：获得保证能容纳实现所建立的最大对象的字节大小。由于在编译时计算，因此sizeof不能用来返回动态分配的内存空间的大小。
>
> 数组——编译时分配的数组空间大小；
>
> 指针——存储该指针所用的空间大小（存储该指针的地址的长度，是长整型，应该为4）；
>
> 类型——该类型所占的空间大小；
>
> 对象——对象的实际占用空间大小；
>
> 函数——函数的返回类型所占的空间大小。函数的返回类型不能是void。
>
> 对了，还要注意结构体的内存对齐原则！！！这个也是考点

问：定义一个不包含任何成员变量和成员函数的空的类，对该类型sizeof，得到的结果是多少？

答：1。因为该类的实例不包含任何信息，按常理来说应该sizeof=0的。但是当我们声明该类实例时，必须在内存中占用一定的空间才行，否则你无法使用这些实例。至于占用多少内存是由编译器决定的。用了一个char为了保证空类和空类之间在内存中不会有相同的地址。c++中的struct和class本质其实没有区别，区别仅仅是默认的“权限不同”，class是private，struct是public，sizeof(class)或者sizeof(struct)是1。

问：如果在空类里面添加一个构造函数和析构函数，sizeof是多少？

答：还是一样的。因为调用构造函数和析构函数或者其他函数只需要知道函数的地址就行，函数的地址和类的实例无关。

问：如果吧析构函数或者其他函数编程虚函数呢？

答：如果类中有虚函数，会生成虚函数表，并且每个对象都会在头部添加一个指向虚函数表的指针。所以sizeof就是指针的大小，计算机内部地址总线的宽度，32位机器上是4，64位机器上是8。

问：不用sizeof如何获得int所占的字节数？

思路：设初始值为1，则循环将值左移，直到值为0，记录循环的次数，即总共的位数，再除以8（一个字节=8位），即该类型的字节长度。

```c++
int main()
{
    int i = 1;
    int count = 0;
    while(i)
        i = i <<1;//一个循环，每次左移一位
     count++;
    cout << count/8 << endl;//因为一个字节8位
    return 0;
}
```

#### 谈谈 void*

指针是对内存区域的抽象。指针变量中存放着目标对象的内存地址，而与指针相复合的类型，则说明了相应内存区域中的内容具有哪些属性，以及能做什么事情。也就是说，在内存空间某块区域中的内容，原本可以是不可解读的；但是，如果有一个描述这块内存区域的指针存在，我们就能找到它（地址的作用），并且合理地使用它（类型的作用）。void* 只有其中一半的作用。因为没有明确与指针相复合的类型，所以不能解引用，也不能使用基于类型之上（sizeof(T)）的指针运算。

### const

#### 简述常量指针和指针常量区别的区别

```c
//const* 是常量指针，*const 是指针常量
int const *a;    //a指针所指向的内存里的值不变，即（*a）不变
int *const a;    //a指针所指向的内存地址不变，即a不变
const int a;     //指的是a是一个常量，不允许修改。
const int *a;    //a指针所指向的内存里的值不变，即（*a）不变
const int *const a;   //都不变，即（*a）不变，a也不变
```

#### 顶层 const 和 底层 const

**概念区分**

* **顶层**const：指的是const修饰的变量**本身**是一个常量，无法修改，指的是指针，就是 * 号的右边
* **底层**const：指的是const修饰的变量**所指向的对象**是一个常量，指的是所指变量，就是 * 号的左边

**举个例子**

```plaintext
int a = 10;int* const b1 = &a;        //顶层const，b1本身是一个常量
const int* b2 = &a;       //底层const，b2本身可变，所指的对象是常量
const int b3 = 20;            //顶层const，b3是常量不可变
const int* const b4 = &a;  //前一个const为底层，后一个为顶层，b4不可变
const int& b5 = a;           //用于声明引用变量，都是底层const
```

**区分作用**

* 执行对象拷贝时有限制，常量的底层const不能赋值给非常量的底层const
* 使用命名的强制类型转换函数const_cast时，只能改变运算对象的底层const

```plaintext
const int a;int const a;const int *a;int *const a;
```

* int const a和const int a均表示定义常量类型a。
* const int *a，其中a为指向int型变量的指针，const在* 左侧，表示a指向不可变常量。(看成const (*a)，对引用加const)
* int *const a，依旧是指针类型，表示a为指向整型数据的常指针。(看成const(a)，对指针const)

#### const 的作用

* 不考虑类的情况

  * const常量在定义时必须初始化，之后无法更改
  * const形参可以接收const和非const类型的实参，例如// i 可以是 int 型或者 const int 型void fun(const int& i){ //...}
  * 在一个函数声明中，const可以修饰形参，表明它是一个输入参数，在函数内部不能改变其值
  * 对指针来说，可以指定指针本身为const，也可以指定指针所指的数据为const，或二者同时指定为const
  * const类型变量可以通过类型转换符const_cast将const类型转换为非const类型
  * 对于函数值传递的情况，因为参数传递是通过复制实参创建一个临时变量传递进函数的，函数内只能改变临时变量，但无法改变实参。则这个时候无论加不加const对实参不会产生任何影响。但是在引用或指针传递函数调用中，因为传进去的是一个引用或指针，这样函数内部可以改变引用或指针所指向的变量，这时const 才是实实在在地保护了实参所指向的变量。因为在编译阶段编译器对调用函数的选择是根据实参进行的，所以，只有引用传递和指针传递可以用是否加const来重载。一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开来

* 考虑类的情况

  * const成员变量：不能在类定义外部初始化，只能通过构造函数初始化列表进行初始化，并且必须有构造函数；不同类对其const数据成员的值可以不同，所以不能在类中声明时初始化

  * const成员函数（常函数）

    * 不可以改变非mutable（用该关键字声明的变量可以在const成员函数中被修改）数据的值
    * const成员函数可以访问非const对象的非const数据成员、const数据成员，也可以访问const对象内的所有数据成员；
    * 非const成员函数可以访问非const对象的非const数据成员、const数据成员，但不可以访问const对象的任意数据成员；
    * 一个没有明确声明为const的成员函数被看作是将要修改对象中数据成员的函数，而且编译器不允许它为一个const对象所调用。因此const对象只能调用const成员函数。
    * 对于类的成员函数，有时候必须指定其返回值为const类型，以使得其返回值不为“左值”。

#### mutable 关键字

mutable：可变的

首先想到的是在lamba表达式中有这个东西，表示如果是值传递的，可以修改，不加这个mutable属性不能修改，表示传递过来的是常量。虽然在匿名函数内部改变了变量的值，但是在外部还是原来的值

除了lamba表达式中的，就只有类中的了

mutable 在类中只能够修饰非静态数据成员，用来修饰一个 const 示例的部分可变的数据成员的。如下代码：

```c++
struct Test
{
    int a;
    mutable int b;
};

const struct Test test = {1,2};
test.a = 10;  # 编译错误
test.b = 20;  # 允许访问
```

### define

#### 说一下你理解的 ifdef endif代表着什么？

一般情况下，源程序中所有的行都参加编译。但是有时希望对其中一部分内容只在满足一定条件才进行编译，也就是对一部分内容指定编译的条件，这就是“条件编译”。有时，希望当满足某条件时对一组语句进行编译，而当条件不满足时则编译另一组语句。

条件编译命令最常见的形式为：

```c
#ifdef 标识符  
程序段1  
#else  
程序段2  
#endif
```

它的作用是：当标识符已经被定义过(一般是用#define命令定义)，则对程序段1进行编译，否则编译程序段2。 其中#else部分也可以没有，即：

```C
 #ifdef  
程序段1  
#denif
```

 在一个大的软件工程里面，可能会有多个文件同时包含一个头文件，当这些文件编译链接成一个可执行文件上时，就会出现大量“重定义”错误。

在头文件中使用#define、#ifndef、#ifdef、#endif能避免头文件重定义

#### define 与 const 的区别

* const定义的常量是变量带类型，而#define定义的只是个常数不带类型；
* define只在预处理阶段起作用，简单的文本替换，而const在编译、链接过程中起作用；
* define只是简单的字符串替换没有类型检查。而const是有数据类型的，是要进行判断的，可以避免一些低级错误；
* define预处理后，占用代码段空间，const占用数据段空间；
* const不能重定义，而define可以通过#undef取消某个符号的定义，进行重定义；
* define独特功能，比如可以用来防止文件重复引用。

**编译阶段**

* define是在编译的**预处理**阶段起作用，而const是在编译、运行的时候起作用

**安全性**

* define只做替换，不做类型检查和计算，也不求解，容易产生错误，一般最好加上一个大括号包含住全部的内容，要不然很容易出错
* const常量有数据类型，编译器可以对其进行类型安全检查

**内存占用**

* define只是将宏名称进行替换，在内存中会产生多分相同的备份。const在程序运行中只有一份备份，且可以执行常量折叠，能将复杂的的表达式计算出结果放入常量表
* 宏替换发生在编译阶段之前，属于文本插入替换；const作用发生于编译过程中。
* 宏定义的数据没有分配内存空间，只是插入替换掉；const定义的变量只是值不能改变，但要分配内存空间。

#### define 与 typedef 的区别

* 执行时间不同，typedef在编译阶段有效，typedef有类型检查的功能；#define是宏定义，发生在预处理阶段，属于文本插入替换，不进行类型检查；
* 功能差异，typedef用来定义类型的别名，定义与平台无关的数据类型，与struct的结合使用等。#define不只是可以为类型取别名，还可以定义常量、变量、编译开关等，主要用于定义常量及书写复杂的内容。
* 作用域不同，#define没有作用域的限制，只要是之前预定义过的宏，在以后的程序中都可以使用。而typedef有自己的作用域。

* 宏不是语句，不在在最后加分号；typedef是语句，要加分号标识结束。
* 注意对指针的操作，typedef char *p_char和#define p_char char*区别巨大。

#### define 与 inline 的区别

* #define是关键字，inline是函数；
* 宏定义在预处理阶段进行文本替换，inline函数在编译阶段进行替换；
* inline函数有类型检查，相比宏定义比较安全；

区别：

**宏定义不是函数**，但是使用起来像函数。预处理器用复制宏代码的方式代替函数的调用，省去了函数压栈退栈过程，提高了效率；**而内联函数本质上是一个函数**，内联函数一般用于函数体的代码比较简单的函数，不能包含复杂的控制语句，while、switch，并且内联函数本身不能直接调用自身。

**宏函数**是在预编译的时候把所有的宏名用宏体来替换，简单的说就是字符串替换 ；**而内联函数**则是在编译的时候进行代码插入，编译器会在每处调用内联函数的地方直接把内联函数的内容展开，这样可以省去函数的调用的开销，提高效率

**宏定义**是没有类型检查的，无论对还是错都是直接替换；**而内联函数**在编译的时候会进行类型的检查，内联函数满足函数的性质，比如有返回值、参数列表等

**答案解析**

```plaintext
//宏定义示例
#define MAX(a, b) ((a)>(b)?(a):(b))
MAX(a, "Hello"); //错误地比较int和字符串，没有参数类型检查

//内联函数示例
#include <stdio.h>
inline int add(int a, int b) {
    return (a + b);
}
int main(void) {
    int a;
    a = add(1, 2);
    printf("a+b=%d\n", a);
    return 0;
}
//以上a = add(1, 2);处在编译时将被展开为：a = (a + b);
```

**1、使用时的一些注意事项：**

使用宏定义一定要注意错误情况的出现，比如宏定义函数没有类型检查，可能传进来任意类型，从而带来错误，如举例。还有就是括号的使用，宏在定义时要小心处理宏参数，一般用括号括起来，否则容易出现二义性

inline函数一般用于比较小的，频繁调用的函数，这样可以减少函数调用带来的开销。只需要在函数返回类型前加上关键字inline，即可将函数指定为inline函数。

同其它函数不同的是，最好将inline函数定义在头文件，而不仅仅是声明，因为编译器在处理inline函数时，需要在调用点内联展开该函数，所以仅需要函数声明是不够的。

**2、内联函数使用的条件：**

内联是以代码膨胀（复制）为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率 的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。以下情况不宜使用内联：

（1）如果函数体内的代码比较长，使用内联将导致内存消耗代价较高。

（2）如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大。

内联不是什么时候都能展开的，一个好的编译器将会根据函数的定义体，自动地取消不符合要求的内联。

* 在使用时，宏只做简单字符串替换（编译前）。而内联函数可以进行参数类型检查（编译时），且具有返回值。
* 内联函数在编译时直接将函数代码嵌入到目标代码中，省去函数调用的开销来提高执行效率，并且进行参数类型检查，具有返回值，可以实现重载。
* 宏定义时要注意书写（参数要括起来）否则容易出现歧义，内联函数不会产生歧义
* 内联函数有类型检测、语法判断等功能，而宏没有

**内联函数适用场景:**

* 使用宏定义的地方都可以使用 inline 函数。
* 作为类成员接口函数来读写类的私有成员或者保护成员，会提高效率。

首先分析一下C宏定义的好处：首先C语言是一个效率很高的语言，使用预处理器实现，没有参数压栈，函数返回等操作，效率很高。

1. 相当于把内联函数里面的代码写在调用内联函数处。不用执行进入函数的步骤，直接执行函数体。

2. 从上面那一条的角度说，内联函数更像是宏，但却比宏多了类型检查，真正具有函数特性。

3. 在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数。

4. 编译器会为所用 inline 函数中的局部变量分配内存空间

5. 会将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中；

* 优点
  * 内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。
  * 内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会。
  * 内联函数在运行时可调试，而宏定义不可以。
  * 可以说inline函数不仅吸收了了C宏定义的，同时消除宏定义的缺点。
* 缺点
  * 代码膨胀。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。
  * inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译。

* 虚函数（virtual）可以是内联函数（inline）吗？
  * 首先要明白，内联函数是编译器做出的选择，是否内联决定权在编译器，程序员不可控。同时，虚函数是多态性的一种体现，多态性表现在函数的运行阶段而不是函数的编译阶段。因此，**虚函数表现为多态性时（运行期）不可以内联。**
  * 唯一可以内联的时候是：编译器知道所调用的对象是哪个类。**只有在编译器具有实际对象而不是对象的指针或引用时才会发生。**

#### define 与 函数 的区别

* 宏在编译时完成替换，之后被替换的文本参与编译，相当于直接插入了代码，运行时不存在函数调用，执行起来更快；函数调用在运行时需要跳转到具体调用函数。
* 宏定义属于在结构中插入代码，没有返回值；函数调用具有返回值。
* 宏定义参数没有类型，不进行类型检查；函数参数具有类型，需要检查类型。
* 宏定义不要在最后加分号。

#### 谈谈 assert()

断言，是宏，而非函数。assert 宏的原型定义在 `<assert.h>`（C）、`<cassert>`（C++）中，其作用是如果它的条件返回错误，则终止程序执行。可以通过定义 `NDEBUG` 来关闭 assert，但是需要在源代码的开头，`include <assert.h>` 之前。
**assert() 使用**

```c++
#define NDEBUG          // 加上这行，则 assert 不可用
#include <assert.h>

assert( p != NULL );    // assert 不可用
```

#### 用#define声明一个常数，表明1年中有多少秒（忽略闰年问题）？

答案：#define SECONDS_PER_YEAR (60 *60* 24 * 365)UL

要点：

* 没有以分号结束;
* 懂得预处理器将为你计算常数表达式的值。即60 *60* 24 * 365而不是31536000.
* 考虑到了16位机将会溢出，巧妙运用了UL。
 //U和L是 整数文字量的后缀修饰，用于显示指明整数文字量的类型为unsigned int(U)和long int（L）

#### 宏实现比较大小，以及两个数中的最小值?

```c
#include <iostream>
#define MAX(X, Y) ((X)>(Y)?(X):(Y))
#define MIN(X, Y) ((X)<(Y)?(X):(Y))
using namespace std;

int main ()
{
    int var1 = 10, var2 = 100;
    cout << MAX(var1, var2) << endl;
    cout << MIN(var1, var2) << endl;
    return 0;
}
/*
程序运行结果：
100
10
*/
```

* 参数用括号括起来;
* 考察能否合理运用条件运算符;

### inline

#### 内联函数优缺点

优点：

* inline定义的内联函数，函数代码被放入符号表中，在使用时进行替换（像宏一样展开），效率很高
* 类的内联函数也是函数。编绎器在调用一个内联函数，首先会检查参数问题，保证调用正确，像对待
 真正函数一样，消除了隐患及局限性。
* inline可以作为类的成员函数，也可以使用所在类的保护成员及私有成员。

缺点：

* 内联函数以复制为代价，活动产函数开销
* 如果函数的代码较长，使用内联将消耗过多内存
* 如果函数体内有循环，那么执行函数代码时间比调用开销大。

#### 说说内联函数和函数的区别，内联函数的作用

内联函数比普通函数多了关键字**inline**

内联函数避免了函数调用的**开销**；普通函数有调用的开销

普通函数在被调用的时候，需要**寻址（函数入口地址）**；内联函数不需要寻址。

内联函数有一定的限制，内联函数体要求**代码简单**，不能包含复杂的结构控制语句；普通函数没有这个要求。

**内联函数的作用**：内联函数在调用时，是将调用表达式用内联函数体来替换。避免函数调用的开销。

**答案解析**

在使用内联函数时，应注意如下几点：

在内联函数内不允许用循环语句和开关语句。 如果内联函数有这些语句，则编译将该函数视同普通函数那样产生函数调用代码,递归函数是不能被用来做内联函数的。内联函数只适合于只有1～5行的小函数。对一个含有许多语句的大函数，函数调用和返回的开销相对来说微不足道，所以也没有必要用内联函数实现。

内联函数的定义必须出现在内联函数第一次被调用之前。

#### 为什么不能把所有的函数写成内联函数?

内联函数以代码复杂为代价，它以省去函数调用的开销来提高执行效率。所以一方面如果内联函数体内代码执行时间相比函数调用开销较大，则没有太大的意义；另一方面每一处内联函数的调用都要复制代码，消耗更多的内存空间，因此以下情况不宜使用内联函数：

* 函数体内的代码比较长，将导致内存消耗代价
* 函数体内有循环，函数执行时间要比函数调用开销大

### static

#### static 的作用

* 不考虑类的情况
  * 隐藏。所有不加static的全局变量和函数具有全局可见性，可以在其他文件中使用，加了之后只能在该文件所在的编译模块中使用
  * 默认初始化为0，包括未初始化的全局静态变量与局部静态变量，都存在全局未初始化区
  * 静态变量在函数内定义，始终存在，且只进行一次初始化，具有记忆性，其作用范围与局部变量相同，函数退出后仍然存在，但不能使用
* 考虑类的情况
  * static成员变量：只与类关联，不与类的对象关联。定义时要分配空间，不能在类声明中初始化，必须在类定义体外部初始化，初始化时不需要标示为static；可以被非static成员函数任意访问。
  * static成员函数：不具有this指针，无法访问类对象的非static成员变量和非static成员函数；**不能被声明为const、虚函数和volatile**；可以被非static成员函数任意访问

**定义全局静态变量和局部静态变量**：在变量前面加上static关键字。初始化的静态变量会在数据段分配内存，未初始化的静态变量会在BSS段分配内存。直到程序结束，静态变量始终会维持前值。只不过全局静态变量和局部静态变量的作用域不一样；

**定义静态函数**：在函数返回类型前加上static关键字，函数即被定义为静态函数。静态函数只能在**本源文件**中使用；

在变量类型前加上static关键字，变量即被定义为静态变量。**静态变量只能在本源文件中使用**；

1. //示例 static int a; static void func();

在c++中，**static关键字可以用于定义类中的静态成员变量**：使用静态数据成员，它既可以被当成全局变量那样去存储，但又被隐藏在类的内部。类中的static静态数据成员拥有一块单独的存储区，而不管创建了多少个该类的对象。所有这些对象的静态数据成员都**共享**这一块静态存储空间。

在c++中，**static关键字可以用于定义类中的静态成员函数**：与静态成员变量类似，类里面同样可以定义静态成员函数。只需要在函数前加上关键字static即可。如静态成员函数也是类的一部分，而不是对象的一部分。所有这些对象的静态数据成员都**共享**这一块静态存储空间。

static关键字修饰全局变量和局部变量的作用？
全局变量-隐藏变量 局部变量-延长生命周期

1.先来介绍它的第一条也是最重要的一条：隐藏。（static函数，static变量均可）

当同时编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性。

2.static的第二个作用是保持变量内容的持久。（static变量中的记忆功能和全局生存期）存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。共有两种变量存储在静态存储区：全局变量和static变量，只不过和全局变量比起来，static可以控制变量的可见范围，说到底static还是用来隐藏的。

3.static的第三个作用是默认初始化为0（static变量）

其实全局变量也具备这一属性，因为全局变量也存储在静态数据区。在静态数据区，内存中所有的字节默认值都是0x00，某些时候这一特点可以减少程序员的工作量。

4.static的第四个作用：C++中的类成员声明static

\1) 函数体内static变量的作用范围为该函数体，不同于auto变量，该变量的内存只被分配一次，因此其值在下次调用时仍维持上次的值；

\2) 在模块内的static全局变量可以被模块内所有函数访问，但不能被模块外其它函数访问；

\3) 在模块内的static函数只可被这一模块内的其它函数调用，这个函数的使用范围被限制在声明它的模块内；

\4) 在类中的static成员变量属于整个类所拥有，对类的所有对象只有一份拷贝；

\5) 在类中的static成员函数属于整个类所拥有，这个函数不接收this指针，因而只能访问类的static成员变量。

类内：

\6) static类对象必须要在类外进行初始化，static修饰的变量先于对象存在，所以static修饰的变量要在类外初始化；

\7) 由于static修饰的类成员属于类，不属于对象，因此static类成员函数是没有this指针的，this指针是指向本对象的指针。正因为没有this指针，所以static类成员函数不能访问非static的类成员，只能访问 static修饰的类成员；

\8) static成员函数不能被virtual修饰，static成员不属于任何对象或实例，所以加上virtual没有任何实际意义；静态成员函数没有this指针，虚函数的实现是为每一个对象分配一个vptr指针，而vptr是通过this指针调用的，所以不能为virtual；虚函数的调用关系，this->vptr->ctable->virtual function

**答案解析**

当调用一个对象的非静态成员函数时，系统会把该对象的起始地址赋给成员函数的this指针。而静态成员函数不属于任何一个对象，因此C++规定静态成员函数没有this指针（划重点，面试题常考）。既然它没有指向某一对象，也就无法对一个对象中的非静态成员进行访问。

#### 全局变量和 static 变量的区别

1、全局变量（外部变量）的说明之前再冠以static就构成了静态的全局变量。

全局变量本身就是静态存储方式，静态全局变量当然也是静态存储方式。

这两者在存储方式上并无不同。这两者的区别在于非静态全局变量的作用域是整个源程序，当一个源程序由多个原文件组成时，非静态的全局变量在各个源文件中都是有效的。

而静态全局变量则限制了其作用域，即只在定义该变量的源文件内有效，在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其他源文件中引起错误。

static全局变量与普通的全局变量的区别是static全局变量只初始化一次，防止在其他文件单元被引用。

2.static函数与普通函数有什么区别？ static函数与普通的函数作用域不同。尽在本文件中。只在当前源文件中使用的函数应该说明为内部函数（static），内部函数应该在当前源文件中说明和定义。

对于可在当前源文件以外使用的函数应该在一个头文件中说明，要使用这些函数的源文件要包含这个头文件。 static函数与普通函数最主要区别是static函数在内存中只有一份，普通静态函数在每个被调用中维持一份拷贝程序的局部变量存在于（堆栈）中，全局变量存在于（静态区）中，动态申请数据存在于（堆）

#### 谈谈 static 变量初始化时机

静态局部变量和全局变量一样，数据都存放在全局区域，所以在主程序之前，编译器已经为其分配好了内存，在编译阶段分配好了内存之后就进行初始化，在程序运行结束时变量所处的全局内存会被回收。所以在c语言中无法使用变量对静态局部变量进行初始化。

**再说C++和C语言的区别：**

c++主要引入了类这种东西，要进行初始化必须考虑到相应的构造函数和析构函数，而且很多时候构造或者析构函数中会指定我们制定的操作，并非简单的分配内存。因此为了造成不必要的影响（一些我不需要的东西被提前构造出来）所以c++规定全局或者静态对象在首次用到的时候才会初始化。

所以c++整了两种初始化的情况，我理解就是编译初始化和运行初始化。

编译初始化也叫静态初始化。对全局变量和const类型的初始化主要是，叫做zero initialization 和 const initialization，静态初始化在程序加载的过程中完成。从具体实现上看，zero initialization 的变量会被保存在 bss 段，const initialization 的变量则放在 data 段内，程序加载即可完成初始化，这和 c 语言里的全局变量静态变量初始化基本是一致的。其次全局类对象也是在编译器初始化。

动态初始化也叫运行时初始化。主要是指需要经过函数调用才能完成的初始化或者是类的初始化，一般来说是局部静态类对象的初始化和局部静态变量的初始化。

<img src="https://cdn.jsdelivr.net/gh/luogou/cloudimg/data/20190424220313563.png" alt="在这里插入图片描述" style="zoom: 60%; float: left;" />

下面是我自己的实验的一段代码：

```c++
#include<stdio.h>
static int a;
int main()
{
 int b = 5;
 { 
        //g++编译报错
   static int c = b;
        //gcc编译不报错
        static int c;
  printf("c:%d\n",c); 
 }
 return 0;
}
```

如果在c语言中有局部静态变量赋值操作的话会报错：`undefined reference to ' __cxa_guard_acquire'和 '__cxa_guard_release'`。而这两个API接口恰恰是c++中保证局部静态变量运行时初始化的关键，具体参考[c++局部静态变量和线程安全具体实现参考](https://www.cnblogs.com/william-cheung/p/4831085.html)

#### static 线程安全问题

C语言中非局部静态变量一般在main执行之前的静态初始化过程中分配内存并初始化，可以认为是线程安全的；C++11标准针规定了局部静态变量初始化是线程安全的。这里的线程安全并不是说：由于 m 只能被初始化一次，所以只有初始化 m 的线程会阻塞，另外一个就立即跳过初始化过程返回了。这里的线程安全指的是：一个线程在初始化 m 的时候，其他线程执行到 m 的初始化这一行的时候，就会挂起。

具体实现如下：局部静态变量在编译时，编译器的实现是和全局变量类似的，均存储在bss段中。然后编译器会生成一个`guard_for_c`(上述我写的代码中局部静态变量是c) 用来保证线程安全和一次性初始化的整型变量，是编译器生成的，存储在 bss 段。它的最低的一个字节被用作相应静态变量是否已被初始化的标志， 若为 0 表示还未被初始化，否则表示已被初始化(`if ((guard_for_bar & 0xff) == 0)`判断)。 `__cxa_guard_acquire` 实际上是一个加锁的过程， 相应的 `__cxa_guard_abort` 和`__cxa_guard_release` 释放锁。

### 类型转换

#### 隐式转换，如何消除隐式转换？

* C++的基本类型中并非完全的对立，部分数据类型之间是可以进行隐式转换的。所谓隐式转换，是指不需要用户干预，编译器私下进行的类型转换行为。很多时候用户可能都不知道进行了哪些转换
* C++面向对象的多态特性，就是通过父类的类型实现对子类的封装。通过隐式转换，你可以直接将一个子类的对象使用父类的类型进行返回。在比如，数值和布尔类型的转换，整数和浮点数的转换等。某些方面来说，隐式转换给C++程序开发者带来了不小的便捷。C++是一门强类型语言，类型的检查是非常严格的。
* 基本数据类型 基本数据类型的转换以取值范围的作为转换基础（保证精度不丢失）。隐式转换发生在从小->大的转换中。比如从char转换为int。从int->long。自定义对象 子类对象可以隐式的转换为父类对象。
* C++中提供了explicit关键字，在构造函数声明的时候加上explicit关键字，能够禁止隐式转换。
* 如果构造函数只接受一个参数，则它实际上定义了转换为此类类型的隐式转换机制。可以通过将构造函数声明为explicit加以制止隐式类型转换，关键字explicit只对一个实参的构造函数有效，需要多个实参的构造函数不能用于执行隐式转换，所以无需将这些构造函数指定为explicit。

#### 谈谈 static_cast

比 C 语言强制类型转换

* 更加安全；
* 更直接明显，能够一眼看出是什么类型转换为什么类型，容易找出程序中的错误
* 可清楚地辨别代码中每个显式的强制转换
* 可读性更好，能体现程序员的意图

static_cast < type-id > (expression)

该运算符把expression转换为type-id类型，但没有运行时类型检查来保证转换的安全性。它主要有如下几种用法：

用于类层次结构中基类（父类）和派生类（子类）之间指针或引用引用的转换

进行上行转换（把派生类的指针或引用转换成基类表示）是安全的

进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的

用于基本数据类型之间的转换，如把int转换成char，把int转换成enum。这种转换的安全性也要开发人员来保证。

把空指针转换成目标类型的空指针

把任何类型的表达式转换成void类型

注意：static_cast不能转换掉expression的const、volatile、或者__unaligned属性。

#### 谈谈 reinterpret_cast

`reinterpret_cast<type-id> (expression)`

type-id 必须是一个指针、引用、算术类型、函数指针或者成员指针。它可以用于类型之间进行强制转换。

#### 谈谈 const_cast

该运算符用来修改类型的const或volatile属性。除了const 或volatile修饰之外， type_id和expression的类型是一样的。用法如下：

常量指针被转化成非常量的指针，并且仍然指向原来的对象

常量引用被转换成非常量的引用，并且仍然指向原来的对象

const_cast一般用于修改底指针。如const char *p形式

#### 谈谈 dynamic_cast

有类型检查，基类向派生类转换比较安全，但是派生类向基类转换则不太安全

dynamic_cast (expression)

该运算符把expression转换成type-id类型的对象。type-id 必须是类的指针、类的引用或者void*

如果 type-id 是类指针类型，那么expression也必须是一个指针，如果 type-id 是一个引用，那么 expression 也必须是一个引用

dynamic_cast运算符可以在执行期决定真正的类型，也就是说expression必须是多态类型。如果下行转换是安全的（也就说，如果基类指针或者引用确实指向一个派生类对象）这个运算符会传回适当转型过的指针。如果 如果下行转换不安全，这个运算符会传回空指针（也就是说，基类指针或者引用没有指向一个派生类对象）

dynamic_cast主要用于类层次间的上行转换和下行转换，还可以用于类之间的交叉转换

在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的

在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全

举个例子：

```c++
#include <bits/stdc++.h>
using namespace std;

class Base
{
public:
    Base() :b(1) {}
    virtual void fun() {};
    int b;
};

class Son : public Base
{
public:
    Son() :d(2) {}
    int d;
};

int main()
{
    int n = 97;

    //reinterpret_cast
    int *p = &n;
    //以下两者效果相同
    char *c = reinterpret_cast<char*> (p); 
    char *c2 =  (char*)(p);
    cout << "reinterpret_cast输出："<< *c2 << endl;
    //const_cast
    const int *p2 = &n;
    int *p3 = const_cast<int*>(p2);
    *p3 = 100;
    cout << "const_cast输出：" << *p3 << endl;

    Base* b1 = new Son;
    Base* b2 = new Base;

    //static_cast
    Son* s1 = static_cast<Son*>(b1); //同类型转换
    Son* s2 = static_cast<Son*>(b2); //下行转换，不安全
    cout << "static_cast输出："<< endl;
    cout << s1->d << endl;
    cout << s2->d << endl; //下行转换，原先父对象没有d成员，输出垃圾值

    //dynamic_cast
    Son* s3 = dynamic_cast<Son*>(b1); //同类型转换
    Son* s4 = dynamic_cast<Son*>(b2); //下行转换，安全
    cout << "dynamic_cast输出：" << endl;
    cout << s3->d << endl;
    if(s4 == nullptr)
        cout << "s4指针为nullptr" << endl;
    else
        cout << s4->d << endl;


    return 0;
}
//输出结果
//reinterpret_cast输出：a
//const_cast输出：100
//static_cast输出：
//2
//-33686019
//dynamic_cast输出：
//2
//s4指针为nullptr
```

从输出结果可以看出，在进行下行转换时，dynamic_cast安全的，如果下行转换不安全的话其会返回空指针，这样在进行操作的时候可以预先判断。而使用static_cast下行转换存在不安全的情况也可以转换成功，但是直接使用转换后的对象进行操作容易造成错误。

#### 继承机制中对象之间如何转换？指针和引用之间如何转换？

 向上类型转换

将派生类指针或引用转换为基类的指针或引用被称为向上类型转换，向上类型转换会自动进行，而且向上类型转换是安全的。

**向下类型转换**

将基类指针或引用转换为派生类指针或引用被称为向下类型转换，向下类型转换不会自动进行，因为一个基类对应几个派生类，所以向下类型转换时不知道对应哪个派生类，所以在向下类型转换时必须加动态类型识别技术。RTTI技术，用dynamic_cast进行向下类型转换。

#### 谈谈 RTTI 机制

**概念：**

RTTI(Run Time Type Identification)即通过运行时类型识别，C++引入这个机制是为了让程序在运行时能根据基类的指针或引用来获得该指针或引用所指的对象的实际类型。但是现在RTTI的类型识别已经不限于此了，它还能通过typeid操作符识别出所有的基本类型（int，指针等）的变量对应的类型。

和很多其他语言一样，C++是一种静态类型语言。其数据类型是在编译期就确定的，不能在运行时更改。然而由于面向对象程序设计中多态性的要求，C++中的指针或引用(Reference)本身的类型，可能与它实际代表(指向或引用)的类型并不一致。有时我们需要将一个多态指针转换为其实际指向对象的类型，就需要知道运行时的类型信息，这就产生了运行时类型识别的要求。C++要想获得运行时类型信息，只能通过RTTI机制，并且C++最终生成的代码是直接与机器相关的。

**如何实现：**

C++通过以下的两个操作提供RTTI：

（1）typeid运算符，该运算符返回其表达式或类型名的实际类型。返回指针和引用所指的实际类型；

（2）dynamic_cast运算符，该运算符将基类的指针或引用安全地转换为派生类类型的指针或引用。

我们知道C++的多态性（运行时）是由虚函数实现的，对于多态性的对象，无法在程序编译阶段确定对象的类型。当类中含有虚函数时，其基类的指针就可以指向任何派生类的对象，这时就有可能不知道基类指针到底指向的是哪个对象的情况，类型的确定要在运行时利用运行时类型标识做出。为了获得一个对象的类型可以使用typeid函数，该函数反回一个对type_info类对象的引用，要使用typeid必须使用头文件`<typeinfo>`，因为typeid是一个返回类型为typ_info的引用的函数

### 字符串

#### strcpy、strncpy、sprintf、memcopy 函数的区别？

strcpy 和 memcopy

1、复制的内容不同。strcpy只能复制字符串，而memcpy可以复制任意内容，例如字符数组、整型、结构体、类等。

2、复制的方法不同。strcpy不需要指定长度，它遇到被复制字符的串结束符"\0"才结束，所以容易溢出。memcpy则是根据其第3个参数决定复制的长度。

 3、用途不同。通常在复制字符串时用strcpy，而需要复制其他类型数据时则一般用memcpy

.strcpy strncpy 的区别（当长度大于n 时， 只会截取前n个，不会加\0, 要是少于n个的话会用\0补充）

\1) 函数原型

```plaintext
char* strcpy(char* strDest, const char* strSrc)
char* strncpy(char* strDest, const char* strSrc, int pos)
```

\2) strcpy函数: 如果参数 dest 所指的内存空间不够大，可能会造成缓冲溢出(buffer Overflow)的错误情况，在编写程序时请特别留意，或者用strncpy()来取代。 strncpy函数：用来复制源字符串的前n个字符，src 和 dest 所指的内存区域不能重叠，且 dest 必须有足够的空间放置n个字符。

\3) 如果目标长>指定长>源长，则将源长全部拷贝到目标长，自动加上’\0’ 如果指定长<源长，则将源长中按指定长度拷贝到目标字符串，不包括’\0’ 如果指定长>目标长，运行时错误 ；

\1) 操作对象不同

① strcpy的两个操作对象均为字符串

② sprintf的操作源对象可以是多种数据类型，目的操作对象是字符串

③ memcpy的两个对象就是两个任意可操作的内存地址，并不限于何种数据类型。

\2) 执行效率不同

memcpy最高，strcpy次之，sprintf的效率最低。

\3) 实现功能不同

① strcpy主要实现字符串变量间的拷贝

② sprintf主要实现其他数据类型格式到字符串的转化

③ memcpy主要是内存块间的拷贝。

#### string和char*的区别

string继承自basic_string,其实是对char*进行了封装，封装的string包含了char*数组，容量，长度等等属性。

string可以进行动态扩展，在每次扩展的时候另外申请一块原空间大小两倍的空间（2^n），然后将原字符串拷贝过去，并加上新增的内容。

#### strlen和sizeof区别？

* sizeof是运算符，并不是函数，结果在编译时得到而非运行中获得；strlen是字符处理的库函数。

* sizeof参数可以是任何数据的类型或者数据（sizeof参数不退化）；strlen的参数只能是字符指针且结尾是'\0'的字符串。

* 因为sizeof值在编译时确定，所以不能用来得到动态分配（运行时分配）存储空间的大小

```c
  int main(int argc, char const *argv[]){

      const char* str = "name";

      sizeof(str); // 取的是指针str的长度，是8
      strlen(str); // 取的是这个字符串的长度，不包含结尾的 \0。大小是4
      return 0;
  }
```

#### string 和 `vector<char>`

#### 你知道const char* 与string之间的关系是什么吗？

\1) string 是c++标准库里面其中一个，封装了对字符串的操作，实际操作过程我们可以用const char*给string类初始化

\2) 三者的转化关系如下所示：

```plaintext
a)  string转const char* 

string s = “abc”; 

const char* c_s = s.c_str(); 

b)  const char* 转string，直接赋值即可 

const char* c_s = “abc”; 
 string s(c_s); 

c)  string 转char* 
 string s = “abc”; 
 char* c; 
 const int len = s.length(); 
 c = new char[len+1]; 
 strcpy(c,s.c_str()); 

d)  char* 转string 
 char* c = “abc”; 
 string s(c); 

e)  const char* 转char* 
 const char* cpc = “abc”; 
 char* pc = new char[strlen(cpc)+1]; 
 strcpy(pc,cpc);

f)  char* 转const char*，直接赋值即可 
 char* pc = “abc”; 
 const char* cpc = pc;
```

#### printf 和 cout 区别

cout<<是一个函数，cout<<后可以跟不同的类型是因为cout<<已存在针对各种类型数据的重载，所以会自动识别数据的类型。输出过程会首先将输出字符放入缓冲区，然后输出到屏幕。

cout是有缓冲输出:

```plaintext
 cout < < "abc " < <endl; 
或cout < < "abc\n ";cout < <flush; 这两个才是一样的.
```

flush立即强迫缓冲输出。 printf是无缓冲输出。有输出时立即输出

#### 谈谈 std::string

* sizeof()一个空string的大小是8字节。

 首先我们要知道在c++中sizeof 的大小是由非静态成员变量决定，静态成员变量和成员函数不算在内。

 因为源码`basic_string.h`中data member如下：

 ```c++
  // Data Members (private):
  mutable _Alloc_hider _M_dataplus;
 
 struct _Alloc_hider : _Alloc
 {
     _Alloc_hider(_CharT* __dat, const _Alloc& __a): _Alloc(__a), _M_p(__dat) { }
     _CharT* _M_p; // The actual data.
 };
 ```

 _M_p是指向实际数据的指针，当调用string::data()或者string::c_str()时返回的也是该值。因此sizeof(string)的大小为8，等于该指针的大小

 关于mutable关键字，下面有讲解

* copy-on-write机制

 大多数的string对象拷贝都是用于只读，每次都拷贝内存是没有必要的，而且也很消耗性能，这就有了写时复制机制，也就是把内存复制延迟到写操作时，请看如下代码：

 ```c++
 string s = "Fuck the code.";
 string s1 = s; // 读操作，不实际拷贝内存 
 cout << s1 << endl; // 读操作，不实际拷贝内存 
 s1 += "I want it."; // 写操作，拷贝内存 
 ```

 一些不经意操作可能导致意外的内存拷贝。比如下面代码：

 ```c++
 string s1("test for copy");
 string s2(s1);
 cout << s2 << endl; // shared
 cout << s2[1] << endl; // leaked，此处会重新申请并拷贝内存
 ```

 operator[]有两个重载版本，const和非const版本，当调用非const版本的operator[]时，会造成内存拷贝。那么什么时候会调用const版本，什么时候会调用非const版本？调用哪个版本取决于string对象是否是const，所以好的编程习惯应该是“在const的场景下使用const”。

 gcc5 已经放弃了copy-on-write的设计，采用短字符串优化的方案，即对长度小于16的字符串，作为string对象的一部分，直接从栈空间开辟内存，而且c++11中std::move的引入也使这种copy-on-write的优化不再必要。

* 短字符串优化

 c++11之前是写时复制，之后是实时拷贝+短字符串优化。如下：

 首先gcc中的basic_string有4个数据成员：

  * _M_dataplus
  * _M_string_length
  * _S_local_capacity （不占空间，估计编译时直接把所有_S_local_capacity替换为了15）
  * 匿名union

 ```c++
 // Use empty-base optimization: http://www.cantrip.org/emptyopt.html
 struct _Alloc_hider : allocator_type // TODO check __is_final
 {
 _Alloc_hider(pointer __dat, const _Alloc& __a = _Alloc())
 : allocator_type(__a), _M_p(__dat) { }
 pointer _M_p; // The actual data.
 };
 _Alloc_hider      _M_dataplus;
 size_type         _M_string_length;
 enum { _S_local_capacity = 15 / sizeof(_CharT) };
 union
 {
 _CharT           _M_local_buf[_S_local_capacity + 1]; //之所以是15 + 1，
 //是因为字符串要是null terminated的
 size_type        _M_allocated_capacity;
 }
 ```

 当string长度小于等于 `_S_local_capacity(15)`时，使用`_M_local_buf`，字符串存储在栈上，alloctor就不必进行一次内存分配,从而减少一次系统调用,减少一次用户态向内核态的转换,这就是短字符串优化。 当string长度大于是，在堆上分配。`_M_allocated_capacity` 这个参数,其含义就是容量,也就是分配的内存大小,很巧妙的设计,当使用静态内存的时候,容量为15,不用计算,当大于15的时候静态数组便没有用了,正好用来记录容量,至于如何区分使用的内存是静态的还是由alloctor分配的,就是我们的_M_dataplus要做的事了,其中有一个指针,指向数据,我们只需要在进行短字符串优化时把指针指向静态数组即可

* std::string的缺点

 不支持split、find、join等方法

 没有format，转成sprintf等等

 std::string算上重载有130+的成员函数

* c++string是一个类，是basic_string类的别名

 能被继承，但最好不要

<https://stackoverflow.com/questions/6006860/why-should-one-not-derive-from-c-std-string-class>
