# 语法

## 问题

### 变量

* 定义和声明的区别
* 初始化和赋值的区别
* 全局变量与局部变量区别
* 形参与实参区别
* 说说静态局部变量，全局变量，局部变量的特点，以及使用场景
* 两个相互依赖的全局变量怎么初始化

### struct

* C++ 中struct的拷贝？
* 说说 C++中 struct 和 class 的区别，和 C struct 的区别
* struct 和 union 的区别？
* 结构体变量比较是否相等

### 引用、指针

* 说说数组和指针的区别？

* 说说C++中函数指针和指针函数的区别，函数指针应用场景？

* 简述C++有几种传值方式，之间的区别是什么？

* 说说使用指针需要注意什么，谈谈野指针、空悬指针？

* 指针与引用的区别？

* C++中NULL和nullptr区别？

* 一个指针占多少字节？

* char a,char a[],`char *a`,``char*[]``,`char **a` 之间的区别

* 谈谈 sizeof

    

### const

* 简述常量指针和指针常量区别
* 顶层 const 和 底层 const
* const 的作用
* mutable 关键字



### define

* 说一下你理解的 ifdef endif代表着什么？

* define 与 const 的区别

* define 与 typedef 的区别

* define 与 inline 的区别

* define 与 函数 的区别

* 谈谈 assert()

* 用#define声明一个常数，表明1年中有多少秒（忽略闰年问题）？

* 宏实现比较大小，以及两个数中的最小值

### inline

* 内联函数概念

* 内联函数优缺点

### static

* static 的作用
* 全局遍历和 static 变量的区别
* 谈谈 static 变量初始化时机
* static 线程安全问题

### 类型转换

* 隐式转换，如何消除隐式转换？

* 谈谈 static_cast

* 谈谈 reinterpret_cast

* 谈谈 const_cast

* 谈谈 dynamic_cast

* 继承机制中对象之间如何转换？指针和引用之间如何转换？

* 谈谈 RTTI 机制

### 字符串

* strcpy函数和strncpy函数的区别？哪个函数更安全？
* string和char*的区别
* string 和 `vector<char>`
* 知道const char* 与string之间的关系是什么吗？
* printf 和 cout 区别
* 谈谈 std::string

## 回答

### 变量

#### 定义和声明的区别

**如果是指变量的声明和定义：** 从编译原理上来说，声明是仅仅告诉编译器，有个某类型的变量会被使用，但是编译器并不会为它分配任何内存。而定义就是分配了内存。

**如果是指函数的声明和定义：** 声明：一般在头文件里，对编译器说：这里我有一个函数叫function() 让编译器知道这个函数的存在。 定义：一般在源文件里，具体就是函数的实现过程 写明函数体。

* 声明仅仅是把变量的声明的位置及类型提供给编译器，并不分配内存空间；定义要在定义的地方为其分配存储空间。
* 相同变量可以在多处声明（外部变量extern），但只能在一处定义。

#### 初始化和赋值的区别

* 对于简单类型来说，初始化和赋值没什么区别
* 对于类和复杂数据类型来说，初始化调用拷贝构造函数，赋值调用重载的赋值操作符函数

#### 全局变量与局部变量区别

生命周期不同：全局变量随主程序创建和创建，随主程序销毁而销毁；局部变量在局部函数内部，甚至局部循环体等内部存在，退出就不存在；

使用方式不同：通过声明后全局变量在程序的各个部分都可以用到；局部变量分配在堆栈区，只能在局部使用。

操作系统和编译器通过内存分配的位置可以区分两者，全局变量分配在全局数据段并且在程序开始运行的时候被加载。局部变量则分配在堆栈里面 。

#### 形参与实参区别

* 形参变量只有在被调用时才分配内存单元，在调用结束时， 即刻释放所分配的内存单元。因此，形参只有在函数内部有效。 函数调用结束返回主调函数后则不能再使用该形参变量。
* 实参可以是常量、变量、表达式、函数等， 无论实参是何种类型的量，在进行函数调用时，它们都必须具有确定的值， 以便把这些值传送给形参。 因此应预先用赋值，输入等办法使实参获得确定值，会产生一个临时变量。
* 实参和形参在数量上，类型上，顺序上应严格一致， 否则会发生“类型不匹配”的错误。
* 函数调用中发生的数据传送是单向的。 即只能把实参的值传送给形参，而不能把形参的值反向地传送给实参。 因此在函数调用过程中，形参的值发生改变，而实参中的值不会变化。
* 当形参和实参不是指针类型时，在该函数运行时，形参和实参是不同的变量，他们在内存中位于不同的位置，形参将实参的内容复制一份，在该函数运行结束的时候形参被释放，而实参内容不会改变。

#### **说说静态局部变量，全局变量，局部变量的特点，以及使用场景**

**首先从作用域考虑**：C++里作用域可分为6种：全局，局部，类，语句，命名空间和文件作用域。

* 全局变量：全局作用域，可以通过extern作用于其他非定义的源文件。
* 静态全局变量 ：全局作用域+文件作用域，所以无法在其他文件中使用。
* 局部变量：局部作用域，比如函数的参数，函数内的局部变量等等。
* 静态局部变量 ：局部作用域，只被初始化一次，直到程序结束。

**从所在空间考虑**：除了局部变量在栈上外，其他都在静态存储区。因为静态变量都在静态存储区，所以下次调用函数的时候还是能取到原来的值。

**生命周期**： 局部变量在栈上，出了作用域就回收内存；而全局变量、静态全局变量、静态局部变量都在静态存储区，直到程序结束才会回收内存。

**使用场景**：从它们各自特点就可以看出各自的应用场景，不再赘述。

#### 两个相互依赖的全局变量怎么初始化

### struct

#### 说说 C++中 struct 和 class 的区别，和 C struct 的区别

* struct 中默认的访问控制权限是 public 的，而 class 中默认的访问控制权限是 private 的
* 在继承关系中，struct 默认是公有继承，而 class 是私有继承；
* class 关键字可以用于定义模板参数，就像 typename，而 struct 不能用于定义模板参数，



C++ 中的 struct 是对 C 中的 struct 进行了扩充，它们在声明时的区别如下：

|          | **C**                  | **C++**                  |
| -------- | ---------------------- | ------------------------ |
| 成员函数 | 不能有                 | 可以                     |
| 静态成员 | 不能有                 | 可以                     |
| 访问控制 | 默认public，不能修改   | public/private/protected |
| 继承关系 | 不可以继承             | 可从类或者其他结构体继承 |
| 初始化   | 不能直接初始化数据成员 | 可以                     |

使用时的区别：C 中使用结构体需要加上 struct 关键字，或者对结构体使用 typedef 取别名，而 C++ 中可以省略 struct 关键字直接使用

```c++
struct Student{  
 int  iAgeNum;  
 string strName; 
} 
typedef struct Student Student2; //C中取别名  
struct Student stu1; // C 中正常使用 
Student2 stu2;   // C 中通过取别名的使用 
Student stu3;   // C++ 中使用
```

#### struct 和 union 的区别？

结构体struct：把不同类型的数据组合成一个整体。struct里每个成员都有自己独立的地址。sizeof(struct)是内存对齐后所有成员长度的加和。（引申出[内存对齐](#说一说内存对齐)的问题）

共同体union：各成员共享一段内存空间, 一个union变量的长度等于各成员中最长的长度，以达到节省空间的目的。所谓的共享不是指把多个成员同时装入一个union变量内, 而是指该union变量可被赋予任一成员值,但每次只能赋一种值, 赋入新值则冲去旧值。 sizeof(union)是最长的数据成员的长度。



### 引用、指针

#### 说说数组和指针的区别？

（1）数组：数组是用于储存多个相同类型数据的集合。 数组名是首元素的地址。

（2）指针：指针相当于一个变量，但是它和不同变量不一样，它存放的是其它变量在内存中的地址。 指针名指向了内存的首地址。



区别

* 赋值：同类型指针变量可以相互赋值；数组不行，只能一个一个元素的赋值或拷贝

* 存储方式：

    * 数组：数组在内存中是连续存放的，开辟一块连续的内存空间。数组是根据数组的下进行访问的，数组的存储空间，不是在静态区就是在栈上。
    * 指针：指针很灵活，它可以指向任意类型的数据。指针的类型说明了它所指向地址空间的内存。由于指针本身就是一个变量，再加上它所存放的也是变量，所以指针的存储空间不能确定。

* 求sizeof：

    * 数组在内存中是连续存放的，开辟一块连续的内存空间；数组所占存储空间：sizeof（数组名）；数组大小：sizeof(数组名)/sizeof(数组元素数据类型)；

    * 用运算符sizeof 可以计算出数组的容量（字节数）。sizeof(p),p 为指针得到的是一个指针变量的字节数，而不是p 所指的内存容量。


* 在使用下标的时候，两者的用法相同，都是原地址加上下标值，不过数组的原地址就是数组首元素的地址是固定的，指针的原地址就不是固定的。

    * **a 是数组名，是数组首元素地址，a +1表示地址值加上一个元素类型的大小**
    * 数组名不是真正意义上的指针，可以理解为常指针，所以数组名没有自增、自减等操作。
    * 当数组名当做形参传递给调用函数后，就失去了原有特性，退化成一般指针，多了自增、自减操作，但sizeof运算符不能再得到原数组的大小了。

    



#### 说说C++中函数指针和指针函数的区别，函数指针的应用场景

**定义不同** 指针函数本质是一个函数，其返回值为指针。 函数指针本质是一个指针，其指向一个函数。

**写法不同**

```c++
指针函数：int *fun(int x,int y);
函数指针：int (*fun)(int x,int y);
```



函数指针的**应用场景**：**回调**（callback）

我们调用别人提供的 API函数(Application Programming Interface,应用程序编程接口)，称为Call；如果别人的库里面调用我们的函数，就叫Callback。

回调函数的作用

* 当发生某种事件时，系统或其他函数将会自动调用你定义的一段函数；
* 回调函数就相当于一个中断处理函数，由系统在符合你设定的条件时自动调用。为此，你需要做三件事：1，声明；2，定义；3，设置触发条件，就是在你的函数中把你的回调函数名称转化为地址作为一个参数，以便于系统调用；
* 回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用为调用它所指向的函数时，我们就说这是回调函数；
* 因为可以把调用者与被调用者分开。调用者不关心谁是被调用者，所有它需知道的，只是存在一个具有某种特定原型、某些限制条件（如返回值为int）的被调用函数。

```c++
//以库函数qsort排序函数为例，它的原型如下：
void qsort(void *base,//void*类型，代表原始数组
           size_t nmemb, //第二个是size_t类型，代表数据数量
           size_t size, //第三个是size_t类型，代表单个数据占用空间大小
           int(*compar)(const void *,const void *)//第四个参数是函数指针
          );
//第四个参数告诉qsort，应该使用哪个函数来比较元素，即只要我们告诉qsort比较大小的规则，它就可以帮我们对任意数据类型的数组进行排序。在库函数qsort调用我们自定义的比较函数，这就是回调的应用。

//示例
int num[100];
int cmp_int(const void* _a , const void* _b){//参数格式固定
    int* a = (int*)_a;    //强制类型转换
    int* b = (int*)_b;
    return *a - *b;　　
}
qsort(num,100,sizeof(num[0]),cmp_int); //回调
```



#### 简述C++有几种传值方式，之间的区别是什么？

* 值传递：形参即使在函数体内值发生变化，也不会影响实参的值；
* 引用传递：形参在函数体内值发生变化，会影响实参的值；
* 指针传递：在指针指向没有发生改变的前提下，形参在函数体内值发生变化，会影响实参的值；



* 需要返回函数内局部变量的内存的时候用指针。使用指针传参需要开辟内存，用完要记得释放指针，不然会内存泄漏。而返回局部变量的引用是没有意义的

* 对栈空间大小比较敏感（比如递归）的时候使用引用。使用引用传递不需要创建临时变量，开销要更小

* 类对象作为参数传递的时候使用引用，这是C++类对象传递的标准方式

* 值传递用于对象时，整个对象会拷贝一个副本，这样效率低；而引用传递用于对象时，不发生拷贝行为，只是绑定对象，更高效；指针传递同理，但不如引用传递安全。

    

#### 说说使用指针需要注意什么，谈谈野指针、空悬指针？

* 初始化：NULL、赋初值
* free 或 delete 后注意置为 NULL 

* 避免数组或指针下标越界
* 动态内存申请释放配对，防止内存泄漏



* 悬空指针：指向已删除（或释放）的内存位置的指针称为悬空指针。free 后忘记置为 NULL
* 无效指针：是一种特定的指针类型  void * 指向存储中某个数据位置的指针，它没有任何特定的类型。
    * void指针不能被取消引用。但是，可以使用类型转换void指针来完成
    * 由于缺少具体的值和大小，因此无法对void指针进行指针算术运算。（要类型转换）
* 空指针：NULL指针是没有指向任何内容的指针。如果没有将地址分配给指针的情况，则可以简单地使用NULL。
* 野指针：尚未初始化为任何值（甚至不是NULL）的指针称为野指针。可以将指针初始化为一个非NULL垃圾值，该值可能不是有效地址。



#### 指针与引用的区别？

* 指针是一个变量，存储的是一个地址，引用跟原来的变量实质上是同一个东西，是原变量的别名
* 指针可以有多级，引用只有一级
* 指针可以为空，引用不能为NULL且在定义时必须初始化，不存在指向空值的引用，必须有具体实体
* 指针在初始化后可以改变指向，而引用在初始化之后不可再改变
* sizeof指针得到的是本指针的大小，sizeof引用得到的是引用所指向变量的大小
* 当把指针作为参数进行传递时，也是将实参的一个拷贝传递给形参，两者指向的地址相同，但不是同一个变量，在函数中改变这个变量的指向不影响实参，而引用却可以。
* 引用本质是一个指针



#### C++ 中 NULL 和 nullptr 区别？

* 在C语言中，NULL被定义为(void\*)0, 而在C++语言中，NULL 则被定义为整数0

* 在C++中指针必须有明确的类型定义。但是将 NULL 定义为 0 带来的另一个问题是无法与整数的0区分，因为C++中允许有函数重载，会把 NULL 当作 0 来传递，容易产生二义性

* nullptr在C++11被引入用于解决这一问题，nullptr可以明确区分整型和指针类型，能够根据环境自动转换成相应的指针类型，但不会被转换为任何整型，所以不会造成参数传递错误。

    

#### 一个指针占多少字节？

* 32 位编译环境，4 字节
* 64 位编译环境，8 字节
* 一个指针占内存大小跟编译环境有关，与机器的位数无关



#### char a,char a[],char *a,char*[],char **a 之间的区别

1. char a  定义了一个存储空间，存储的是char类型的变量

2. char a[] 是一个字符数组，数组中的每一个元素是一个char类型的数据

3. char *a

 > **字符串的本质（在计算机眼中）是其第一个字符的地址，c和c++中操作字符串是通过内存中其存储的首地址来完成的**
 >
 > 对于char a[]来说a代表的是数组的首地址，那么对char *a来说a代表的也是字符串的首地址
 >
 > 因此char a[]和char *a可以放到一块看，这两个没有本质区别。
 >
 > 但是要注意对于char s[]和char* a我们可以有`s=a`，但不能有`a=s`，因为创建数组的时候s的地址不为空已经确定，但是a是一个空指针，不能将非空的地址指向空指针

4. char *a[]

 >  `*` 的优先级是低于[]的，因此要先看`a[]`再看  `*`
 >
 > 因此这是一个char* 数组，数组中的每一个元素都是指针，这些指针指向char类型
 >
 > `char *a[ ] = {"China","French","America","German"}`

5. char **a

 > 两个**代表相同的优先级，因此从右往左看，即`char*(*a)`
 >
 > char * a 不就是一个字符串数组，a代表首地址。那么char* ( * a)就是和char*a[]一样的数据结构



#### 谈谈 sizeof

* 数组——编译时分配的数组空间大小；
* 指针——存储该指针所用的空间大小（存储该指针的地址的长度，是长整型，应该为4）；
* 类型——该类型所占的空间大小；
    * 定义一个不包含任何成员变量和成员函数的空的类，对该类型sizeof。结果为 1，因为声明该类实例的时候必须在内存中占一定空间才能使用，具体占用多少看编译器
    * 如果在空类里面添加一个构造函数和析构函数，sizeof是多少？还是一样的。因为调用构造函数和析构函数或者其他函数只需要知道函数的地址就行，函数的地址和类的实例无关。
    * 如果把析构函数或者其他函数变成虚函数呢？如果类中有虚函数，会生成虚函数表，并且每个对象都会在头部添加一个指向虚函数表的指针。所以sizeof就是指针的大小
* 对象——对象的实际占用空间大小；
* 函数——函数的返回类型所占的空间大小。函数的返回类型不能是void。





### const

#### 简述常量指针和指针常量，顶层 const 和底层 const

```c
//const* 是常量指针，*const 是指针常量
int const *a;    //a指针所指向的内存里的值不变，即（*a）不变
int *const a;    //a指针所指向的内存地址不变，即a不变
const int a;     //指的是a是一个常量，不允许修改。
const int *a;    //a指针所指向的内存里的值不变，即（*a）不变
const int *const a;   //都不变，即（*a）不变，a也不变
```

* const * 是常量指针
    * 指针指向的内存的值不变
    * 底层 const：指的是const修饰的变量**所指向的对象**是一个常量，指的是所指变量，就是 * 号的左边
* *const 是指针常量
    * 指针本身不变
    * 顶层 const：指的是const修饰的变量**本身**是一个常量，无法修改，指的是指针，就是 * 号的右边



#### const 的作用

* 不考虑类的情况

  * const 常量在定义时必须初始化，之后无法更改
  * const 修饰形参
      * const 形参可以接收const和非const类型的实参
      * 对于值传递没啥用，反正也是拷贝的
      * 指针和引用传递可以起到保护作用
      * 一个拥有顶层 const 的形参无法和另一个没有顶层 const 的形参区分开来（底层const可以）

* 考虑类的情况

  * const成员变量：不能在类定义外部初始化，只能通过构造函数初始化列表进行初始化，并且必须有构造函数；不同类对其const数据成员的值可以不同，所以不能在类中声明时初始化

  * const成员函数（常函数）

    * 不可以改变非mutable（用该关键字声明的变量可以在const成员函数中被修改）数据的值
    * const成员函数可以访问非const对象的非const数据成员、const数据成员，也可以访问const对象内的所有数据成员；
    * 非const成员函数可以访问非const对象的非const数据成员、const数据成员，但不可以访问const对象的任意数据成员；
    * 一个没有明确声明为const的成员函数被看作是将要修改对象中数据成员的函数，而且编译器不允许它为一个const对象所调用。因此const对象只能调用const成员函数。
    * 对于类的成员函数，有时候必须指定其返回值为const类型，以使得其返回值不为“左值”。

#### mutable 关键字

mutable：可变的

首先想到的是在lamba表达式中有这个东西，表示如果是值传递的，可以修改，不加这个mutable属性不能修改，表示传递过来的是常量。虽然在匿名函数内部改变了变量的值，但是在外部还是原来的值

除了lamba表达式中的，就只有类中的了

mutable 在类中只能够修饰非静态数据成员，用来修饰一个 const 示例的部分可变的数据成员的。如下代码：

```c++
struct Test
{
    int a;
    mutable int b;
};

const struct Test test = {1,2};
test.a = 10;  # 编译错误
test.b = 20;  # 允许访问
```

### define

#### 说一下你理解的 ifdef endif代表着什么？

* 条件编译

* 可以用来避免头文件重定义

    

#### define 与 const 的区别

* const定义的常量是变量带类型，而#define定义的只是个常数不带类型；
* define只在预处理阶段起作用，简单的文本替换，而const在编译、链接过程中起作用；
* define只是简单的字符串替换没有类型检查。而const是有数据类型的，是要进行判断的，可以避免一些低级错误；
* define预处理后，占用代码段空间，const占用数据段空间；
* const不能重定义，而define可以通过#undef取消某个符号的定义，进行重定义；
* define独特功能，比如可以用来防止文件重复引用。



#### define 与 typedef 的区别

* 执行时间不同，typedef在编译阶段有效，typedef有类型检查的功能；#define是宏定义，发生在预处理阶段，属于文本插入替换，不进行类型检查；
* 功能差异，typedef用来定义类型的别名，定义与平台无关的数据类型，与struct的结合使用等。#define不只是可以为类型取别名，还可以定义常量、变量、编译开关等，主要用于定义常量及书写复杂的内容。
* 作用域不同，#define没有作用域的限制，只要是之前预定义过的宏，在以后的程序中都可以使用。而typedef有自己的作用域。

* 宏不是语句，不在在最后加分号；typedef是语句，要加分号标识结束。
* 注意对指针的操作，typedef char *p_char和#define p_char char*区别巨大。



#### define 与 inline 的区别

* #define是关键字，inline是函数；
* 宏定义在预处理阶段进行文本替换，inline函数在编译阶段进行替换；
* inline函数有类型检查，相比宏定义比较安全；



#### define 与 函数 的区别

* 宏在编译时完成替换，之后被替换的文本参与编译，相当于直接插入了代码，运行时不存在函数调用，执行起来更快；函数调用在运行时需要跳转到具体调用函数。
* 宏定义属于在结构中插入代码，没有返回值；函数调用具有返回值。
* 宏定义参数没有类型，不进行类型检查；函数参数具有类型，需要检查类型。
* 宏定义不要在最后加分号。

#### 谈谈 assert()

断言，是宏，而非函数。assert 宏的原型定义在 `<assert.h>`（C）、`<cassert>`（C++）中，其作用是如果它的条件返回错误，则终止程序执行。可以通过定义 `NDEBUG` 来关闭 assert，但是需要在源代码的开头，`include <assert.h>` 之前。
**assert() 使用**

```c++
#define NDEBUG          // 加上这行，则 assert 不可用
#include <assert.h>

assert( p != NULL );    // assert 不可用
```

#### 用#define声明一个常数，表明1年中有多少秒（忽略闰年问题）？

```c
#define SECONDS_PER_YEAR (60 * 60 * 24 * 365)UL
```

* 没有以分号结束;
* 懂得预处理器将为你计算常数表达式的值。即60 *60* 24 * 365而不是31536000.
* 考虑到了16位机将会溢出，巧妙运用了UL。
 //U和L是 整数文字量的后缀修饰，用于显示指明整数文字量的类型为unsigned int(U)和long int（L）

#### 宏实现比较大小，以及两个数中的最小值?

```c
#include <iostream>
#define MAX(X, Y) ((X)>(Y)?(X):(Y))
#define MIN(X, Y) ((X)<(Y)?(X):(Y))
using namespace std;

int main ()
{
    int var1 = 10, var2 = 100;
    cout << MAX(var1, var2) << endl;
    cout << MIN(var1, var2) << endl;
    return 0;
}
/*
程序运行结果：
100
10
*/
```

* 参数用括号括起来;
* 考察能否合理运用条件运算符;

### inline

#### 内联函数概念

内联函数比普通函数多了关键字**inline**,

内联函数现在基本就是个建议，是否真的内联由编译器决定

#### 内联函数优缺点

优点：

* 内联函数避免了函数调用的**开销**；普通函数有调用的开销
* 普通函数在被调用的时候，需要**寻址（函数入口地址）**；内联函数不需要寻址。

* 比宏安全

缺点：

* 代码膨胀，如果函数的代码较长，使用内联将消耗过多内存
* 内联函数有一定的限制，内联函数体要求**代码简单**，不能包含复杂的结构控制语句；普通函数没有这个要求。
* 如果函数体内有循环，那么执行函数代码时间比调用开销大。
* 虚函数运行时多态，内联在编译期，无法内联



### static

#### static 的作用

* 不考虑类的情况
  * 变量
      * 隐藏。所有不加static的全局变量和函数具有全局可见性，可以在其他文件中使用，加了之后只能在该文件所在的编译模块中使用
      * 默认初始化为0，包括未初始化的全局静态变量与局部静态变量，都存在全局未初始化区
      * 在变量前面加上static关键字。初始化的静态变量会在数据段分配内存，未初始化的静态变量会在BSS段分配内存。直到程序结束，静态变量始终会维持前值。只不过全局静态变量和局部静态变量的作用域不一样；
      * 与全局变量相比，static全局变量只初始化一次，防止在其他文件单元被引用。
  
  * 函数
      * 在函数返回类型前加上static关键字，函数即被定义为静态函数。静态函数只能在**本源文件**中使用
  
* 考虑类的情况
  * static成员变量：
      * 只与类关联，不与类的对象关联
      * 在类中的static成员变量属于整个类所拥有，对类的所有对象只有一份拷贝；
      * 可以被非 static 成员函数任意访问
      * static类对象必须要在类外进行初始化，static修饰的变量先于对象存在，所以static修饰的变量要在类外初始化；
  * static成员函数：
      * 不具有this指针
      * 不能被声明为const、虚函数和volatile
          * static成员函数不能被virtual修饰，static成员不属于任何对象或实例，所以加上virtual没有任何实际意义；静态成员函数没有this指针，虚函数的实现是为每一个对象分配一个vptr指针，而vptr是通过this指针调用的，所以不能为virtual；虚函数的调用关系，this->vptr->ctable->virtual function
      * 可以被非static成员函数任意访问
      * static类成员函数不能访问非static的类成员，只能访问 static修饰的类成员；
      * 静态成员函数也是类的一部分，而不是对象的一部分







#### 谈谈 static 变量初始化时机

静态局部变量和全局变量一样，数据都存放在全局区域，所以在主程序之前，编译器已经为其分配好了内存，在编译阶段分配好了内存之后就进行初始化，在程序运行结束时变量所处的全局内存会被回收。所以在c语言中无法使用变量对静态局部变量进行初始化。



**再说C++和C语言的区别：**

c++主要引入了类这种东西，要进行初始化必须考虑到相应的构造函数和析构函数，而且很多时候构造或者析构函数中会指定我们制定的操作，并非简单的分配内存。因此为了造成不必要的影响（一些我不需要的东西被提前构造出来）所以c++规定全局或者静态对象在首次用到的时候才会初始化。

所以c++整了两种初始化的情况，我理解就是编译初始化和运行初始化。

编译初始化也叫静态初始化。对全局变量和const类型的初始化主要是，叫做zero initialization 和 const initialization，静态初始化在程序加载的过程中完成。从具体实现上看，zero initialization 的变量会被保存在 bss 段，const initialization 的变量则放在 data 段内，程序加载即可完成初始化，这和 c 语言里的全局变量静态变量初始化基本是一致的。其次全局类对象也是在编译器初始化。

动态初始化也叫运行时初始化。主要是指需要经过函数调用才能完成的初始化或者是类的初始化，一般来说是局部静态类对象的初始化和局部静态变量的初始化。

<img src="https://cdn.jsdelivr.net/gh/luogou/cloudimg/data/20190424220313563.png" alt="在这里插入图片描述" style="zoom: 60%; float: left;" />

下面是我自己的实验的一段代码：

```c++
#include<stdio.h>
static int a;
int main()
{
 int b = 5;
 { 
        //g++编译报错
   static int c = b;
        //gcc编译不报错
        static int c;
  printf("c:%d\n",c); 
 }
 return 0;
}
```

如果在c语言中有局部静态变量赋值操作的话会报错：`undefined reference to ' __cxa_guard_acquire'和 '__cxa_guard_release'`。而这两个API接口恰恰是c++中保证局部静态变量运行时初始化的关键，具体参考[c++局部静态变量和线程安全具体实现参考](https://www.cnblogs.com/william-cheung/p/4831085.html)

#### static 线程安全问题

C语言中非局部静态变量一般在main执行之前的静态初始化过程中分配内存并初始化，可以认为是线程安全的；C++11标准针规定了局部静态变量初始化是线程安全的。这里的线程安全并不是说：由于 m 只能被初始化一次，所以只有初始化 m 的线程会阻塞，另外一个就立即跳过初始化过程返回了。这里的线程安全指的是：一个线程在初始化 m 的时候，其他线程执行到 m 的初始化这一行的时候，就会挂起。

具体实现如下：局部静态变量在编译时，编译器的实现是和全局变量类似的，均存储在bss段中。然后编译器会生成一个`guard_for_c`(上述我写的代码中局部静态变量是c) 用来保证线程安全和一次性初始化的整型变量，是编译器生成的，存储在 bss 段。它的最低的一个字节被用作相应静态变量是否已被初始化的标志， 若为 0 表示还未被初始化，否则表示已被初始化(`if ((guard_for_bar & 0xff) == 0)`判断)。 `__cxa_guard_acquire` 实际上是一个加锁的过程， 相应的 `__cxa_guard_abort` 和`__cxa_guard_release` 释放锁。



### 类型转换

#### 隐式转换，如何消除隐式转换？

* 基本数据类型隐式转换
* 父类子类转换
* 构造函数 explicit 关键字，防止只有一个实参的构造函数发生隐式转换



#### 谈谈 static_cast

比 C 语言强制类型转换

* 更加安全；
* 更直接明显，能够一眼看出是什么类型转换为什么类型，容易找出程序中的错误
* 可清楚地辨别代码中每个显式的强制转换
* 可读性更好，能体现程序员的意图

static_cast < type-id > (expression)

该运算符把expression转换为type-id类型，但没有运行时类型检查来保证转换的安全性。它主要有如下几种用法：

* 用于类层次结构中基类（父类）和派生类（子类）之间指针或引用引用的转换
* 进行上行转换（把派生类的指针或引用转换成基类表示）是安全的
* 进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的
* 用于基本数据类型之间的转换，如把int转换成char，把int转换成enum。这种转换的安全性也要开发人员来保证。
* 把空指针转换成目标类型的空指针
* 把任何类型的表达式转换成void类型

注意：static_cast不能转换掉expression的const、volatile、或者__unaligned属性。

#### 谈谈 reinterpret_cast

`reinterpret_cast<type-id> (expression)`

type-id 必须是一个指针、引用、算术类型、函数指针或者成员指针。它可以用于类型之间进行强制转换。

#### 谈谈 const_cast

该运算符用来修改类型的const或volatile属性。除了const 或volatile修饰之外， type_id和expression的类型是一样的。用法如下：

常量指针被转化成非常量的指针，并且仍然指向原来的对象

常量引用被转换成非常量的引用，并且仍然指向原来的对象

const_cast一般用于修改底指针。如const char *p形式

#### 谈谈 dynamic_cast

有类型检查，基类向派生类转换比较安全，但是派生类向基类转换则不太安全

dynamic_cast (expression)

该运算符把expression转换成type-id类型的对象。type-id 必须是类的指针、类的引用或者void*

如果 type-id 是类指针类型，那么expression也必须是一个指针，如果 type-id 是一个引用，那么 expression 也必须是一个引用

dynamic_cast运算符可以在执行期决定真正的类型，也就是说expression必须是多态类型。如果下行转换是安全的（也就说，如果基类指针或者引用确实指向一个派生类对象）这个运算符会传回适当转型过的指针。如果 如果下行转换不安全，这个运算符会传回空指针（也就是说，基类指针或者引用没有指向一个派生类对象）

dynamic_cast主要用于类层次间的上行转换和下行转换，还可以用于类之间的交叉转换

在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的

在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全

举个例子：

```c++
#include <bits/stdc++.h>
using namespace std;

class Base
{
public:
    Base() :b(1) {}
    virtual void fun() {};
    int b;
};

class Son : public Base
{
public:
    Son() :d(2) {}
    int d;
};

int main()
{
    int n = 97;

    //reinterpret_cast
    int *p = &n;
    //以下两者效果相同
    char *c = reinterpret_cast<char*> (p); 
    char *c2 =  (char*)(p);
    cout << "reinterpret_cast输出："<< *c2 << endl;
    //const_cast
    const int *p2 = &n;
    int *p3 = const_cast<int*>(p2);
    *p3 = 100;
    cout << "const_cast输出：" << *p3 << endl;

    Base* b1 = new Son;
    Base* b2 = new Base;

    //static_cast
    Son* s1 = static_cast<Son*>(b1); //同类型转换
    Son* s2 = static_cast<Son*>(b2); //下行转换，不安全
    cout << "static_cast输出："<< endl;
    cout << s1->d << endl;
    cout << s2->d << endl; //下行转换，原先父对象没有d成员，输出垃圾值

    //dynamic_cast
    Son* s3 = dynamic_cast<Son*>(b1); //同类型转换
    Son* s4 = dynamic_cast<Son*>(b2); //下行转换，安全
    cout << "dynamic_cast输出：" << endl;
    cout << s3->d << endl;
    if(s4 == nullptr)
        cout << "s4指针为nullptr" << endl;
    else
        cout << s4->d << endl;


    return 0;
}
//输出结果
//reinterpret_cast输出：a
//const_cast输出：100
//static_cast输出：
//2
//-33686019
//dynamic_cast输出：
//2
//s4指针为nullptr
```

从输出结果可以看出，在进行下行转换时，dynamic_cast安全的，如果下行转换不安全的话其会返回空指针，这样在进行操作的时候可以预先判断。而使用static_cast下行转换存在不安全的情况也可以转换成功，但是直接使用转换后的对象进行操作容易造成错误。

#### 继承机制中对象之间如何转换？指针和引用之间如何转换？

 **向上类型转换**

* 将派生类指针或引用转换为基类的指针或引用被称为向上类型转换
* 向上类型转换会自动进行
* 而且向上类型转换是安全的。

**向下类型转换**

* 将基类指针或引用转换为派生类指针或引用被称为向下类型转换
* 向下类型转换不会自动进行，因为一个基类对应几个派生类，所以向下类型转换时不知道对应哪个派生类，所以在向下类型转换时必须加动态类型识别技术。
* RTTI技术，用dynamic_cast进行向下类型转换。



#### 谈谈 RTTI 机制

**概念：**

RTTI(Run Time Type Identification)即通过运行时类型识别，C++引入这个机制是为了让程序在运行时能根据基类的指针或引用来获得该指针或引用所指的对象的实际类型。但是现在RTTI的类型识别已经不限于此了，它还能通过typeid操作符识别出所有的基本类型（int，指针等）的变量对应的类型。

和很多其他语言一样，C++是一种静态类型语言。其数据类型是在编译期就确定的，不能在运行时更改。然而由于面向对象程序设计中多态性的要求，C++中的指针或引用(Reference)本身的类型，可能与它实际代表(指向或引用)的类型并不一致。有时我们需要将一个多态指针转换为其实际指向对象的类型，就需要知道运行时的类型信息，这就产生了运行时类型识别的要求。C++要想获得运行时类型信息，只能通过RTTI机制，并且C++最终生成的代码是直接与机器相关的。

**如何实现：**

C++通过以下的两个操作提供RTTI：

（1）typeid运算符，该运算符返回其表达式或类型名的实际类型。返回指针和引用所指的实际类型；

（2）dynamic_cast运算符，该运算符将基类的指针或引用安全地转换为派生类类型的指针或引用。

我们知道C++的多态性（运行时）是由虚函数实现的，对于多态性的对象，无法在程序编译阶段确定对象的类型。当类中含有虚函数时，其基类的指针就可以指向任何派生类的对象，这时就有可能不知道基类指针到底指向的是哪个对象的情况，类型的确定要在运行时利用运行时类型标识做出。为了获得一个对象的类型可以使用typeid函数，该函数反回一个对type_info类对象的引用，要使用typeid必须使用头文件`<typeinfo>`，因为typeid是一个返回类型为typ_info的引用的函数



### 字符串

#### strcpy、strncpy、sprintf、memcopy 函数的区别？

操作对象不同

* strcpy， strncpy的两个操作对象均为字符串
* sprintf的操作源对象可以是多种数据类型，目的操作对象是字符
*  memcpy的两个对象就是两个任意可操作的内存地址，并不限于何种数据类型。

执行效率不同：

* memcpy 最高
* strcpy次之
* sprintf的效率最低

实现功能不同

* strcpy 主要实现字符串变量间的拷贝；不需要指定长度，它遇到被复制字符的串结束符"\0"才结束，所以容易溢出
* strncpy 相比 strcpy当长度大于n 时， 只会截取前n个，不会加\0, 要是少于n个的话会用\0补充
* sprintf主要实现其他数据类型格式到字符串的转化
* memcpy 主要是内存块间的拷贝；根据其第3个参数决定复制的长度。

#### string和char*的区别

string继承自basic_string,其实是对char*进行了封装，封装的string包含了char*数组，容量，长度等等属性。

string可以进行动态扩展，在每次扩展的时候另外申请一块原空间大小两倍的空间（2^n），然后将原字符串拷贝过去，并加上新增的内容。

#### strlen和sizeof区别？

* sizeof是运算符，并不是函数，结果在编译时得到而非运行中获得；strlen是字符处理的库函数。

* sizeof参数可以是任何数据的类型或者数据（sizeof参数不退化）；strlen的参数只能是字符指针且结尾是'\0'的字符串。

* 因为sizeof值在编译时确定，所以不能用来得到动态分配（运行时分配）存储空间的大小

```c
  int main(int argc, char const *argv[]){

      const char* str = "name";

      sizeof(str); // 取的是指针str的长度，是8
      strlen(str); // 取的是这个字符串的长度，不包含结尾的 \0。大小是4
      return 0;
  }
```

#### string 和 `vector<char>`

#### 你知道const char* 与string之间的关系是什么吗？

\1) string 是c++标准库里面其中一个，封装了对字符串的操作，实际操作过程我们可以用const char*给string类初始化

\2) 三者的转化关系如下所示：

```plaintext
a)  string转const char* 

string s = “abc”; 

const char* c_s = s.c_str(); 

b)  const char* 转string，直接赋值即可 

const char* c_s = “abc”; 
 string s(c_s); 

c)  string 转char* 
 string s = “abc”; 
 char* c; 
 const int len = s.length(); 
 c = new char[len+1]; 
 strcpy(c,s.c_str()); 

d)  char* 转string 
 char* c = “abc”; 
 string s(c); 

e)  const char* 转char* 
 const char* cpc = “abc”; 
 char* pc = new char[strlen(cpc)+1]; 
 strcpy(pc,cpc);

f)  char* 转const char*，直接赋值即可 
 char* pc = “abc”; 
 const char* cpc = pc;
```

#### printf 和 cout 区别

cout<<是一个函数，cout<<后可以跟不同的类型是因为cout<<已存在针对各种类型数据的重载，所以会自动识别数据的类型。输出过程会首先将输出字符放入缓冲区，然后输出到屏幕。

cout是有缓冲输出:

```plaintext
 cout < < "abc " < <endl; 
或cout < < "abc\n ";cout < <flush; 这两个才是一样的.
```

flush立即强迫缓冲输出。 printf是无缓冲输出。有输出时立即输出

#### 谈谈 std::string

* sizeof()一个空string的大小是8字节。

 首先我们要知道在c++中sizeof 的大小是由非静态成员变量决定，静态成员变量和成员函数不算在内。

 因为源码`basic_string.h`中data member如下：

 ```c++
  // Data Members (private):
  mutable _Alloc_hider _M_dataplus;
 
 struct _Alloc_hider : _Alloc
 {
     _Alloc_hider(_CharT* __dat, const _Alloc& __a): _Alloc(__a), _M_p(__dat) { }
     _CharT* _M_p; // The actual data.
 };
 ```

 _M_p是指向实际数据的指针，当调用string::data()或者string::c_str()时返回的也是该值。因此sizeof(string)的大小为8，等于该指针的大小

 关于mutable关键字，下面有讲解

* copy-on-write机制

 大多数的string对象拷贝都是用于只读，每次都拷贝内存是没有必要的，而且也很消耗性能，这就有了写时复制机制，也就是把内存复制延迟到写操作时，请看如下代码：

 ```c++
 string s = "Fuck the code.";
 string s1 = s; // 读操作，不实际拷贝内存 
 cout << s1 << endl; // 读操作，不实际拷贝内存 
 s1 += "I want it."; // 写操作，拷贝内存 
 ```

 一些不经意操作可能导致意外的内存拷贝。比如下面代码：

 ```c++
 string s1("test for copy");
 string s2(s1);
 cout << s2 << endl; // shared
 cout << s2[1] << endl; // leaked，此处会重新申请并拷贝内存
 ```

 operator[]有两个重载版本，const和非const版本，当调用非const版本的operator[]时，会造成内存拷贝。那么什么时候会调用const版本，什么时候会调用非const版本？调用哪个版本取决于string对象是否是const，所以好的编程习惯应该是“在const的场景下使用const”。

 gcc5 已经放弃了copy-on-write的设计，采用短字符串优化的方案，即对长度小于16的字符串，作为string对象的一部分，直接从栈空间开辟内存，而且c++11中std::move的引入也使这种copy-on-write的优化不再必要。

* 短字符串优化

 c++11之前是写时复制，之后是实时拷贝+短字符串优化。如下：

 首先gcc中的basic_string有4个数据成员：

  * _M_dataplus
  * _M_string_length
  * _S_local_capacity （不占空间，估计编译时直接把所有_S_local_capacity替换为了15）
  * 匿名union

 ```c++
 // Use empty-base optimization: http://www.cantrip.org/emptyopt.html
 struct _Alloc_hider : allocator_type // TODO check __is_final
 {
 _Alloc_hider(pointer __dat, const _Alloc& __a = _Alloc())
 : allocator_type(__a), _M_p(__dat) { }
 pointer _M_p; // The actual data.
 };
 _Alloc_hider      _M_dataplus;
 size_type         _M_string_length;
 enum { _S_local_capacity = 15 / sizeof(_CharT) };
 union
 {
 _CharT           _M_local_buf[_S_local_capacity + 1]; //之所以是15 + 1，
 //是因为字符串要是null terminated的
 size_type        _M_allocated_capacity;
 }
 ```

 当string长度小于等于 `_S_local_capacity(15)`时，使用`_M_local_buf`，字符串存储在栈上，alloctor就不必进行一次内存分配,从而减少一次系统调用,减少一次用户态向内核态的转换,这就是短字符串优化。 当string长度大于是，在堆上分配。`_M_allocated_capacity` 这个参数,其含义就是容量,也就是分配的内存大小,很巧妙的设计,当使用静态内存的时候,容量为15,不用计算,当大于15的时候静态数组便没有用了,正好用来记录容量,至于如何区分使用的内存是静态的还是由alloctor分配的,就是我们的_M_dataplus要做的事了,其中有一个指针,指向数据,我们只需要在进行短字符串优化时把指针指向静态数组即可

* std::string的缺点

 不支持split、find、join等方法

 没有format，转成sprintf等等

 std::string算上重载有130+的成员函数

* c++string是一个类，是basic_string类的别名

 能被继承，但最好不要

<https://stackoverflow.com/questions/6006860/why-should-one-not-derive-from-c-std-string-class>
