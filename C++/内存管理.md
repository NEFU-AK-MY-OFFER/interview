# 内存管理

## 问题

### 内存布局

* 谈谈 C++ 内存对齐？
* 为什么C++没有垃圾回收机制？
* 如何设计垃圾回收机制？
* 常见的内存错误及其对策
* 谈谈内存泄漏？
* 简述一下堆和栈的区别
* C++ 的内存分区
* 什么时候会发生 segment fault 数组越界一定会发生吗

### new/delete、malloc/free

* new/delete 与 malloc/free 的异同
* delete 如何知道释放内存的大小
* malloc、realloc、calloc 区别
* malloc 申请的空间能用 delete 释放吗
* new/delete 和 malloc/free 的实现
* 既然有了malloc/free，C++中为什么还需要new/delete呢？直接用malloc/free不好吗？
* 被 free 回收的内存是立即返还给操作系统吗？
* C++ 有几种 new
* delete p、delete[]p 有什么用

### 对象内存

* C++中类的数据成员和成员函数内存分布情况
* 你知道空类的大小是多少吗？
* 谈谈深拷贝和浅拷贝
* 类如何实现只能静态分配和只能动态分配

### 函数调用

* 函数的堆栈过程
* 函数调用过程栈的变化，返回值和参数变量哪个先入栈？
* 方法调用的原理（栈，汇编）
* C++函数调用的压栈过程
* 参数的计算顺序与压栈顺序
* printf 实现原理

### 智能指针

* 智能指针的原理、常用的智能指针及实现
* sharedPtr存在线程安全问题吗
* weak_ptr 的 expired 是线程安全的吗
* 为什么推荐用 make_shared 创建指针
* shared_ptr重载了=运算符，里面有什么，要注意什么，返回值是什么
* 共享指针能否指向独占指针，独占指针能否指向共享指针（或者说能否互相转换？）
* 用lambda捕获uniquePtr应该怎么做（引用捕获，因为uniquePtr没有拷贝构造）
  lambda捕获uniquePtr后如何避免调用lambda时uniquePtr的指针已失效（不会，面试官说要用移动捕获C++14/17的特性）
  用lambda捕获sharedPtr要怎么做（值捕获，避免调用时sharedPtr对象已销毁）
  捕获sharedPtr时如果不想延长对象生命周期怎么做（先赋值给weakPtr,再捕获）

## 回答

### 内存布局

#### 谈谈 C++ 内存对齐？

内存对齐应用于三种数据类型中：

* struct
* class
* union

struct/class/union内存对齐原则有四个：

1. 数据成员对齐规则：结构(struct)或联合(union)的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员存储的起始位置要从该成员大小或者成员的子成员大小的整数倍开始。
2. 结构体作为成员:如果一个结构里有某些结构体成员,则结构体成员要从其内部"最宽基本类型成员"的整数倍地址开始存储。(struct a里存有struct b,b里有char,int ,double等元素,那b应该从8的整数倍开始存储)。
3. 收尾工作:结构体的总大小，也就是sizeof的结果，必须是其内部最大成员的"最宽基本类型成员"的整数倍。不足的要补齐。(基本类型不包括struct/class/uinon)。
4. sizeof(union)，以结构里面size最大元素为union的size，因为在某一时刻，union只有一个成员真正存储于该地址。

概念：各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐



为什么要内存对齐

1. **平台原因(移植原因)**：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。

2. **性能原因**：数据结构(尤其是栈)应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。

**字节对齐实例**

```C++
union example {    
 int a[5];    
 char b;    
 double c;   
};   

int result = sizeof(example);   
/* 如果以最长20字节为准，内部double占8字节，这段内存的地址0x00000020并不是double的整数倍，只有当最小为0x00000024时可以满足整除double（8Byte）同时又可以容纳int a[5]的大小，所以正确的结果应该是result=24 */  

struct example {    
 int a[5];    
 char b;    
 double c;   
}test_struct; 
int result = sizeof(test_struct);   /* 如果我们不考虑字节对齐，那么内存地址0x0021不是double（8Byte）的整数倍，所以需要字节对齐，那么此时满足是double（8Byte）的整数倍的最小整数是0x0024，说明此时char b对齐int扩充了三个字节。所以最后的结果是result=32 */
  
struct example {
    char b;    
    double c;    
    int a;   
}test_struct;   
int result = sizeof(test_struct);   
/* 字节对齐除了内存起始地址要是数据类型的整数倍以外，还要满足一个条件，那就是占用的内存空间大小需要是结构体中占用最大内存空间的类型的整数倍，所以20不是double（8Byte）的整数倍，我们还要扩充四个字节，最后的结果是result=24 */
```

结构体对齐

* 结构体内成员按照声明顺序存储，第一个成员地址和整个结构体地址相同。
* 未特殊说明时，按结构体中size最大的成员对齐（若有double成员，按8字节对齐。）

c++11以后引入两个关键字 [alignas](https://zh.cppreference.com/w/cpp/language/alignas)与 [alignof](https://zh.cppreference.com/w/cpp/language/alignof)。其中alignof可以计算出类型的对齐方式，alignas可以指定结构体的对齐方式。

1、 分配内存的顺序是按照声明的顺序。

2、 每个变量相对于起始位置的偏移量必须是该变量类型大小的整数倍，不是整数倍空出内存，直到偏移量是整数倍为止。

3、 最后整个结构体的大小必须是里面变量类型最大值的整数倍。

添加了#pragma pack(n)后规则就变成了下面这样：

1、 偏移量要是n和当前变量大小中较小值的整数倍

2、 整体大小要是n和最大变量大小中较小值的整数倍

3、 n值必须为1,2,4,8…，为其他值时就按照默认的分配规则





#### 为什么C++没有垃圾回收机制？

* 首先，实现一个垃圾回收器会带来额外的空间和时间开销。你需要开辟一定的空间保存指针的引用计数和对他们进行标记mark。然后需要单独开辟一个线程在空闲的时候进行free操作。
* 垃圾回收会使得C++不适合进行很多底层的操作。



#### 如何设计垃圾回收机制？

垃圾收集器是一种动态存储分配器，它自动释放程序不再需要的已分配的块，这些块也称为 垃圾 。在程序员看来，垃圾就是不再被引用的对象。自动回收垃圾的过程则称为 垃圾收集（garbage [collection](https://so.csdn.net/so/search?q=collection&spm=1001.2101.3001.7020)） 。在一个支持垃圾收集的语言中，程序显式地申请内存，但从不需要显式的释放它们。垃圾收集器会定期识别垃圾块，并将垃圾块放回空闲链表中。显然，C语言的malloc包不是一个带GC功能的分配器，程序员显式 调用malloc分配内存，也需要显式调用free释放它。而像java、C#这些语言等则提供了垃圾收集器。

**基本概念**

有向可达图与根集

垃圾收集器将存储器视为一张有向可达图。图中的节点可以分为两组：一组称为根节点，对应于不在堆中的位置，这些位置可以是寄存器、栈中的变量，或者是虚拟存储器中读写数据区域的全局变量；另外一组称为堆节点，对应于堆中一个分配块，如下图：

![这里写图片描述](https://img-blog.csdn.net/20180101205900758?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjYxMTg3OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

当存在一个根节点可到达某个堆节点时，我们称该堆节点是可达的，反之称为不可达。不可达堆节点为垃圾。可见垃圾收集的目标即是从从根集出发，寻找未被引用的堆节点，并将其释放。

**三种基本的垃圾收集算法及其改进算法**

垃圾收集算法是一个重要而活跃的研究领域，自从20世纪60年代开始对垃圾收集进行研究以来，垃圾算法的研究从未停止。常见的垃圾收集算法有一下这几种类型：

1、引用计数算法

引用技术算法是唯一一种不用用到根集概念的GC算法。其基本思路是为每个对象加一个计数器，计数器记录的是所有指向该对象的引用数量。每次有一个新的引用指向这个对象时，计数器加一；反之，如果指向该对象的引用被置空或指向其它对象，则计数器减一。当计数器的值为0时，则自动删除这个对象。

![这里写图片描述](https://img-blog.csdn.net/20180101210852188?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjYxMTg3OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

缺点二是多个线程同时对引用计数进行增减时，引用计数的值可能会产生不一致的问题，必须使用并发控制机制解决这一问题，也是一个不小的开销。

2、 Mark & Sweep 算法

这个算法也称为标记清除算法，为McCarthy独创。它也是目前公认的最有效的GC方案。Mark&Sweep垃圾收集器由标记阶段和回收阶段组成，标记阶段标记出根节点所有可达的对节点，清除阶段释放每个未被标记的已分配块。典型地，块头部中空闲的低位中的一位用来表示这个块是否已经被标记了。通过Mark&Sweep算法动态申请内存时，先按需分配内存，当内存不足以分配时，从寄存器或者程序栈上的引用出发，遍历上述的有向可达图并作标记（标记阶段），然后再遍历一次内存空间，把所有没有标记的对象释放（清除阶段）。因此在收集垃圾时需要中断正常程序，在程序涉及内存大、对象多的时候中断过程可能有点长。当然，收集器也可以作为一个独立线程不断地定时更新可达图和回收垃圾。该算法不像引用计数可对内存进行即时回收，但是它解决了引用计数的循环引用问题，因此有的语言把引用计数算法搭配Mark & Sweep 算法构成GC机制。

![这里写图片描述](https://img-blog.csdn.net/20180101211251780?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjYxMTg3OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

3、 节点复制算法

Mark & Sweep算法的缺点是在分配大量对象时，且对象大都需要回收时，回收中断过程可能消耗很大。而节点复制算法则刚好相反，当需要回收的对象越多时，它的开销很小，而当大部分对象都不需要回收时，其开销反而很大。
算法的基本思路是这样的：从根节点开始，被引用的对象都会被复制到一个新的存储区域中，而剩下的对象则是不再被引用的，即为垃圾，留在原来的存储区域。释放内存时，直接把原来的存储区域释放掉，继续维护新的存储区域即可。过程如图：

![这里写图片描述](https://img-blog.csdn.net/20180101211401719?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjYxMTg3OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

可以看到，当被引用对象（非垃圾对象）很多时，需要复制很多的对象到新存储区域。

**分代回收**

以上三种基本算法各有各的优缺点，也各自有许多改进的方案。通过对这三种方式的融合，出现了一些更加高级的方式。而高级GC技术中最重要的一种为分代回收。它的基本思路是这样的：程序中存在大量的这样的对象，它们被分配出来之后很快就会被释放，但如果一个对象分配后相当长的一段时间内都没有被回收，那么极有可能它的生命周期很长，尝试收集它是无用功。为了让GC变得更高效，我们应该对刚诞生不久的对象进行重点扫描，这样就可以回收大部分的垃圾。为了达到这个目的，我们需要依据对象的”年龄“进行分代，刚刚生成不久的对象划分为新生代，而存在时间长的对象划分为老生代，根据实现方式的不同，可以划分为多个代。

一种回收的实现策略可以是：首先从根开始进行一次常规扫描，扫描过程中如果遇到老生代对象则不进行递归扫描，这样可大大减少扫描次数。这个过程可使用标记清除算法或者复制收集算法。然后，把扫描后残留下来的对象划分到老生代，若是采用标记清除算法，则应该在对象上设置某个标志位标志其年龄；若是采用复制收集，则只需要把新的存储区域内对象设置为老生代就可以了。而实际的实现上，分代回收算法的方案五花八门，常常会融合几种基本算法。

而其他的改进算法数量非常庞大，但大都基于上述的三种基本算法。

**C++垃圾回收机制**

C语言本身没有提供GC机制，而C++ 0x则提供了基于引用计数算法的智能指针进行内存管理。也有一些不作为C++标准的[垃圾回收](https://so.csdn.net/so/search?q=垃圾回收&spm=1001.2101.3001.7020)库，如著名的Boehm库。借助其他的算法也可以实现C/C++的GC机制，如前面所说的标记清除算法。

![这里写图片描述](https://img-blog.csdn.net/20180101212333800?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjYxMTg3OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

当应用程序使用[malloc](https://so.csdn.net/so/search?q=malloc&spm=1001.2101.3001.7020)试图从堆上获得内存块时，通常都是以常规方式来调用malloc，而当malloc找不到合适空闲块的时候，它就会去调用垃圾收集器，以回收垃圾到空闲链表。此时，垃圾收集器将识别出垃圾块，并通过free函数将它们返回给堆。这样看来，垃圾收集器代替我们调用了free函数，从而让我们显式分配，而无须显式释放。

上图中的垃圾收集器为一个保守的垃圾收集器。保守的定义是：每个可达的块都能够正确地被标记为可达，而一些不可达块却可能被错误地标记为可达。其根本原因在于C/C++语言不会用任何类型信息来标记存储器的位置，即对于一个整数类型来说，语言本身没有一种显式的方法来判断它是一个整数还是一个指针。因此，如果某个整数值所代表的地址恰好的某个不可达块中某个字的地址，那么这个不可达块就会被标记为可达。所以，C/C++所实现的垃圾收集器都不是精确的，存在着回收不干净的现象。而像JAVA的垃圾收集器则是精确回收。

#### 常见的内存错误及其对策

* 内存分配未成功，却使用了它。
    * 对策：定义指针时，先初始化为NULL。

* 内存分配虽然成功，但是尚未初始化就引用它。
    * 对策：用malloc或new申请内存之后，应该**立即检查**指针值是否为NULL。防止使用指针值为NULL的内存。

* 内存分配成功并且已经初始化，但操作越过了内存的边界。
    * 对策：避免数字或指针的下标**越界**，特别要当心发生“多1”或者“少1”操作

* 忘记了释放内存，造成内存泄露。
    * 对策：动态内存的申请与释放必须配对，防止**内存泄漏**

* 释放了内存却继续使用它。
    * 对策：用free或delete释放了内存之后，立即将指针**设置为NULL**，防止“野指针”




#### 谈谈内存泄漏？

**可能原因**

简单地说就是申请了一块内存空间，使用完毕后没有释放掉。

* new和malloc申请资源使用后，没有用delete和free释放；
* 子类继承父类时，父类析构函数不是虚函数。
* Windows句柄资源使用后没有释放。

**后果**

只发生一次小的内存泄漏可能不被注意，但泄漏大量内存的程序将会出现各种症状：性能下降到内存逐渐用完，导致另一个程序失败

**如何避免**

* 良好的编码习惯，使用了内存分配的函数，一旦使用完毕,要记得使用其相应的函数释放掉
  * 计数法：使用new或者malloc时，让该数+1，delete或free时，该数-1，程序执行完打印这个计数，如果不为0则表示存在内存泄露
  * 一定要将基类的析构函数声明为**虚函数**
  * 对象数组的释放一定要用**delete []**
  * 有new就有delete，有malloc就有free，保证它们一定成对出现
  
* 使用智能指针

* 一些常见的工具插件

    * Clang AddressSanitizer
    * Valgrind

    

#### 简述堆和栈的区别

|                  | 堆                                                           | 栈                                                           |
| ---------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **管理方式**     | 堆中资源由程序员控制（容易产生memory leak）                  | 栈资源由编译器自动管理，无需手工控制                         |
| **内存管理机制** | 系统有一个记录空闲内存地址的链表，当系统收到程序申请时，遍历该链表，寻找第一个空间大于申请空间的堆结点，删 除空闲结点链表中的该结点，并将该结点空间分配给程序（大多数系统会在这块内存空间首地址记录本次分配的大小，这样delete才能正确释放本内存空间，另外系统会将多余的部分重新放入空闲链表中） | 只要栈的剩余空间大于所申请空间，系统为程序提供内存，否则报异常提示栈溢出。（这一块理解一下链表和队列的区别，不连续空间和连续空间的区别，应该就比较好理解这两种机制的区别了） |
| **空间大小**     | 堆向高地址扩展，是不连续的内存区域，大小可以灵活调整。<br />堆是不连续的内存区域（因为系统是用链表来存储空闲内存地址，自然不是连续的），堆大小受限于计算机系统中有效的虚拟内存（32bit 系统理论上是4G），所以堆的空间比较灵活，比较大 | 栈顶和栈底是之前预设好的，栈是向栈底扩展，大小固定，可以通过ulimit -a查看，由ulimit -s修改。<br />栈是一块连续的内存区域，大小是操作系统预定好的，windows下栈大小是2M（也有是1M，在 编译时确定，VC中可设置） |
| **碎片问题**     | 对于堆，频繁的new/delete会造成大量碎片，使程序效率降低       | 对于栈，它是有点类似于数据结构上的一个先进后出的栈，进出一一对应，不会产生碎片。（看到这里我突然明白了为什么面试官在问我堆和栈的区别之前先问了我栈和队列的区别） |
| **生长方向**     | 堆向上，向高地址方向增长。                                   | 栈向下，向低地址方向增长。                                   |
| **分配方式**     | 堆都是动态分配（没有静态分配的堆）                           | 栈有静态分配和动态分配，静态分配由编译器完成（如局部变量分配），动态分配由alloca函数分配，但栈的动态分配的资源由编译器进行释放，无需程序员实现。 |
| **分配效率**     | 堆的操作是由C/C++函数库提供的，在分配堆内存的时候需要一定的算法寻找合适大小的内存。并且获取堆的内容需要两次访问，第一次访问指针，第二次根据指针保存的地址访问内存，因此堆比较慢。 | 栈是其系统提供的数据结构，计算机在底层对栈提供支持，分配专门 寄存器存放栈地址，栈操作有专门指令。 |

#### 内存分区和程序段

**一、c语言五大内存分区**

1. **栈区（stack）**:存放函数形参和局部变量（auto类型），由编译器自动分配和释放。
2. **堆区（heap）**:该区由程序员申请后使用，需要手动释放否则会造成内存泄漏。如果程序员没有手动释放，那么程序结束时可能由OS回收。
3. **全局/静态存储区**：存放全局变量和静态变量（包括静态全局变量与静态局部变量），初始化的全局变量和静态局部变量放在一块，未初始化的放在另一块。
4. **文字常量区**：常量在统一运行被创建，常量区的内存是只读的，程序结束后由系统释放。
5. **程序代码区**：存放程序的二进制代码，内存由系统管理

**二、可执行程序程序三段-Text段，Date段，Bss段**

![img](https://pic4.zhimg.com/v2-4216fb4084bb62effd0843f4ab839fe3_b.gif)

**1.一个程序的3个基本段：text段，dtae段，bss段**

* text段在内存中被映射为只读，但date段与bss段是可写的
* text段：代码段，就是放程序代码的，编译时确定，只读
* date段：存放在编译阶段（而非运行时）就能确定的数据，可读可写。也就是通常所说的静态存储区，赋了初值的全局变量和赋初值的静态变量存放在这个区域，常量也存在这个区域
* bss段：已经定义但没赋初值的全局变量和静态变量存放在这个区域。

两者之间区别是：代码段，数据段，堆栈段是cpu级别的概念，五大分区属于语言级别的概念，两者是不同的概念。

**三、可执行程序内存空间与逻辑地址空间的映射与划分**

![img](https://pic1.zhimg.com/v2-90f6e3b4370ef3135af29eacf3afe17c_b.jpg)

**左边是UNIX系统的执行文件，右边是进程对应的逻辑地址空间的划分情况**

* 首先是栈区（堆栈区stack）,堆栈是由编译器自动分配释放，存放函数的参数和局部变量的值（auto类型），操作方式类似于数据结构中的栈。栈的申请是由系统自动分配，如在函数内部申请一个局部变量int
 h,同时判断所申请空间是否小于栈的剩余空间，如果小于则为其开辟空间，为程序提供内存，否则将报异常提示栈溢出。
* 堆（heap），堆一般由程序员分配释放，若程序员不释放，程序结束可能由OS回收。它与数据结构中的堆是两回事，分配方式类似于链表，申请则是程序员自己操作使用malloc或new。申请过程比较复杂，当系统收到程序的申请时，会遍历记录空闲内存地址的链表，以求寻找第一个空间大于所申请空间的堆节点，然后将该节点从空闲节点链表中删除，并将该节点的空间分配给程序，有些情况下，新申请的内存块的首地址记录本次分配的内存块的大小，这样在delete尤其是delete[]时能正确的释放内存空间。
* 下边是全局静态存储区，全局变量与静态变量的存储是放在一块的，初始化的全局变量与静态变量存放在一块区域，未初始化的全局变量与未初始化的静态变量存放在相邻的另一块区域。
* 文字常量区，常量字符串就是放在该部分，只读存储区，程序结束后由系统释放
* 程序代码区，存放程序的二进制代码区。

**四、存储类型关键字定义变量与函数作用域与生命周期**

![img](https://pic1.zhimg.com/v2-be18cb3847cd5657ed5419506937258c_b.jpg)

* **auto变量**：函数的局部变量，如果没有声明为static,函数中定义的局部变量全部为auto类型，auto变量包括未加static声明的局部变量和函数的形参。在函数调用时系统会给他们分配存储空间，在函数调用结束后会自动释放这些空间。属于动态存储方式。
* **static变量**：用static声明的局部变量在调用结束后不会消失而保存原来的值。static局部变量定义使用后值会存储下来。所以使用static局部变量定义只需要一次赋值。静态局部变量的作用域仅限于所定义的函数。但函数结束后变量的值会保留。直到整个程序运行结束。全局变量从定义开始作用于整个文件直至程序运行结束。
* **register寄存器变量**：寄存器变量可以提高c语言的执行效率，即将局部变量的值存入CPU的寄存器中。需要注意的是！！！：1.只有动态存储的变量（自动局部变量和形参）才可以作为寄存器变量来存储，局部静态变量不可以定义为寄存器变量。2.计算机的寄存器数目是有限的，所以不能定义任意多个寄存器变量。
* **extern外部变量**：即全局变量的外部表现形式，是在函数外部定义的变量。全局变量的作用域为从定义开始到源文件结束。exten对该变量作外部变量声明，扩展变量作用域。

#### 什么时候会发生 segment fault 数组越界一定会发生吗

#### 程序启动的过程

操作系统首先创建相应的进程并分配私有的进程空间，然后操作系统的加载器负责把可执行文件的数据段和代码段映射到进程的虚拟内存空间中。

加载器读入可执行程序的导入符号表，根据这些符号表可以查找出该可执行程序的所有依赖的动态链接库。

加载器针对该程序的每一个动态链接库调用LoadLibrary

（1）查找对应的动态库文件，加载器为该动态链接库确定一个合适的基地址。

（2）加载器读取该动态链接库的导入符号表和导出符号表，比较应用程序要求的导入符号是否匹配该库的导出符号。

（3）针对该库的导入符号表，查找对应的依赖的动态链接库，如有跳转，则跳到3

（4）调用该动态链接库的初始化函数

初始化应用程序的全局变量，对于全局对象自动调用构造函数。

进入应用程序入口点函数开始执行。

### new/delete、malloc/free

#### new/delete 与 malloc/free 的异同

* new/delete是C++操作符关键字，需要编译器支持。malloc/free是库函数，需要头文件支持；

* 使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。而malloc则需要显式地指出所需内存的尺寸。

* new 操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回void *，需要通过强制类型转换将void*指针转换成我们需要的类型。

 ```
 int *p = new float[2]; //编译错误
 int *p = (int*)malloc(2 * sizeof(double));//编译无错误
 ```

* new内存分配失败时，会抛出bac_alloc 异常。malloc分配内存失败时返回NULL。

* new会先调用operator new函数，申请足够的内存（通常底层使用malloc实现）。然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。delete先调用析构函数，然后调用operator delete函数释放内存（通常底层使用free实现）。malloc/free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。

#### delete 如何知道释放内存的大小



#### malloc、realloc、calloc 区别

* malloc申请的空间的值是随机初始化的
* calloc申请的空间的值是初始化为0的；
* realloc函数：给动态分配的空间分配额外的空间，用于扩充容量。



#### malloc 申请的空间能用 delete 释放吗

不能，malloc /free主要为了兼容C，new和delete 完全可以取代malloc /free的。

malloc /free的操作对象都是必须明确大小的，而且不能用在动态类上。

new 和delete会自动进行类型检查和大小，malloc/free不能执行构造函数与析构函数，所以动态对象它是不行的。

当然从理论上说使用malloc申请的内存是可以通过delete释放的。不过一般不这样写的。而且也不能保证每个C++的运行时都能正常。

#### new/delete 和 malloc/free 的实现

new的实现过程：

1. 首先调用名为operator new（operator new[])的标准库函数，分配足够大的原始为类型化的内存，以保存指定类型的一个对象
 * 对于复杂结构，先调用operator new分配内存，然后在分配的内存上调用构造函数
2. 接下来运行该类型的一个构造函数，用指定初始化构造对象
3. 最后返回指向新分配并构造后的的对象的指针

delete的实现过程：

1. 对指针指向的对象运行适当的析构函数
2. 通过调用名为**operator delete**的标准库函数释放该对象所用内存

delete简单数据类型默认只是调用free函数；复杂数据类型先调用析构函数再调用operator delete

​	 



new[] 和 delete[]
new[]

* 对于简单类型，new[]计算好大小后调用operator new
* 对于复杂数据结构，new[]先调用operator new[]分配内存，然后在p的前四个字节写入数组大小n，然后调用n次构造函数，针对复杂类型，new[]会额外存储数组大小
* 需要在 new [] 一个对象数组时，需要保存数组的维度，C++ 的做法是在分配数组空间时多分配了 4 个字节的大小，专门保存数组的大小，在 delete [] 时就可以取出这个保存的数，就知道了需要调用析构函数多少次了

delete[]

* 针对简单类型，delete和delete[]等同。假设指针p指向new[]分配的内存。因为要4字节存储数组大小，实际分配的内存地址为[p-4]，系统记录的也是这个地址。delete[]实际释放的就是p-4指向的内存。而delete会直接释放p指向的内存，这个内存根本没有被系统记录，所以会崩溃。



malloc底层实现：

* 当开辟的空间小于 128K 时，调用 brk（），brk是将数据段(.data)的最高地址指针_edata往高地址推
* 当开辟的空间大于 128K 时，调用mmap（），mmap是在进程的虚拟地址空间中（堆和栈中间，称为文件映射区域的地方）找一块空闲的虚拟内存。这两种方式分配的都是虚拟内存，没有分配物理内存。在第一次访问已分配的虚拟地址空间的时候，发生缺页中断，操作系统负责分配物理内存，然后建立虚拟内存和物理内存之间的映射关系；
* malloc采用的是内存池的管理方式，以减少内存碎片。先申请大块内存作为堆区，然后将堆区分为多个内存块。当用户申请内存时，直接从堆区分配一块合适的空闲快。采用隐式链表将所有空闲块，每一个空闲块记录了一个未分配的、连续的内存地址。
* 操作系统中有一个记录空闲内存地址的链表。当操作系统收到程序的申请时，就会遍历该链表，然后就寻找第一个空间大于所申请空间的堆结点，然后就将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。
* malloc是从堆里面申请内存，也就是说函数返回的指针是指向堆里面的一块内存。

#### 既然有了malloc/free，C++中为什么还需要new/delete呢？直接用malloc/free不好吗？

如果是对象的话，还要构造和析构



#### 被free回收的内存是立即返还给操作系统吗？

不是的，被free回收的内存会首先被ptmalloc使用双链表保存起来，当用户下一次申请内存的时候，会尝试从这些内存中寻找合适的返回。这样就避免了频繁的系统调用，占用过多的系统资源。同时ptmalloc也会尝试对小块内存进行合并，避免过多的内存碎片。



#### C++ 有几种 new

在C++中，new有三种典型的使用方法：

* plain new：平常用的，空间分配失败抛出 std::bad_alloc

* nothrow new：nothrow new在空间分配失败的情况下是不抛出异常，而是返回NULL

* placement new：这种new允许在一块已经分配成功的内存上重新构造对象或对象数组。placement new不用担心内存分配失败，因为它根本不分配内存，它做的唯一一件事情就是调用对象的构造函数。

    * palcement new的主要用途就是反复使用一块较大的动态分配的内存来构造不同类型的对象或者他们的数组

    * placement new构造起来的对象数组，要显式的调用他们的析构函数来销毁（析构函数并不释放对象的内存），千万不要使用delete，这是因为placement new构造起来的对象或数组大小并不一定等于原来分配的内存大小，使用delete会造成内存泄漏或者之后释放内存时出现运行时错误。





#### delete p、delete[]p 的区别

* delete只会调用一次析构函数。
* delete[]会调用数组中每个元素的析构函数。
* delete[]时，数组中的元素按逆序的顺序进行销毁；



#### 什么是内存池，如何实现

内存池（Memory Pool） 是一种**内存分配**方式。通常我们习惯直接使用new、malloc 等申请内存，这样做的缺点在于：由于所申请内存块的大小不定，当频繁使用时会造成大量的内存碎片并进而降低性能。内存池则是在真正使用内存之前，先申请分配一定数量的、大小相等(一般情况下)的内存块留作备用。当有新的内存需求时，就从内存池中分出一部分内存块， 若内存块不够再继续申请新的内存。这样做的一个显著优点是尽量避免了内存碎片，使得内存分配效率得到提升。

这里**简单描述一下《STL源码剖析》中的内存池实现机制**：

**allocate 包装 malloc，deallocate包装free**

一般是一次20*2个的申请，先用一半，留着一半，为什么也没个说法，侯捷在STL那边书里说好像是C++委员会成员认为20是个比较好的数字，既不大也不小。

1. 首先客户端会调用malloc()配置一定数量的区块（固定大小的内存块，通常为8的倍数），假设40个32bytes的区块，其中20个区块（一半）给程序实际使用，1个区块交出，另外19个处于维护状态。剩余20个（一半）留给内存池，此时一共有（20*32byte）
2. 客户端之后有有内存需求，想申请（20*64bytes）的空间，这时内存池只有（20*32bytes），就先将（10*64bytes)个区块返回，1个区块交出，另外9个处于维护状态，此时内存池空空如也.
3. 接下来如果客户端还有内存需求，就必须再调用malloc()配置空间，此时新申请的区块数量会增加一个随着配置次数越来越大的附加量，同样一半提供程序使用，另一半留给内存池。申请内存的时候用永远是先看内存池有无剩余，有的话就用上，然后挂在0-15号某一条链表上，要不然就重新申请。
4. 如果整个堆的空间都不够了，就会在原先已经分配区块中寻找能满足当前需求的区块数量，能满足就返回，不能满足就向客户端报bad_alloc异常

allocator就是用来分配内存的，最重要的两个函数是allocate和deallocate，就是用来申请内存和回收内存的，外部（一般指容器）调用的时候只需要知道这些就够了。

内部实现，目前的所有编译器都是直接调用的::operator new()和::operator delete()，说白了就是和直接使用new运算符的效果是一样的，所以老师说它们都没做任何特殊处理。

**其实最开始GC2.9之前**

new和 operator new 的区别：new 是个运算符，编辑器会调用 operator new(0)

operator new()里面有调用malloc的操作，那同样的 operator delete()里面有调用的free的操作

GC2.9下的alloc函数的一个比较好的分配器的实现规则如下：

维护一条0-15号的一共16条链表，其中 0 号表示8 bytes ，1 号表示 16 bytes，2 号表示 24 bytes。。。。而15 号表示 16* 8 = 128 bytes。

如果在申请内存时，申请内存的大小并不是8的倍数（比如2、4、7、9、18这样不是8的倍数），那就找刚好能满足内存大小的链表。比如想申请 12 个大小，那就按照 16 来处理，也就是找 1 号链表了；想申请 20 ，距离它最近的就是 24 了，那就找 2 号链表。

只许比所要申请的内容大，不许小！

**但是现在GC4.9及其之后** 也还有 alloc 函数，只不过已经变成_pool_alloc这个名字了，名字已经改了，也不再是默认的了。

你需要自己手动去指定它可以自己指定，比如

```plaintext
vector<string,__gnu_cxx::pool_alloc<string>> vec;
```

这样来使用它，等于兜兜转转又回到以前那种对malloc和free的包装形式了。

### 对象内存

#### C++中类的数据成员和成员函数内存分布情况

* 类的大小：
  * **非静态成员**的数据类型大小之和
  * 边缘对齐优化加入 padding：内存对齐另外分配的空间大小，类内的数据也是需要进行内存对齐操作的
  * 有虚函数的话，会在类对象插入vptr指针，加上指针大小

* 静态成员不占据类的空间，成员函数也不占据类的空间大小
* 当该类是某类的派生类，那么派生类继承的基类部分的数据成员也会存在在派生类中的空间中，也会对派生类进行扩展

* 一个类对象的地址就是类所包含的这一片内存空间的首地址，这个首地址也就对应具体某一个成员变量的地址
* 对象的大小和对象中数据成员的大小是一致的，成员函数不占用对象的内存。这是因为所有的函数都是存放在代码区的，不管是全局函数，还是成员函数。
* 静态成员函数的存放问题：静态成员函数与一般成员函数的唯一区别就是没有this指针，因此不能访问非静态数据成员。所有函数都存放在代码区，静态函数也不例外。所有有人一看到 static 这个单词就主观的认为是存放在全局数据区，那是不对的。
* 空类的大小

    * C++标准指出，不允许一个对象（当然包括类对象）的大小为0，不同的对象不能具有相同的地址；C++中要求对于类的每个实例都必须有独一无二的地址,那么编译器自动为空类分配一个字节大小，这样便保证了每个实例均有独一无二的内存地址
    * 带有虚函数的C++类大小不为1，因为每一个对象会有一个vptr指向虚函数表，具体大小根据指针大小确定（32 位 4 字节、64 位为 8 字节）
    * 当该空白类作为基类时，该类的大小就优化为0了，子类的大小就是子类本身的大小。这就是所谓的空白基类最优化

    



#### 谈谈深拷贝和浅拷贝


浅拷贝只是拷贝一个指针，并没有新开辟一个地址

深拷贝，在计算机中开辟了一块新的内存地址用于存放复制的对象。



#### 谈谈对象复用和零拷贝

**对象复用**

对象复用其本质是一种设计模式：Flyweight享元模式。

通过将对象存储到“对象池”中实现对象的重复利用，这样可以避免多次创建重复对象的开销，节约系统资源。

**零拷贝**

零拷贝就是一种避免 CPU 将数据从一块存储拷贝到另外一块存储的技术。

零拷贝技术可以减少数据拷贝和共享总线操作的次数。

在C++中，vector的一个成员函数**emplace_back()**很好地体现了零拷贝技术，它跟push_back()函数一样可以将一个元素插入容器尾部，区别在于：**使用push_back()函数需要调用拷贝构造函数和转移构造函数，而使用emplace_back()插入的元素原地构造，不需要触发拷贝构造和转移构造**，效率更高。举个例子：

```plaintext
#include <vector>
#include <string>
#include <iostream>
using namespace std;

struct Person
{
    string name;
    int age;
    //初始构造函数
    Person(string p_name, int p_age): name(std::move(p_name)), age(p_age)
    {
         cout << "I have been constructed" <<endl;
    }
     //拷贝构造函数
     Person(const Person& other): name(std::move(other.name)), age(other.age)
    {
         cout << "I have been copy constructed" <<endl;
    }
     //转移构造函数
     Person(Person&& other): name(std::move(other.name)), age(other.age)
    {
         cout << "I have been moved"<<endl;
    }
};

int main()
{
    vector<Person> e;
    cout << "emplace_back:" <<endl;
    e.emplace_back("Jane", 23); //不用构造类对象

    vector<Person> p;
    cout << "push_back:"<<endl;
    p.push_back(Person("Mike",36));
    return 0;
}
//输出结果：
//emplace_back:
//I have been constructed
//push_back:
//I have been constructed
//I am being moved.
```

#### 类如何实现只能静态分配和只能动态分配

建立类的对象有两种方式：

① 静态建立：静态建立一个类对象，就是由编译器为对象在栈空间中分配内存

② 动态建立：A *p = new A(); 动态建立一个类对象，就是使用new运算符为对象在堆空间中分配内存。这个过程分为两步，第一步执行operator new()函数，在堆中搜索一块内存并进行分配；第二步调用类构造函数构造对象

**只能动态分配**

类对象只能通过new运算符建立在堆空间中，不能静态分配，即不能直接调用类的构造函数

private 构造函数(不可行)

new运算符过程分为两步，C++提供new运算符的重载，其实只允许重载[operator](https://so.csdn.net/so/search?q=operator&spm=1001.2101.3001.7020) new( )函数，而operator（）函数用于内存分配，无法提供构造函数功能。因此，将构造函数设为private不可行

private 析构函数（无法实现继承）

从另外一个角度分析，对象静态分配时，是由编译器负责分配内存空间的，调用构造函数在栈空间中构造对象。当对象使用完毕，编译器又会调用析构函数来释放栈空间中的类对象。如果编译器无法调用类的析构函数，会怎样呢？其实，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性（其实不光是析构函数，只要是非静态的函数，编译器都会进行检查）。如果类的析构函数在类外部无法访问，则编译器拒绝在栈空间上为类对象分配内存。因此，可以将析构函数设为private，这样就无法在栈上建立类对象了。

```c++
class A  
{  
public:  
     A(){}  
     void destory(){delete this;}  
private:  
     ~A(){}  
};  
```

这样在使用A a; 来建立对象时会编译错误，提示析构函数无法访问。这样就只能用new运算符来建立对象了，并且构造函数可以调用，因为是public。但是必须提供一个destory函数来实现内存空间的释放。**上面的方法虽然能实现只能动态建立对象，但是有一个缺点：无法实现继承。**因为如果A作为基类的话，则析构函数通常要设为virtual，然后在子类中被重写，以实现多态。因此析构函数不能设为private。为了解决这个问题该怎么办呢？

构造、析构函数设为 protected

将析构函数设为protected，类外无法访问protected成员，但是子类可以访问。完美解决问题。实现如下：

```c++
class A  
{  
protected:  
     A(){}  
     ~A(){}  
public:  
     static A* create(){return new A();}  
     void destory(){delete this;}  
}; 
```

增加create函数是为了让代码看起来更统一，调用create函数在堆上创建类A对象，调用destory函数来释放内存。

**只能静态分配**

只有使用new运算符，对象才会被建立在堆上。因此只要限制new运算符就可以实现类对象只能建立在栈上。可以将new运算符设为私有，实现如下：

```c++
class A  
{  
private:  
     void* operator new(size_t t){}          //注意函数的第一个参数和返回值都是固定的  
     void operator delete(void* ptr){}       //重载了new就需要重载delete  
public:  
     A(){}  
     ~A(){}  
```

### 函数调用

#### 函数调用过程

```c
int f(int a, int b, int c,int d,int e,int f,int g, int h) {
    int sum = 0;
    sum = a + b + c + d + e + f  + g + h;
    return sum;
}

int main() {
    int x = f(1, 2, 3, 4, 5, 6, 7, 8);
    return 0;
}
```

```assembly
f(int, int, int, int, int, int, int, int):
# 3. 建立它自己的栈帧
 push   rbp
# 4 然后ESP的内容赋值给了EBP。这使得函数的参数可以通过对EBP附加一个偏移量得到，而栈寄存器ESP便可以空出来做其他事情
 mov    rbp,rsp
 
# 5 为寄存器的参数分配空间（非寄存器的已经分配过空间了）
 mov    DWORD PTR [rbp-0x14],edi
 mov    DWORD PTR [rbp-0x18],esi
 mov    DWORD PTR [rbp-0x1c],edx
 mov    DWORD PTR [rbp-0x20],ecx
 mov    DWORD PTR [rbp-0x24],r8d
 mov    DWORD PTR [rbp-0x28],r9d
 
 # int sum = 0
 # 6 为局部变量分配空间最后，如果需要，保存寄存器EBX，ESI和EDI的值。
 mov    DWORD PTR [rbp-0x4],0x0
 
# 累加
 mov    edx,DWORD PTR [rbp-0x14]
 mov    eax,DWORD PTR [rbp-0x18]
 add    edx,eax
 mov    eax,DWORD PTR [rbp-0x1c]
 add    edx,eax
 mov    eax,DWORD PTR [rbp-0x20]
 add    edx,eax
 mov    eax,DWORD PTR [rbp-0x24]
 add    edx,eax
 mov    eax,DWORD PTR [rbp-0x28]
 add    edx,eax
 mov    eax,DWORD PTR [rbp+0x10]
 add    edx,eax
 mov    eax,DWORD PTR [rbp+0x18]
 add    eax,edx
 mov    DWORD PTR [rbp-0x4],eax
 
 # 7 返回值保存在 eax
 mov    eax,DWORD PTR [rbp-0x4]
 
 # 8 消除栈帧
 pop    rbp
 ret    
 
main:
# 对应 {
 push   rbp
 mov    rbp,rsp
 sub    rsp,0x10
 
# 0. 这里可能要保持一些寄存器现场 EAX、EDX、ECX
 
# 1. 参数压栈 前 6 个寄存器，后面的压栈，从后面往前
 push   0x8
 push   0x7
 mov    r9d,0x6
 mov    r8d,0x5
 mov    ecx,0x4
 mov    edx,0x3
 mov    esi,0x2
 mov    edi,0x1
 
# 2. call 当call指令执行的时候，EIP指令指针寄存器的内容被压入栈中。因为EIP寄存器是指向main中的下一条指令，所以现在返回地址就在栈顶了。在call指令执行完之后，下一个执行周期将从名为foo的标记处开始，不是直接执行下面的 add
 call   401106 <f(int, int, int, int, int, int, int, int)>
 
# 弹出压入栈的两个参数
 add    rsp,0x10
 
# 返回值
 mov    DWORD PTR [rbp-0x4],eax
 
 
# 对应 return 0
 mov    eax,0x0
 
 # 对应 }
 # leave 等效 mov esp, ebp + pop ebp
 leave  
 ret    
 cs nop WORD PTR [rax+rax*1+0x0]
 nop    DWORD PTR [rax+0x0]
```

**一个典型的栈帧**

![图片](https://mmbiz.qpic.cn/mmbiz_png/TufFCFqd0g2MoF9ibbdTtrPb3jano20opbSPsyicsSTzNAjGVOeqsibkmxPuWEfxjiaY5CYYC4G09EQC8918Ys1sPQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

​              图 1

图1是一个典型的栈帧，图中，栈顶在上，地址空间往下增长。
这是如下一个函数调用时的栈的内容：

```
int foo(int arg1, int arg2, int arg3);
```

并且，foo有两个局部的int变量（4个字节）。在这个简化的场景中，main调用foo，而程序的控制仍在foo中。这里，main是调用者（caller），foo是被调用者（callee）。

**ESP被foo使用来指示栈顶。EBP相当于一个“基准指针”**。从main传递到foo的参数以及foo本身的局部变量都可以通过这个基准指针为参考，加上偏移量找到。
由于被调用者允许使用EAX，ECX和EDX寄存器，所以如果调用者希望保存这些寄存器的值，就必须在调用子函数之前显式地把他们保存在栈中。另一方面，如果除了上面提到的几个寄存器，被调用者还想使用别的寄存器，比如EBX，ESI和EDI，那么，被调用者就必须在栈中保存这些被额外使用的寄存器，并在调用返回前回复他们。也就是说，如果被调用者只使用约定的EAX，ECX和EDX寄存器，他们由调用者负责保存并回复，但如果被调用这还额外使用了别的寄存器，则必须有他们自己保存并回复这些寄存器的值。

传递给foo的参数被压到栈中，**最后一个参数先进栈，所以第一个参数是位于栈顶的**。

foo中声明的局部变量以及函数执行过程中需要用到的一些临时变量也都存在栈中。
**小于等于4个字节的返回值会被保存到`EAX`中**，如果大于4字节，小于8字节，那么EDX也会被用来保存返回值。如果返回值占用的空间还要大，那么调用者会向被调用者传递一个额外的参数，这个额外的参数指向将要保存返回值的地址。用C语言来说，就是函数调用：

```
x = foo(a, b, c);
```

被转化为：

```
foo(&x, a, b, c);
```

注意，这仅仅在返回值占用大于**8个字节**时才发生。有的编译器不用EDX保存返回值，所以当返回值大于4个字节时，就用这种转换。
当然，并不是所有函数调用都直接赋值给一个变量，还可能是直接参与到某个表达式的计算中，如：

```
m = foo(a, b, c) + foo(d, e, f);
```

有或者作为另外的函数的参数， 如：

```
fooo(foo(a, b, c), 3);
```

这些情况下，foo的返回值会被保存在一个临时变量中参加后续的运算，所以，foo(a, b, c)还是可以被转化成**foo(&tmp, a, b, c)**。

让我们一步步地看一下在c函数调用过程中，一个栈帧是如何建立及消除的。

**函数调用前调用者的动作**

在我们的例子中，调用者是main，它准备调用函数foo。在函数调用前，main正在用ESP和EBP寄存器指示它自己的栈帧。

首先，main把EAX，ECX和EDX压栈。这是一个可选的步骤，只在这三个寄存器内容需要保留的时候执行此步骤。
接着，main把传递给foo的参数一一进栈，最后的参数最先进栈。例如，我们的函数调用是：

```
a = foo(12, 15, 18);
```

相应的汇编语言指令是：

```
push dword 18
push dword 15
push dword 12
```

最后，main用call指令调用子函数：

```
call foo
```

**当call指令执行的时候，EIP指令指针寄存器的内容被压入栈中**。因为EIP寄存器是指向main中的下一条指令，所以现在返回地址就在栈顶了。在call指令执行完之后，下一个执行周期将从名为foo的标记处开始。
图2展示了call指令完成后栈的内容。图2及后续图中的**粗线**指示了函数调用前栈顶的位置。我们将会看到，当整个函数调用过程结束后，栈顶又回到了这个位置。

![图片](https://mmbiz.qpic.cn/mmbiz_png/TufFCFqd0g2MoF9ibbdTtrPb3jano20op8bXCE6Vvnd8w1ywqdpjIgTMhPocJvODficgkAJlFCSL0QEZlDItDZag/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

​             图 2

**被调用者在函数调用后的动作**

当函数foo，也就是被调用者取得程序的控制权，它**必须做3件事**：

* 建立它自己的栈帧
* 为局部变量分配空间
* 最后，如果需要，保存寄存器EBX，ESI和EDI的值。

首先foo必须建立它自己的栈帧。EBP寄存器现在正指向main的栈帧中的某个位置，这个值必须被保留，因此，EBP进栈。然后ESP的内容赋值给了EBP。这使得函数的参数可以通过对EBP附加一个偏移量得到，而栈寄存器ESP便可以空出来做其他事情。如此一来，几乎所有的c函数都由如下两个指令开始：

```
push ebp
mov ebp, esp
```

此时的栈入图3所示。在这个场景中，第一个参数的地址是EBP加8，因为main的EBP和返回地址各在栈中占了4个字节。

![图片](https://mmbiz.qpic.cn/mmbiz_png/TufFCFqd0g2MoF9ibbdTtrPb3jano20ophtA6k18SUiblKOTYaOybpsAIm04WDyVd8zzicmlwYrO3icHOOH4ic408IQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

​                图 3

下一步，foo必须为它的局部变量分配空间，同时，也必须为它可能用到的一些临时变量分配空间。比如，foo中的一些C语句可能包括复杂的表达式，其子表达式的中间值就必须得有地方存放。这些存放中间值的地方同城被称为临时的，因为他们可以为下一个复杂表达式所复用。为说明方便，我们假设我们的foo中有两个int类型（每个4字节）的局部变量，需要额外的12字节的临时存储空间。简单地把栈指针减去20便为这20个字节分配了空间：

```
sub esp, 20
```

现在，局部变量和临时存储都可以通过基准指针EBP加偏移量找到了。
最后，如果foo用到EBX，ESI和EDI寄存器，则它f必须在栈里保存它们。结果，现在的栈如图4所示。

![图片](https://mmbiz.qpic.cn/mmbiz_png/TufFCFqd0g2MoF9ibbdTtrPb3jano20opUomKNshDkBIfZr5UVbOJIBIzllqgFJmibPSeyFSBkhapKAjrZGKeHYw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

​              图 4

foo的函数体现在可以执行了。这其中也许有进栈、出栈的动作，栈指针ESP也会上下移动，但EBP是保持不变的。这意味着我们可以一直用[EBP+8]找到第一个参数，而不管在函数中有多少进出栈的动作。函数foo的执行也许还会调用别的函数，甚至递归地调用foo本身。然而，只要EBP寄存器在这些子调用返回时被恢复，就可以继续用EBP加上偏移量的方式访问实际参数，局部变量和临时存储。

**被调用者返回前的动作**

在把程序控制权返还给调用者前，被调用者foo必须先把返回值**保存在`EAX`寄存器**中。我们前面已经讨论过，当返回值占用多于4个或8个字节时，接收返回值的变量地址会作为一个额外的指针参数被传到函数中，而函数本身就不需要返回值了。这种情况下，被调用者直接通过内存拷贝把返回值直接拷贝到接收地址，从而省去了一次通过栈的中转拷贝。
其次，foo必须恢复EBX，ESI和EDI寄存器的值。如果这些寄存器被修改，正如我们前面所说，我们会在foo执行开始时把它们的**原始值压入栈中**。如果ESP寄存器指向如图4所示的正确位置，寄存器的原始值就可以出栈并恢复。可见，在foo函数的执行过程中正确地跟踪ESP是多么的重要————也就是说，进栈和出栈操作的次数必须保持平衡。
这两步之后，我们不再需要foo的局部变量和临时存储了，我们可以通过下面的指令消除栈帧：

```
mov esp, ebp
pop ebp
```

其结果就是现在栈里的内容跟图2中所示的栈完全一样。现在可以执行返回指令了。从栈里弹出返回地址，赋值给EIP寄存器。栈如图5所示：

![图片](https://mmbiz.qpic.cn/mmbiz_png/TufFCFqd0g2MoF9ibbdTtrPb3jano20op4sPKhic325cvaYERHmibKxGwSWtRc3ah65PhiaVLpUgUCia7wZLbicnnyOw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

i386指令集有一条**“leave”**指令，它与上面提到的mov和pop指令所作的动作完全相同。所以，C函数通常以这样的指令结束：

```
leave
ret
```

**调用者在返回后的动作**

在程序控制权返回到调用者（也就是我们例子中的main）后，栈如图5所示。这时，传递给foo的参数通常已经不需要了。我们可以把3个参数一起弹出栈，这可以通过把栈指针加12（=3个4字节）实现：

```
add esp, 12
```

如果在函数调用前，EAX，ECX和EDX寄存器的值被保存在栈中，调用者main函数现在可以把它们弹出。这个动作之后，栈顶就回到了我们开始整个函数调用过程前的位置，也就是图5中粗线的位置。

看个具体的实例：

这段代码反汇编后，代码是什么呢？

```
 1#include <stdio.h>
 2long test(int a, int b){
 3     a = a + 3;
 4     b = b + 5;
 5     return a + b;
 6}
 7
 8int main(int argc, char* argv[]){
 9    printf("%d", test(10,90));
10    return 0;
11}
```

先来看一个概貌：

```
 116:   int main(int argc, char* argv[])
 217:   {
 300401070   push        ebp
 400401071   mov         ebp,esp
 500401073   sub         esp,40h
 600401076   push        ebx
 700401077   push        esi
 800401078   push        edi
 900401079   lea         edi,[ebp-40h]
100040107C   mov         ecx,10h
1100401081   mov         eax,0CCCCCCCCh
1200401086   rep stos    dword ptr [edi]
1318:        printf("%d",test(10,90));
1400401088   push        5Ah
150040108A   push        0Ah
160040108C   call        @ILT+0(test) (00401005)
1700401091   add         esp,8
1800401094   push        eax
1900401095   push        offset string "%d" (0042201c)
200040109A   call        printf (004010d0)
210040109F   add         esp,8
2219:        return 0;
23004010A2   xor         eax,eax
2420:   }
```

下面来解释一下，

![图片](https://mmbiz.qpic.cn/mmbiz_png/TufFCFqd0g2gIGUg7lMl7cABgyfklHKZJvXzpia3gYKRnYTwpmN6x6xHvjLw0ibNVJJL612oTdZTpNLFFOCgasVQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)
开始进入Main函数 esp=0x12FF84  ebp=0x12FFC0
完成椭圆形框起来的部分：

```
00401070   push        ebp
```

**ebp的值入栈，保存现场(调用现场**，从test函数看，如红线所示，即保存的0x12FF80用于从test函数堆栈返回到main函数)：

```
00401071    mov        ebp,esp
```

此时ebp＝0x12FF80 **此时ebp就是“当前函数堆栈”的基址 以便访问堆栈中的信息；还有就是从当前函数栈顶返回到栈底：**

```
00401073     sub        esp,40h  
```

函数使用的堆栈，默认64个字节，堆栈上就是16个横条（密集线部分）此时esp=0x12FF40。
在上图中，上面密集线是test函数堆栈空间，下面是Main的堆栈空间(补充，其实这个就叫做 **Stack Frame**)：

```
100401076   push        ebx
200401077   push        esi
300401078   push        edi    入栈 
400401079   lea         edi,[ebp-40h]
50040107C   mov         ecx,10h
600401081   mov         eax,0CCCCCCCCh
700401086   rep stos    dword ptr [edi]      
```

初始化用于该函数的栈空间为0XCCCCCCCC，即从0x12FF40~0x12FF80所有的值均为0xCCCCCCCC：

```
118:        printf("%d",test(10,90));
200401088   push        5Ah    参数入栈 从右至左 先90  后10
30040108A   push        0Ah 
40040108C   call        @ILT+0(test) (00401005)    
```

函数调用，转向eip 00401005 。
**注意，此时仍入栈，入栈的是call test 指令下一条指令的地址00401091下一条指令是add esp,8。**
@ILT+0(?test@@YAJHH@Z):

```
00401005   jmp       test (00401020)  
```

即转向被调函数test：

```
 18:    long test(int a,int b)
 29:    {
 300401020   push        ebp
 400401021   mov         ebp,esp           
 500401023   sub         esp,40h
 600401026   push        ebx
 700401027   push        esi
 800401028   push        edi
 900401029   lea         edi,[ebp-40h]
100040102C   mov         ecx,10h
1100401031   mov         eax,0CCCCCCCCh
1200401036   rep stos    dword ptr [edi]       //这些和上面一样
1310:        a = a + 3;                                    
1400401038   mov         eax,dword ptr [ebp+8]     //ebp=0x12FF24 加8 [0x12FF30]即取到了参数10
150040103B   add         eax,3
160040103E   mov         dword ptr [ebp+8],eax
1711:        b = b + 5;
1800401041   mov         ecx,dword ptr [ebp+0Ch]
1900401044   add         ecx,5
2000401047   mov         dword ptr [ebp+0Ch],ecx
2112:        return a + b;
220040104A   mov         eax,dword ptr [ebp+8]
230040104D   add         eax,dword ptr [ebp+0Ch]  //最后的结果保存在eax, 结果得以返回
2413:   }
2500401050   pop         edi                 
2600401051   pop         esi
2700401052   pop         ebx
2800401053   mov         esp,ebp     //esp指向0x12FF24, test函数的堆栈空间被放弃，从当前函数栈顶返回到栈底
2900401055   pop         ebp           //此时ebp=0x12FF80, 恢复现场  esp=0x12FF28
3000401056   ret                          ret负责栈顶0x12FF28之值00401091弹出到指令寄存器中，esp=0x12FF30
```

因为win32汇编一般用eax返回结果 所以如果最终结果不是在eax里面的话 还要把它放到eax。

注意，从被调函数返回时，是弹出EBP,恢复堆栈到函数调用前的地址，弹出返回地址到EIP以继续执行程序。

从test函数返回，执行：

```
00401091   add         esp,8      
```

清栈，清除两个压栈的参数10 90 调用者main负责。
**(所谓__cdecl调用由调用者负责恢复栈，调用者负责清理的只是入栈的参数，test函数自己的堆栈空间自己返回时自己已经清除，靠！一直理解错)**

```
100401094   push        eax          //入栈，计算结果108入栈，即printf函数的参数之一入栈
200401095   push        offset string "%d" (0042201c)     //入栈，参数 "%d"  当然其实是％d的地址
30040109A   call        printf (004010d0)      //函数调用 printf("%d",108) 因为printf函数时
40040109F   add         esp,8       //清栈，清除参数 ("%d", 108)
519:        return 0;           
6004010A2   xor         eax,eax     //eax清零
720:   }    
```

main函数执行完毕 此时esp=0x12FF34  ebp=0x12FF80：

```
1004010A4   pop         edi
2004010A5   pop         esi
3004010A6   pop         ebx
4004010A7   add         esp,40h    //为啥不用mov esp, ebp? 是为了下面的比较
5004010AA   cmp         ebp,esp   //比较，若不同则调用chkesp抛出异常
6004010AC   call        __chkesp (00401150)   
7004010B1   mov         esp,ebp   
8004010B3   pop         ebp          //ESP=0X12FF84  
```

EBP=0x12FFC0 尘归尘 土归土 一切都恢复最初的平静了 :)

```
004010B4   ret
```

另：

1. 如果函数调用方式是**__stdcall**不同之处在于main函数call 后面没有了add esp, 8；test函数最后一句是 ret 8  (由test函数清栈, ret 8意思是执行ret后，esp+8)。
2. 运行过程中0x12FF28 保存了指令地址 00401091是怎么保存的？栈每个空间保存4个字节（粒度4字节） 例如下一个栈空间0x12FF2C保存参数10，因此：

```
10x12FF28 0x12FF29 0x12FF2A 0x12FF2B   
2   91       10       40       00      
```

little-endian  认为其读的第一个字节为最小的那位上的数。

3. char a[] = "abcde"
 对局部字符数组变量（栈变量）赋值，是利用寄存器从全局数据内存区把字符串“abcde”拷贝到栈内存中的。
4. int szNum[5] = { 1, 2, 3, 4, 5 }; 栈中是如何分布的？

```
100401798   mov         dword ptr [ebp-14h],1
20040179F   mov         dword ptr [ebp-10h],2
3004017A6   mov         dword ptr [ebp-0Ch],3
4004017AD   mov         dword ptr [ebp-8],4
5004017B4   mov         dword ptr [ebp-4],5
```

可以看出来是从右边开始入栈，所以是 5 4 3 2 1 入栈，

```
1int *ptrA = (int*)(&szNum+1);
2int *ptrB = (int*)((int)szNum + 1);
3std::cout<< ptrA[-1] << *ptrB << std::endl;
```

结果如何？

```
128:       int *ptrA = (int*)(&szNum+1);
2004017BB   lea         eax,[ebp]
3004017BE   mov         dword ptr [ebp-18h],eax
```

&szNum是指向数组指针；加1是加一个数组宽度；&szNum+1指向移动5个int单位之后的那个地方， 就是把EBP的地址赋给指针；
ptrA[-1]是回退一个int*宽度，即ebp-4；

```
129:       int *ptrB = (int*)((int)szNum + 1);
2004017C1   lea         ecx,[ebp-13h]
3004017C4   mov         dword ptr [ebp-1Ch],ecx
```

如果上面是指针算术，那这里就是地址算术，只是首地址+1个字节的offset，即ebp-13h给指针。实际保存是这样的：

```
01 00 00 00 02 00 00 00
ebp-14h ebp-13h ebp-10h
```

注意，是int*类型的，最后获得的是 00 00 00 02，由于Little-endian, 实际上逻辑数是02000000，转换为十进制数就为33554432，最后输出533554432。

#### 函数调用过程栈的变化，返回值和参数变量哪个先入栈？

返回值是局部变量，所以比参数变量后入栈，但是它最终的值应该是放在寄存器里的

函数调用过程中

1第一个进栈的是（主函数中的） 调用处的下一条指令（即函数调用语句的下一条可执行语句） 的地址；

2 然后是函数的各个参数，而在大多数C/C++编译器中，在函数调用的过程中，函数的参数是 由右向左入栈的；

3 然后是函数内部的局部变量（注意static变量是不入栈的）；



在函数调用结束（函数运行结束）后

1 局部变量最先出栈

2然后是参数

3最后栈顶指针指向最开始存的指令地址，程序由该点继续运行。



 **函数调用方式决定了函数参数入栈的顺序，是由调用者函数还是被调用函数负责清除栈中的参数等问题**，而函数名修饰规则决定了编译器使用何种名字修饰方式来区分不同的函数，如果函数之间的调用约定不匹配或者名字修饰不匹配就会产生以上的问题。

**函数的调用方式**

在C语言中，假设我们有这样的一个函数： int function(int a,int b)

调用时只要用result = function(1,2)这样的方式就可以使用这个函数。但是，当高级语言被编译成计算机可以识别的机器码时，有一个问题就凸现出来：在CPU中，计算机没有办法知道一个函数调用需要多少个、什么样的参数，也没有硬件可以保存这些参数。也就是说，**计算机不知道怎么给这个函数传递参数，传递参数的工作必须由函数调用者和函数本身来协调。为此，计算机提供了一种被称为栈的数据结构来支持参数传递。**

栈是一种先进后出的数据结构，栈有一个存储区、一个栈顶指针。栈顶指针指向堆栈中第一个可用的数据项（被称为栈顶）。用户可以在栈顶上方向栈中加入数据，这个操作被称为压栈(Push)，压栈以后，栈顶自动变成新加入数据项的位置，栈顶指针也随之修改。用户也可以从堆栈中取走栈顶，称为弹出栈(pop)，弹出栈后，栈顶下的一个元素变成栈顶，栈顶指针随之修改。函数调用时，调用者依次把参数压栈，然后调用函数，函数被调用以后，在堆栈中取得数据，并进行计算。函数计算结束以后，或者调用者、或者函数本身修改堆栈，使堆栈恢复原装。

在参数传递中，有两个很重要的问题必须得到明确说明：

* 当参数个数多于一个时，按照什么顺序把参数压入堆栈
* 函数调用后，由谁来把堆栈恢复原装

在高级语言中，通过函数调用约定来说明这两个问题。常见的调用约定有：

* stdcall
* cdecl
* fastcall
* thiscall
* naked call

**stdcall调用约定**

stdcall很多时候被称为pascal调用约定，因为pascal是早期很常见的一种教学用计算机程序设计语言，其语法严谨，使用的函数调用约定就是stdcall。在Microsoft C++系列的C/C++编译器中，常常用PASCAL宏来声明这个调用约定，类似的宏还有WINAPI和CALLBACK。

stdcall调用约定声明的语法为(以前文的那个函数为例）：int __stdcall function(int a,int b)

stdcall的调用约定意味着：

* 参数从右向左压入堆栈
* 函数自身修改堆栈
* 函数名自动加前导的下划线，后面紧跟一个@符号，其后紧跟着参数的尺寸

以上述这个函数为例，参数b首先被压栈，然后是参数a，函数调用function(1,2)调用处

翻译成汇编语言将变成：

1. push 2 第二个参数入栈
2. push 1 第一个参数入栈
3. call function 调用参数，注意此时自动把cs:eip入栈

而对于函数自身，则可以翻译为：

1. push ebp 保存ebp寄存器，该寄存器将用来保存堆栈的栈顶指针，可以在函数退出时恢复mov ebp,esp 保存堆栈指针mov eax,[ebp + 8H] 堆栈中ebp指向位置之前依次保存有ebp,cs:eip,a,b,ebp +8指向a
2. add eax,[ebp + 0CH] 堆栈中ebp + 12处保存了b
3. mov esp,ebp 恢复esp
4. pop ebp
5. ret 8

而在编译时，这个函数的名字被翻译成_function@8

注意不同编译器会插入自己的汇编代码以提供编译的通用性，但是大体代码如此。其中在函数开始处保留esp到ebp中，在函数结束恢复是编译器常用的方法。

从函数调用看，2和1依次被push进堆栈，而在函数中又通过相对于ebp(即刚进函数时的堆栈指针）的偏移量存取参数。函数结束后，ret 8表示清理8个字节的堆栈，函数自己恢复了堆栈。

**cdecl调用约定**

 cdecl调用约定又称为C调用约定，是C语言缺省的调用约定，它的定义语法是：

```c
int function (int a ,int b) //不加修饰就是C调用约定
int __cdecl function(int a,int b)//明确指出C调用约定
```

在写本文时，出乎我的意料，发现 cdecl 调用约定的参数压栈顺序是和 stdcall 是一样的，**参数首先由右向左压入堆栈。所不同的是，函数本身不清理堆栈，调用者负责清理堆栈。由于这种变化，C调用约定允许函数的参数的个数是不固定的**，这也是C语言的一大特色。（gcc 从右向左压栈汇编是 push、clang 从左向右应该直接 压栈汇编是 mov esp xxx，好像直接分析出来不定参数有几个）

对于前面的function函数，使用cdecl后的汇编码变成：

调用处

1. push 1
2. push 2
3. call function
4. add esp,8 注意：这里调用者在恢复堆栈

被调用函数_function处push ebp 保存ebp寄存器，该寄存器将用来保存堆栈的栈顶指针，可以在函数退出时恢复

1. mov ebp,esp 保存堆栈指针
2. mov eax,[ebp + 8H] 堆栈中ebp指向位置之前依次保存有ebp,cs:eip,a,b,ebp +8指向a
3. add eax,[ebp + 0CH] 堆栈中ebp + 12处保存了b
4. mov esp,ebp 恢复esp
5. pop ebp
6. ret 注意，这里没有修改堆栈

MSDN中说，该修饰自动在函数名前加前导的下划线，因此函数名在符号表中被记录为_function，但是我在编译时似乎没有看到这种变化。**由于参数按照从右向左顺序压栈，因此最开始的参数在最接近栈顶的位置，因此当采用不定个数参数时，第一个参数在栈中的位置肯定能知道，只要不定的参数个数能够根据第一个后者后续的明确的参数确定下来，就可以使用不定参数**，例如对于CRT中的sprintf函数，定义为：

int sprintf(char*buffer,const char* format,...)

由于所有的不定参数都可以通过format确定，因此使用不定个数的参数是没有问题的。

**fastcall**

fastcall调用约定和stdcall类似，它意味着：

函数的第一个和第二个DWORD参数（或者尺寸更小的）通过ecx和edx传递，其他参数通过从右向左的顺序压栈被调用函数清理堆栈

函数名修改规则同stdcall

其声明语法为：int fastcall function(int a,int b)

**thiscall**

thiscall是唯一一个不能明确指明的函数修饰，因为thiscall不是关键字。它是C++类成员函数缺省的调用约定。由于成员函数调用还有一个this指针，因此必须特殊处理，thiscall意味着：

* 参数从右向左入栈
* 如果参数个数确定，this指针通过ecx传递给被调用者；如果参数个数不确定，this指针在所有参数压栈后被压入堆栈。
* 对参数个数不定的，调用者清理堆栈，否则函数自己清理堆栈

为了说明这个调用约定，定义如下类和使用代码：

```c++
class A {
public:
    int function1(int a,int b);
    int function2(int a,...);
};

int A::function1 (int a,int b) {
 return a+b;
}

＃include

int A::function2(int a,...) {
 va_list ap;
 va_start(ap,a);

 int i;
 int result = 0;

    for(i = 0 i < a i ++) {
     result += va_arg(ap,int);
    }
    
    return result;
}

void callee() {
 A a;
 a.function1 (1,2);
 a.function2(3,1,2,3);
}
```

callee函数被翻译成汇编后就变成：

```assembly
//函数function1调用

0401C1D push 2

00401C1F push 1

00401C21 lea ecx,[ebp-8]

00401C24 call function1 注意，这里this没有被入栈

//函数function2调用

00401C29 push 3

00401C2B push 2

00401C2D push 1

00401C2F push 3

00401C31 lea eax,[ebp-8] 这里引入this指针

00401C34 push eax

00401C35 call function2

00401C3A add esp,14h
```

可见，对于参数个数固定情况下，它类似于stdcall，不定时则类似cdecl

**naked call**

这是一个很少见的调用约定，一般程序设计者建议不要使用。编译器不会给这种函数增加初始化和清理代码，更特殊的是，你不能用return返回返回值，只能用插入汇编返回结果。这一般用于实模式驱动程序设计，假设定义一个求和的加法程序，可以定义为：

```
__declspec(naked) int add(int a,int b)
{
    __asm mov eax,a
    __asm add eax,b
    __asm ret
}
```

注意，这个函数没有显式的return返回值，返回通过修改eax寄存器实现，而且连退出函数的ret指令都必须显式插入。上面代码被翻译成汇编以后变成：

```
mov eax,[ebp+8]

add eax,[ebp+12]

ret 8
```

注意这个修饰是和__stdcall及cdecl结合使用的，前面是它和cdecl结合使用的代码，对于和stdcall结合的代码，则变成：

```
declspec(naked) int __stdcall function(int a,int b)
{

__asm mov eax,a

__asm add eax,b

__asm ret 8 //注意后面的8

}
```

至于这种函数被调用，则和普通的cdecl及stdcall调用函数一致。函数调用约定导致的常见问题如果定义的约定和使用的约定不一致，则将导致堆栈被破坏，导致严重问题，下面是两种常见的问题：

函数原型声明和函数体定义不一致

DLL导入函数时声明了不同的函数约定

以后者为例，假设我们在dll种声明了一种函数为：

```
__declspec(dllexport) int func(int a,int b);//注意，这里没有stdcall，使用的是

cdecl
```

使用时代码为：

```
typedef int (*WINAPI DLLFUNC)func(int a,int b);

hLib = LoadLibrary(...);

DLLFUNC func = (DLLFUNC)GetProcAddress(...)//这里修改了调用约定

result = func(1,2);//导致错误
```

由于调用者没有理解WINAPI的含义错误的增加了这个修饰，上述代码必然导致堆栈被破坏，MFC在编译时插入的checkesp函数将告诉你，堆栈被破坏了。

#### C++函数调用的压栈过程

从代码入手，解释这个过程：

```plaintext
#include <iostream>
using namespace std;

int f(int n) 
{
    cout << n << endl;
    return n;
}

void func(int param1, int param2)
{
    int var1 = param1;
    int var2 = param2;
    printf("var1=%d,var2=%d", f(var1), f(var2));//如果将printf换为cout进行输出，输出结果则刚好相反
}

int main(int argc, char* argv[])
{
    func(1, 2);
    return 0;
}
//输出结果
//2
//1
//var1=1,var2=2
```

当函数从入口函数main函数开始执行时，编译器会将我们操作系统的运行状态，main函数的返回地址、main的参数、mian函数中的变量、进行依次压栈；

当main函数开始调用func()函数时，编译器此时会将main函数的运行状态进行压栈，再将func()函数的返回地址、func()函数的参数从右到左、func()定义变量依次压栈；

当func()调用f()的时候，编译器此时会将func()函数的运行状态进行压栈，再将的返回地址、f()函数的参数从右到左、f()定义变量依次压栈

从代码的输出结果可以看出，函数f(var1)、f(var2)依次入栈，而后先执行f(var2)，再执行f(var1)，最后打印整个字符串，将栈中的变量依次弹出，最后主函数返回。

[66.2、文字化表述](https://interviewguide.cn/#/Doc/Knowledge/C++/基础语法/基础语法?id=662、文字化表述)

函数的调用过程：

1）从栈空间分配存储空间

2）从实参的存储空间复制值到形参栈空间

3）进行运算

形参在函数未调用之前都是没有分配存储空间的，在函数调用结束之后，形参弹出栈空间，清除形参空间。

数组作为参数的函数调用方式是地址传递，形参和实参都指向相同的内存空间，调用完成后，形参指针被销毁，但是所指向的内存空间依然存在，不能也不会被销毁。

当函数有多个返回值的时候，不能用普通的 return 的方式实现，需要通过传回地址的形式进行，即地址/指针传递。

#### 参数计算顺序和压栈顺序

看看两个知识点：**参数的计算顺序与压栈顺序**。

c/c++中规定了函数参数的压栈顺序是从右至左，函数调用协议会影响函数参数的入栈方式、栈内数据的清除方式、编译器函数名的修饰规则等。

**参数传递和命名约定**

Visual C/C++ 编译器支持以下调用约定。

| 关键字       | 堆栈清理 | 参数传递                                             |
| :----------- | :------- | :--------------------------------------------------- |
| __cdecl      | Caller   | 以相反的顺序（从右到左）将参数压入堆栈               |
| __clrcall    | n/a      | 按顺序（从左到右）将参数加载到 CLR 表达式堆栈        |
| __stdcall    | Callee   | 以相反的顺序（从右到左）将参数压入堆栈               |
| __fastcall   | Callee   | 存储在寄存器中，然后压入堆栈                         |
| __thiscall   | Callee   | 压入堆栈；此指针存储在 ECX 中                        |
| __vectorcall | Callee   | 存储在寄存器中，然后以相反的顺序（从右到左）压入堆栈 |

通常情况下c/c++默认入栈方式`：__cdel`，也就是以右到左将参数压入堆栈，Windows api使用的是`__stdcall`方式，`__fastcall`适用于对性能要求较高的场合。

**为什么要从右往左入栈**？

每个参数都有自己的地址，但不定长参数无法确认地址，并且函数参数的个数也不确定，C/C++中规定了函数参数的压栈顺序是从右至左，对于含有不定参数的printf函数，其原型是`printf（const char* format,…）；`其中format确定了printf的参数（通过format的%个数判断）。

假设是从左至右压栈，那么先入栈的是format，然后依次入栈未知参数，此时想要知道参数个数，就必须找到format，而要找到format，就必须知道参数个数，这样就会陷入一个死胡同里面了。

而c/c++中规定参数压栈为从右至左的顺序，这种方式对于不定参数，最后入栈的是参数个数，只需要取栈顶就可以得到。

我们举一个了例子如下：

```c++
#include <iostream>
using namespace std;

void fun(int x, int y, int z)
{
    cout << x << &x << endl;
    cout << y << &y << endl;
    cout << z << &z << endl;
}

int main(int argc, char *argv[])
{
    fun(1, 2, 3);
    system("pause");
    return 0;
}
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/wqfIPAmgib2U3sasevo5QcmWd9RtywPeEXcI7c4hXMibqkWIO95W0xzQYZzKay80610vcXt4ExFm0htR4j0LVWSA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

我们知道先入栈的占高地址，从结果看出入栈的顺序依次为`z->y->x`，即压栈顺序从右至左。

**参数计算顺序**

先执行哪个参数和参数的计算顺序有关，而c/c++中没有规定函数参数的计算顺序，这个和编译器有关，代码参数的计算顺序决定了实际输出。

```c++
int main () {
 int a = 2;
 printf("%d, %d, %d", a, (a = (a + 2)), (a = (a + 3)));
 system("pause");
 return 0;
}
//win10 + VS2019 输出: 7, 7, 7
//clang输出结果 2 4 7 
```

vs的计算顺序是从右至左，clang的计算顺序是从左至右，具体的计算流程分析就很简单了。

对于c/c++函数参数的读取顺序，参数入栈时顺序从右向左入栈，但是在入栈前会先把参数列表里的表达式从右向左算一遍得到表达式的结果，最后再把这些运算结果统一入栈。

在参数入栈前，编译器会先把参数的表达式都处理掉，对于一般的操作来说，参数入栈时取值是直接从变量的内存地址里取的，但是对于a++操作，编译器会开辟一个缓冲区来保存当前a的值，然后再对a继续操作，最后参数入栈时的取值是从缓冲区取，而不是直接从a的内存地址里取。

**结论**

因为函数参数的计算顺序依照编译器的实现，所以在编码中避免编写诸如 `fun(++x, x+y)`这种的程序，其在不同的平台得到的结果可能不一样，但是在面试中可能遇到这样的问题，所以我们需要知其然更要知所以然。

#### C++中将临时变量作为返回值时的处理过程

首先需要明白一件事情，临时变量，在函数调用过程中是被压到程序进程的栈中的，当函数退出时，临时变量出栈，即临时变量已经被销毁，临时变量占用的内存空间没有被清空，但是可以被分配给其他变量，所以有可能在函数退出时，该内存已经被修改了，对于临时变量来说已经是没有意义的值了

C语言里规定：16bit程序中，返回值保存在ax寄存器中，32bit程序中，返回值保持在eax寄存器中，如果是64bit返回值，edx寄存器保存高32bit，eax寄存器保存低32bit

由此可见，函数调用结束后，返回值被临时存储到寄存器中，并没有放到堆或栈中，也就是说与内存没有关系了。当退出函数的时候，临时变量可能被销毁，但是返回值却被放到寄存器中与临时变量的生命周期没有关系

如果我们需要返回值，一般使用赋值语句就可以了。

#### printf 实现原理

在C/C++中，对函数参数的扫描是从后向前的。

C/C++的函数参数是通过压入堆栈的方式来给函数传参数的（堆栈是一种先进后出的数据结构），最先压入的参数最后出来，在计算机的内存中，数据有2块，一块是堆，一块是栈（函数参数及局部变量在这里），而栈是从内存的高地址向低地址生长的，控制生长的就是堆栈指针了，最先压入的参数是在最上面，就是说在所有参数的最后面，最后压入的参数在最下面，结构上看起来是第一个，所以最后压入的参数总是能够被函数找到，因为它就在堆栈指针的上方。

printf的第一个被找到的参数就是那个字符指针，就是被双引号括起来的那一部分，函数通过判断字符串里控制参数的个数来判断参数个数及数据类型，通过这些就可算出数据需要的堆栈指针的偏移量了，下面给出printf("%d,%d",a,b);（其中a、b都是int型的）的汇编代码.

### 智能指针

#### 智能指针的原理、常用的智能指针及实现

**原理**

智能指针是一个模板类，用来存储指向动态分配对象的指针，负责自动释放动态分配的对象，防止堆内存泄漏。动态分配的资源，交给一个类对象去管理，当类对象声明周期结束时，自动调用析构函数释放资源。

也就是常说的 RAII， 全称是“Resource Acquisition is Initialization”，直译过来是“资源获取即初始化”，也就是说在构造函数中申请分配资源，在析构函数中释放资源。

因为C++的语言机制保证了，当一个对象创建的时候，自动调用构造函数，当对象超出作用域的时候会自动调用析构函数。所以，在RAII的指导下，我们应该使用类来管理资源，将资源和对象的生命周期绑定。

智能指针（std::shared_ptr和std::unique_ptr）即RAII最具代表的实现，使用智能指针，可以实现自动的内存管理，再也不需要担心忘记delete造成的内存泄漏。

毫不夸张的来讲，有了智能指针，代码中几乎不需要再出现delete了。

**常用的智能指针**

智能指针在C++11版本之后提供，包含在头文件`<memory>`中，`shared_ptr`、`unique_ptr`、`weak_ptr`

* 你不想拥有对内存的所有权就能使用裸指针或者weak_ptr
    * 裸指针是你明确使用时内存未被释放
    * weak_ptr 是你使用时不确定内存有没有被释放
* 如果想拥有对内存的所有权就使用 unique_ptr 和 shared_ptr
    * unique_ptr 表示对内存的独占所有权，说白了就是指针的生命周期和内存的生命周期保持一致
    * shared_ptr 表示对内存的共享所有权，表示内存的生命周期是指针的生命周期的并集

**shared_ptr**

实现原理：采用引用计数器的方法，允许多个智能指针指向同一个对象，每当多一个指针指向该对象时，指向该对象的所有智能指针内部的引用计数加1，每当减少一个智能指针指向对象时，引用计数会减1，当计数为0的时候会自动的释放动态分配的资源。 

* 智能指针将一个计数器与类指向的对象相关联，引用计数器跟踪共有多少个类对象共享同一指针
* 每次创建类的新对象时，初始化指针并将引用计数置为1
* 当对象作为另一对象的副本而创建时，拷贝构造函数拷贝指针并增加与之相应的引用计数
* 对一个对象进行赋值时，赋值操作符减少左操作数所指对象的引用计数（如果引用计数为减至0，则删除对象），并增加右操作数所指对象的引用计数
* 调用析构函数时，构造函数减少引用计数（如果引用计数减至0，则删除基础对象）
* 按引用传参不增加引用计数
* shared_ptr内部的引用计数是线程安全的，但是对象的读取需要加锁。

初始化

* 智能指针是个模板类，可以指定类型，传入指针通过构造函数初始化
* 使用make_shared函数初始化。
* 不能将指针直接赋值给一个智能指针，一个是类，一个是指针。例如`std::shared_ptr<int> p4 = new int(1);`的写法是错误的

**unique_ptr**

* unique_ptr 采用的是独享所有权语义，一个非空的unique_ptr总是拥有它所指向的资源，同一时刻只能有一个unique_ptr指向给定对象
    * 通过禁止拷贝语义、只有移动语义来实现
    * 如果你拷贝一个unique_ptr，那么拷贝结束后，这两个unique_ptr都会指向相同的资源，造成在结束时对同一内存指针多次释放而导致程序崩溃。
    * 转移一个unique_ptr将会把所有权全部从源指针转移给目标指针，源指针被置空；所以unique_ptr不支持普通的拷贝和赋值操作，不能用在STL标准容器中；局部变量的返回值除外（因为编译器知道要返回的对象将要被销毁）
* 相比与原始指针unique_ptr用于其RAII的特性，使得在出现异常的情况下，动态资源能得到释放。
* unique_ptr指针本身的生命周期：从unique_ptr指针创建时开始，直到离开作用域。离开作用域时，若其指向对象，则将其所指对象销毁(默认使用delete操作符，用户可指定其他操作)。
* unique_ptr指针与其所指对象的关系：在智能指针生命周期内，可以改变智能指针所指对象，如创建智能指针时通过构造函数指定、通过reset方法重新指定、通过release方法释放所有权、通过移动语义转移所有权。



**weak_ptr**

weak_ptr是一个弱引用，它是为了配合shared_ptr而引入的一种智能指针，它指向一个由shared_ptr管理的对象而不影响所指对象的生命周期。也就是说，它只引用，不计数，只是提供了对管理对象的一个访问手段。



如果一块内存被shared_ptr和weak_ptr同时引用，当所有shared_ptr析构了之后，不管还有没有weak_ptr引用该内存，内存也会被释放。所以weak_ptr不保证它指向的内存一定是有效的，在使用之前使用函数lock()检查weak_ptr是否为空指针。

它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的构造和析构不会引起引用记数的增加或减少.



weak_ptr 作用

[weak_ptr 那还有什么使用场景_爱好学习的青年人的博客-CSDN博客](https://blog.csdn.net/qq_53111905/article/details/122240842)

* 观察者
    * 成员函数 `use_count()` 观测资源引用计数
    * 成员函数 `expired()` 功能相当于 `use_count()==0` 表示被观测的资源(也就是shared_ptr的管理的资源)是否被销毁
    * 成员函数 `lock()` 从被观测的 `shared_ptr`获得一个可用的 `shared_ptr`对象， 进而操作资源。但当`expired()==true` 的时候，`lock()` 函数将返回一个存储空指针的 `shared_ptr`
        * weak_ptr没有提供常用的指针操作，无法直接访问资源，需要先通过lock方法提升为shared_ptr强智能指针，才能访问资源
* 解决循环引用问题
    * shared_ptr 引用计数问题：互相引用形成环（环形引用），这样两个指针指向的内存都无法释放，需要使用weak_ptr 打破环形引用。
    * 请注意强弱智能指针的一个重要应用规则：定义对象时，用强智能指针shared_ptr，在其它地方引用对象时，使用弱智能指针weak_ptr
* 线程安全的对象回调与析构 —— 弱回调
    * 有时候我们需要“如果对象还活着，就调用它的成员函数，否则忽略之”的语意，就像Observable::notifyObservers()那样，我称之为“弱回调”。这也是可以实现的，利用weak_ptr，我们可以把weak_ptr绑到boost::function里，这样对象的生命期就不会被延长。然后在回调的时候先尝试提升为shared_ptr，如果提升成功，说明接受回调的对象还健在，那么就执行回调；如果提升失败，就不必劳神了。

#### shared_ptr 存在线程安全问题吗

shared_ptr的出现在某种程度上解放了c++程序员，c++11标准原生的支持了并发编程，在并发编程中shared_ptr的线程安全问题如何保证呢？先撇开shared_ptr对象的线程安全性，先看shared_ptr本身的线程安全问题。

我们知道，shared_ptr的底层实现原理是引用计数，关于这个计数是否线程安全呢，如果我们把shared_ptr分别传递到不同的线程中，是否会在成引用计数的竞争问题。我们来看shared_ptr引用计数的底层实现。shared_ptr继承了下面的模板类，用它来管理引用计数。其中有两个变量一个表示shared_ptr的引用数，另外一个表示weak_ptr的引用数，我们知道weak_ptr不会增加只能指针的引用数也就是说不持有对象，他的使用必须通过lock方法获取它指向的shared_ptr才能使用。

```c++
template<_Lock_policy _Lp = __default_lock_policy>
   class _Sp_counted_base
   : public _Mutex_base<_Lp>
   {
   public:  
     _Sp_counted_base() noexcept
     : _M_use_count(1), _M_weak_count(1) { }
     
     virtual
     ~_Sp_counted_base() noexcept
     { }
 
     //当_M_use_count为0时调用，是个纯虚函数(必须实现)，这个函数的作用是释放指针指向的对象所持有的资源，即*this
     virtual void
     _M_dispose() noexcept = 0;
     
     // 当_M_weak_count为0时调用，释放自己本身的资源，即this
     //  _M_weak_count = _M_weak_count + (_M_use_count!= 0),当_M_weak_count和_M_use_count都为0时释放this
     virtual void
     _M_destroy() noexcept
     { delete this; }
     
     virtual void*
     _M_get_deleter(const std::type_info&) noexcept = 0;
 
    //增加一个引用
     void
     _M_add_ref_copy()
     { __gnu_cxx::__atomic_add_dispatch(&_M_use_count, 1); }
 
     void
     _M_add_ref_lock();
 
     bool
     _M_add_ref_lock_nothrow();
 
     void
     _M_release() noexcept
     {
       _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&_M_use_count);
  //首先use_count减去1，并对比减操作之前的值，如果减之前是1，说明减后是0，a1没有任何shared_ptr指针指向它了将销毁对象
if (__gnu_cxx::__exchange_and_add_dispatch(&_M_use_count, -1) == 1)
  {
           _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&_M_use_count);
    _M_dispose();
    //如果destory和dispose存在内存屏障，保证dispose函数的效果在destory函数的调用该线程的可见性
    if (_Mutex_base<_Lp>::_S_need_barriers)
      {
   __atomic_thread_fence (__ATOMIC_ACQ_REL);
      }
 
    //同时对a1的weak_count减去1，也对比减操作之前的值，如果减之前是1，说明减后是0，a1没有weak_ptr指向它了，
    //应该将管理对象销毁，于是调用_M_destroy()销毁了管理对象
           _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&_M_weak_count);
    if (__gnu_cxx::__exchange_and_add_dispatch(&_M_weak_count,
                      -1) == 1)
             {
               _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&_M_weak_count);
        _M_destroy();
             }
  }
     }
 
     void
     _M_weak_add_ref() noexcept
     { __gnu_cxx::__atomic_add_dispatch(&_M_weak_count, 1); }
 
     void
     _M_weak_release() noexcept
     {
       _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&_M_weak_count);
if (__gnu_cxx::__exchange_and_add_dispatch(&_M_weak_count, -1) == 1)
  {
           _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&_M_weak_count);
    if (_Mutex_base<_Lp>::_S_need_barriers)
      {
   __atomic_thread_fence (__ATOMIC_ACQ_REL);
      }
    _M_destroy();
  }
     }
 
    //获取引用计数 
     long
     _M_get_use_count() const noexcept
     {
       return __atomic_load_n(&_M_use_count, __ATOMIC_RELAXED);
     }
 
   private:  
     _Sp_counted_base(_Sp_counted_base const&) = delete;
     _Sp_counted_base& operator=(_Sp_counted_base const&) = delete;
 
     _Atomic_word  _M_use_count;   
     _Atomic_word  _M_weak_count;   
   };
```

​    可能有一些人看过boost中智能指针引用计数的实现，不过好像是通过锁来实现的。这里我们可以看到跟boost的是有所不同的，**这里的智能指针的引用计数在手段上使用了atomic原子操作，只要在shared_ptr在拷贝或赋值时增加引用，析构时减少引用就可以了。**

首先原子操作是线程安全的，所有智能指针在多线程下引用计数也是安全的，也就是说智能指针在多线程下传递使用时引用计数是不会有线程安全问题的，但是这能真正的保证shared_ptr指针的线程安全问题吗。

 虽然通过原子操作解决了引用计数的计数的线程安全问题， 但是智能指针指向的对象的线程安全问题，智能指针没有做任何的保证。  首先智能指针有两个变量，一个是指向的对象的指针，还有一个就是我们上面看到的引用计数管理对象， **当智能指针发生拷贝的时候，标准库的实现是县拷贝智能指针，再拷贝引用计数对象（拷贝引用计数对象的时候，会使use_count加一），这两个操作并不是原子的，隐患就出现在这里**，引用一下陈硕老师的例子：点击打开链接](<https://blog.csdn.net/solstice/article/details/8547547>)

​           ![img](https://img-blog.csdn.net/20180501163944631)

  ![img](https://img-blog.csdn.net/20180501164233241)

 这里陈硕老师说道：“这正是多线程读写同一个shared_ptr必须枷锁的原因”， 为了保证程序的绝对的安全是没错的， 但也不是绝对，上面的情景是特殊场景，这种场景也只是为了说明问题而已，真正开发过程中不一定会用到此场景。其实这个问题的根本还是上面说的智能指针指向的对象的线程安全，shared_ptr没有做任何保证，上面的情景就打破了这一准则，在赋值的过程中，改变了shard_ptr指向的对象的内容，甚至不只是修改了对象这么简单，上面的情景直接把智能指针指向的对象给换了。这中情况不用想肯定会出问题。如果你能保证不会有多个线程同时修改或替换指针指向的对象，不用加锁是完全没有问题的，或者说指针指向的对象本身已经是线程安全（包括多线程下的读写安全和构造析构安全）。总之一句话智能指针指向的对象的线程安全，标准库是没有保证的。

#### 为什么推荐用 make_shared 创建指针

使用shared_ptr直接创建智能指针：

```cpp
auto p = shared_ptr<int>(new int(100));
```

我们有下面的两个过程：
– `new int`申请内存，并把指针传给shared_ptr中的px
– 为shared_ptr 的控制块另外申请一块内存，用来存放shared_ptr的控制信息，比如shared_ptr引用计数，weak_ptr引用计数。

这样把创建一个智能指针需要分两步申请内存，会存在下面两个问题：
– 当 `new int` 申请内存成功，但引用计数内存申请失败时，很可能造成内存泄漏。
– 内存分配是一个消耗性能的过程，分两次分配内存，意味着性能会下降

**make_shared**

为了解决直接使用shared_ptr创建智能指针带来的问题，C++11标准库引入make_shared

```cpp
auto p = make_shared<int>(100);
```

make_shared只会申请一次内存，这块内存会大于int所占用的内存，多出的部分被用于智能指针引用计数。这样就避免了直接使用shared_ptr带来的问题。

不过make_shared并不是完美的。

前面只说到强引用计数，其实智能指针还有弱引用计数。当强引用计数为0时，释放引用的对象内存，当弱引用计数为0时，释放引用计数所占用的内存。

由于弱引用计数的存在，make_shared创建的智能指针引用的对象，可能无法得到及时的释放，只有当强/弱引用都为0时，才能释放make_shared申请的一整块内存

**优点**

`shared_ptr` 需要维护引用计数的信息,

* 强引用, 用来记录当前有多少个存活的 shared_ptrs 正持有该对象. 共享的对象会在最后一个强引用离开的时候销毁( 也可能释放).
* 弱引用, 用来记录当前有多少个正在观察该对象的 weak_ptrs. 当最后一个弱引用离开的时候, 共享的内部信息控制块会被销毁和释放 (共享的对象也会被释放, 如果还没有释放的话).

如果你通过使用原始的 new 表达式分配对象, 然后传递给 shared_ptr (也就是使用 shared_ptr 的构造函数) 的话, shared_ptr 的实现没有办法选择, 而只能单独的分配控制块:

```C++
auto p = new widget();
shared_ptr sp1{ p }, sp2{ sp1 };
```

![img](http://y6bhba.bay.livefilestore.com/y1pDu8kORu85CKSKHFVBvapxrccVoMAjc8W0d6mScWwunuhqV8n25QZKgZhM6MPtFGV1c6dPgjil7g/sharedptr1.png)

如果选择使用 `make_shared` 的话, 情况就会变成下面这样:

```C++
auto sp1 = make_shared(), sp2{ sp1 };
```

![img](http://y6yska.bay.livefilestore.com/y1p-Y0XAkcMZMrSdxkTa85nShcDkVKvqhMTFVGSDc0jURLybPXTGHPdWv9CZGgcGmvZwQQvd6Y1Qdg/sharedptr2.png)

内存分配的动作, 可以一次性完成. 这减少了内存分配的次数, 而内存分配是代价很高的操作.

**异常安全**

```C++
void F(const std::shared_ptr<Lhs>& lhs, const std::shared_ptr<Rhs>& rhs) { /* ... */ }

F(std::shared_ptr<Lhs>(new Lhs("foo")), std::shared_ptr<Rhs>(new Rhs("bar")));
```

C++ 是不保证参数求值顺序, 以及内部表达式的求值顺序的, 所以可能的执行顺序如下:

1. new Lhs(“foo”))
2. new Rhs(“bar”))
3. std::shared_ptr
4. std::shared_ptr

好了, 现在我们假设在第 2 步的时候, 抛出了一个异常 (比如 out of memory, 总之, Rhs 的构造函数异常了), 那么第一步申请的 Lhs 对象内存泄露了. 这个问题的核心在于, shared_ptr 没有立即获得裸指针.

我们可以用如下方式来修复这个问题.

```C++
auto lhs = std::shared_ptr<Lhs>(new Lhs("foo"));

auto rhs = std::shared_ptr<Rhs>(new Rhs("bar"));

F(lhs, rhs);
```

当然, 推荐的做法是使用 `std::make_shared` 来代替:

```C++
F(std::make_shared<Lhs>("foo"), std::make_shared<Rhs>("bar"));
```

**缺点**

* **构造函数是保护或私有时,无法使用 make_shared**

`make_shared` 虽好, 但也存在一些问题, 比如, 当我想要创建的对象没有公有的构造函数时, `make_shared` 就无法使用了, 当然我们可以使用一些小技巧来解决这个问题, 比如这里 [How do I call ::std::make_shared on a class with only protected or private constructors?](http://stackoverflow.com/questions/8147027/how-do-i-call-stdmake-shared-on-a-class-with-only-protected-or-private-const?rq=1)

[make_shared调用私有构造函数的解决方法](http://yoursite.com/2019/04/14/make-shared%E8%B0%83%E7%94%A8%E7%A7%81%E6%9C%89%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/)

* **对象的内存可能无法及时回收**

`make_shared` 只分配一次内存, 这看起来很好. 减少了内存分配的开销. 问题来了, `weak_ptr` 会保持控制块(强引用, 以及弱引用的信息)的生命周期, 而因此连带着保持了对象分配的内存, 只有最后一个 `weak_ptr` 离开作用域时, 内存才会被释放. 原本强引用减为 0 时就可以释放的内存, 现在变为了强引用, 若引用都减为 0 时才能释放, 意外的延迟了内存释放的时间. 这对于内存要求高的场景来说, 是一个需要注意的问题. 关于这个问题可以看这里 [make_shared, almost a silver bullet](http://lanzkron.wordpress.com/2012/04/22/make_shared-almost-a-silver-bullet/)

* 自定义内存管理的类: 需要传递自定义析构器， make_shared 无法使用;
* 内存紧张的系统或非常大的对象：由于内存碎片的问题，分配1次内存比分配2次内存更容易失败。



#### shared_ptr 内部原理

[shared_ptr原理 万里归来少年心的博客-CSDN博客](https://blog.csdn.net/liyazhen2011/article/details/103636202)

 `shared_ptr` 的定义如下：

```cpp
template<class _Ty>
class shared_ptr : public _Ptr_base<_Ty>
```

 `shared_ptr` 从基类 `_Ptr_base` 继承了如下成员变量（部分源码）：

```c++
template<class _Ty>
class _Ptr_base
{
private:
    element_type * _Ptr{ nullptr };      //指向资源
    _Ref_count_base * _Rep{ nullptr };   //指向资源引用计数
}
```

两个指针成员变量，**所以 shared_ptr 大小就是两个指针变量的大小**

* `_Ptr` 指向资源
* `_Rep` 指向资源引用计数

 `_Ref_count_base` 的定义如下：

```c++
class __declspec(novtable) _Ref_count_base
{	// common code for reference counting
private:
	_Atomic_counter_t _Uses;   //记录了引用资源的shared_ptr的个数
	_Atomic_counter_t _Weaks;  //记录了weak_ptr的个数
}
```

* `_Uses`记录了资源的引用计数，也就是引用资源的shared_ptr 的个数；
* `_Weaks`记录了weak_ptr的个数，相当于资源观察者的个数。



经典错误，多个 shared_ptr 通过同一个 raw pointer 构造，试图管理同一个资源，但是重新开辟了引用计数的资源。所以引用计数都为1。析构函数会被调用两次，所以程序出错。 

```c++
#include <iostream>
#include <memory>
using namespace std;
int main()
{
    // 裸指针指向堆上的对象
    int *p = new int;       
    shared_ptr<int> ptr1(p);
    shared_ptr<int> ptr2(p);
    //两次打印都是1，析构两次，出错
    cout << "use_count = " <<  ptr1.use_count() << endl; // 输出 use_count = 1
    cout << "use_count = " << ptr2.use_count() << endl;	// 输出 use_count = 1
    getchar();
    return 0;
}
```

 ![img](https://img-blog.csdnimg.cn/20191220190135321.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpeWF6aGVuMjAxMQ==,size_16,color_FFFFFF,t_70)

正确的代码

```c++
#include <iostream>
#include <memory>
using namespace std;
int main()
{
    // 裸指针指向堆上的对象
    int *p = new int;       
    shared_ptr<int> ptr1(p);
    shared_ptr<int> ptr2(ptr1);
    //两次打印都是2，析构一次，正确
    cout << "use_count = " <<  ptr1.use_count() << endl;
    cout << "use_count = " << ptr2.use_count() << endl;
    getchar();
    return 0;
}
```

 原因：ptr1(p) 调用构造函数，ptr2(ptr1)调用拷贝构造函数（没有开辟新的引用计数的资源，只是引用计数加1）。析构函数会被调用一次，所以程序正确。

![img](https://img-blog.csdnimg.cn/20191220190101527.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpeWF6aGVuMjAxMQ==,size_16,color_FFFFFF,t_70)



#### 共享指针能否指向独占指针，独占指针能否指向共享指针（或者说能否互相转换？）

[如何理解shared_ptr和unique_ptr能否互转 - 掘金 (juejin.cn)](https://juejin.cn/post/7096514898800148488)

**unique_ptr转换成shared_ptr？**

由于unique_ptr的语义是唯一拥有ownership，那只要对他执行move操作就能把ownership 转移出去 给shared_ptr

```
std::unique_ptr<Widget> a = std::make_unique<Widget>();
std::shared_ptr<Widget> b = std::move(a);
```

这样a就等价于nullptr，而b则指向了堆中的Widget对象，切count=1。



**shared_ptr转换成unique_ptr？**

由于shared_ptr本质上是多人拥有ownership，所以要转换成语义更加严格的单人拥有ownership是做不到的，就像图2中a和b都指向了同一个对象，这种情况如果要转成一个unique_ptr c的话就需要同时清除掉a和b对于Widget的指向，这是很难做到的，所以标准里面不支持 shared_ptr 转成 unique_ptr。



一句话总结这个原则，严格条件的ownership能转成宽松条件的ownership。

#### 手搓智能指针

智能指针是一个数据类型，一般用模板实现，模拟指针行为的同时还提供自动垃圾回收机制。它会自动记录SmartPointer<T*>对象的引用计数，一旦T类型对象的引用计数为0，就释放该对象。

除了指针对象外，我们还需要一个引用计数的指针设定对象的值，并将引用计数计为1，需要一个构造函数。新增对象还需要一个构造函数，析构函数负责引用计数减少和释放内存。

通过覆写赋值运算符，才能将一个旧的智能指针赋值给另一个指针，同时旧的引用计数减1，新的引用计数加1

一个构造函数、拷贝构造函数、复制构造函数、析构函数、移动函数；

```C++
template<typename T>
class SharedPtr
{
public:
    SharedPtr(T* ptr = NULL):_ptr(ptr), _pcount(new int(1))
    {}

    SharedPtr(const SharedPtr& s):_ptr(s._ptr), _pcount(s._pcount){
        (*_pcount)++;
    }

    SharedPtr<T>& operator=(const SharedPtr& s){
        if (this != &s)
        {
            if (--(*(this->_pcount)) == 0)
            {
                delete this->_ptr;
                delete this->_pcount;
            }
            _ptr = s._ptr;
            _pcount = s._pcount;
            *(_pcount)++;
        }
        return *this;
    }
    T& operator*()
    {
        return *(this->_ptr);
    }
    T* operator->()
    {
        return this->_ptr;
    }
    ~SharedPtr()
    {
        --(*(this->_pcount));
        if (*(this->_pcount) == 0)
        {
            delete _ptr;
            _ptr = NULL;
            delete _pcount;
            _pcount = NULL;
        }
    }
private:
    T* _ptr;
    int* _pcount;//指向引用计数的指针
};
```

