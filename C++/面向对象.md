# 面向对象

## 问题

### 基本认识

* 谈谈面向对象

* 简述一下 C++ 中的多态

* 简述下向上转型和向下转型

* 谈谈重载和重写？

* 谈谈多继承、菱形继承、虚继承

* C 语言如何实现多态、继承

* 对比组合与继承

### 类

* 说说什么是虚基类，可否被实例化？

* 如何理解抽象类？

* 说说类方法和数据的权限有哪几种？

* 请你回答一下 C++ 类内可以定义引用数据成员吗？

### 特殊成员函数

* 谈谈构造函数、析构函数的作用、特点、具体过程、异常、内联
* C++有哪几种的构造函数
* 委托构造函数的优缺点
* 构造函数里面可以调用成员函数吗
* nullptr 可以调用成员函数吗？
* 有参构造函数里面可以调用无参构造函数吗
* 谈谈成员初始化列表
* 说说一个空类，默认会生成哪些函数？
* 什么情况会自动生成默认构造函数？
* 什么时候需要合成拷贝构造函数呢？
* 如何禁止程序自动生成拷贝构造函数？
* 三之法则/五之法则/零之法则？
* 为什么拷贝构造函数必须传引用不能传值？
* 简述一下移动构造函数？
* 构造函数、拷贝构造函数和赋值操作符的区别？
* 什么时候会调用拷贝构造函数？
* 谈谈拷贝初始化与直接初始化？
* 解释一下什么是trivial destructor

### 虚函数

* C++ 中哪些函数不能被声明为虚函数？

* 虚析构函数的作用？

* 虚函数的代价？

* 虚函数表放在内存的什么区，其中的内容什么时候写进去的，虚表指针初始化时间，怎么查找虚函数的？

* 说说C++中虚函数与纯虚函数？

* 构造函数或析构函数中可以调用虚函数吗

### this 指针

* 谈谈 this 指针

* this指针是什么时候创建的？

* this指针存放在何处？堆、栈、全局变量，还是其他？

* this指针是如何传递类中的函数的？绑定？还是在函数参数的首参数就是this指针？那么，this指针又是如何找到“类实例后函数的”

* this指针是如何访问类中的变量的？

* 我们只有获得一个对象后，才能通过对象使用this指针。如果我们知道一个对象this指针的位置，可以直接使用吗？

* 每个类编译后，是否创建一个类中函数表保存函数指针，以便用来调用函数？

* this指针调用成员变量时，堆栈会发生什么变化？

* 如果在类的析构函数中调用delete this，会发生什么？

* 在成员函数中调用delete this会出现什么问题？对象还可以使用吗？

* 成员函数里memset(this,0,sizeof(*this))会发生什么

* 静态成员函数可以访问非静态的成员变量吗？

## 回答

### 基本认识

#### 谈谈面向对象？

面向对象是一种编程思想，把一切东西看成是一个个对象，比如人、耳机、鼠标、水杯等，他们各自都有属性，比如：耳机是白色的，鼠标是黑色的，水杯是圆柱形的等等，把这些对象拥有的属性变量和操作这些属性变量的函数打包成一个类来表示

**面向过程和面向对象的区别**

* 面向过程：根据业务逻辑从上到下写代码
* 面向对象：将数据与函数绑定到一起，进行封装，这样能够更快速的开发程序，减少了重复代码的重写过程

**面向对象的三大特征是封装、继承、多态。**

封装：将数据和操作数据的方法进行有机结合，隐藏对象的属性和实现细节，仅对外公开接口来和对象进行 交互。封装本质上是一种管理：我们如何管理兵马俑呢？比如如果什么都不管，兵马俑就被随意破坏了。那么我们首先建了一座房子把兵马俑给封装起来。但是我们目的全封装起来，不让别人看。所以我们开放了售票通 道，可以买票突破封装在合理的监管机制下进去参观。类也是一样，不想给别人看到的，我们使用protected/private把成员封装起来。开放一些共有的成员函数对成员合理的访问。所以封装本质是一种管理。

继承：可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。

三种继承方式

| **继承方式**        | **private继承** | **protected继承** | **public继承**               |
| ------------------- | --------------- | ----------------- | ---------------------------- |
| 基类的private成员   | 不可见          | 不可见            | 不可见                       |
| 基类的protected成员 | 变为private成员 | 仍为protected成员 | 仍为protected成员            |
| 基类的public成员    | 变为private成员 | 变为protected成员 | 仍为public成员仍为public成员 |

多态：

用父类型别的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。实现多态，有二种方式，重写，重载。



**面向过程**

优点：

* 流程化使得编程任务明确，在开发之前基本考虑了实现方式和最终结果，具体步骤清楚，便于节点分析。
* 效率高，面向过程强调代码的短小精悍，善于结合数据结构来开发高效率的程序。

缺点：

* 需要深入的思考，耗费精力，代码重用性低，扩展能力差，后期维护难度比较大。

**面向对象**

优点:

* 结构清晰，程序是模块化和结构化，更加符合人类的思维方式；
* 易扩展，代码重用率高，可继承，可覆盖，可以设计出低耦合的系统；
* 易维护，系统低耦合的特点有利于减少程序的后期维护工作量。

缺点：

* 开销大，当要修改对象内部时，对象的属性不允许外部直接存取，所以要增加许多没有其他意义、只负责读或写的行为。这会为编程工作增加负担，增加运行开销，并且使程序显得臃肿。
* 性能低，由于面向更高的逻辑抽象层，使得面向对象在实现的时候，不得不做出性能上面的牺牲，计算时间和空间存储大小都开销很大。

#### 简述一下 C++ 中的多态？

多态是同一个事物在不同场景下的多种形态

* 静态多态
  * 函数重载
  * 模板
  * CRTP
  * 函数指针 std::bind
* 动态多态：
  * 虚函数
  * std::variant & std::visit(C++17)

静态多态：编译器在编译期间完成的，编译器会根据实参类型来推断该调用哪个函数，如果有对应的函数，就调用，没有则在编译时报错。

```cpp
include<iostream>
using namespace std;

int Add(int a,int b)//1
{
    return a+b;
}

char Add(char a,char b)//2
{
    return a+b;
}

int main()
{
    cout<<Add(666,888)<<endl;//1
    cout<<Add('1','2');//2
    return 0;
}
```

显然，第一条语句会调用函数1，而第二条语句会调用函数2，这绝不是因为函数的声明顺序，不信你可以将顺序调过来试试。

**动态多态：其实要实现动态多态，需要几个条件——即动态绑定条件：**

1. 虚函数。基类中必须有虚函数，在派生类中必须重写虚函数。
2. 通过基类类型的**指针或引用**来调用虚函数。

动态多态的实现原理 

当类中声明虚函数时，编译器会在类中生成一个虚函数表，虚函数表是一个存储类虚函数指针的数据结构， 虚函数表是由编译器自动生成与维护的。virtual 成员函数会被编译器放入虚函数表中，存在虚函数时，每个对象中都有一个指向虚函数表的指针（vptr 指针）。在多态调用时, vptr 指针就会根据这个对象在对应类的虚函数表中查找被调用的函数，从而找到函数的入口地址



#### 简述下向上转型和向下转型

子类转换为父类：向上转型，使用dynamic_cast<type_id>(expression)，这种转换相对来说比较安全不会有数据的丢失；

父类转换为子类：向下转型，可以使用强制转换，这种转换时不安全的，会导致数据的丢失，原因是父类的指针或者引用的内存中可能不包含子类的成员的内存。

#### 谈谈重载和重写？

**重写**

是指派生类中存在重新定义的函数。**其函数名，参数列表，返回值类型，所有都必须同基类中被重写的函数一致。只有函数体不同（花括号内）**，派生类对象调用时会调用派生类的重写函数，不会调用被重写函数。重写的基类中被重写的函数必须有virtual修饰。

示例如下：

```c++
#include<bits/stdc++.h>  
using namespace std;  
class A { 
 public:  virtual void fun()  {   cout << "A";  } 
}; 
class B :public A {
  public:  
  virtual void fun()  {   cout << "B";  } 
}; 
int main(void) {  
  A* a = new B();
  a->fun();//输出B，A类中的fun在B类中重写 
 }
```

 在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数。

**重载**

我们在平时写代码中会用到几个函数但是他们的实现功能相同，但是有些细节却不同。例如：交换两个数的值其中包括（int, float,char,double)这些个类型。在C语言中我们是利用不同的函数名来加以区分。这样的代码不美观而且给程序猿也带来了很多的不便。于是在C++中人们提出了用一个函数名定义多个函数，也就是所谓的函数重载。**函数重载是指同一可访问区内被声明的几个具有不同参数列（参数的类型，个数，顺序不同）的同名函数，根据参数列表确定调用哪个函数，重载不关心函数返回类型。**

```plaintext
#include<bits/stdc++.h>
using namespace std;  
class A {  
 void fun() {};
 void fun(int i) {};
 void fun(int i, int j) {};     
 void fun1(int i,int j){}; 
};
```

**C++ 如何实现重载**

C++利用命名倾轧（name mangling）技术，来改名函数名，区分参数不同的同名函数。命名倾轧是在编译阶段完成的。

C++定义同名重载函数：

```plaintext
#include<iostream> 
using namespace std; 

int func(int a,double b) {
   return ((a)+(b)); 
} 
int func(double a,float b) {
   return ((a)+(b)); 
} 
int func(float a,int b) {
   return ((a)+(b)); 
} 
int main() {  
 return 0; 
}
```

![img](https://uploadfiles.nowcoder.com/images/20220225/4107856_1645788124958/5E57B0F4AE72F40057C2EAA16C4DB902)

由上图可得，d代表double，f代表float，i代表int，加上参数首字母以区分同名函数。

**C 语言如何实现重载**

语言中不允许有同名函数，因为编译时函数命名是一样的，不像c++会添加参数类型和返回类型作为函数编译后的名称，进而实现重载。如果要用c语言显现函数重载，可通过以下方式来实现：

使用函数指针来实现，重载的函数不能使用同名称，只是类似的实现了函数重载功能

重载函数使用可变参数，方式如打开文件open函数

gcc有内置函数，程序使用编译函数可以实现函数重载

```c
#include<stdio.h>   
void func_int(void * a) {
     printf("%d\n",*(int*)a);  //输出int类型，注意 void * 转化为int 
}   
void func_double(void * b) {     
 printf("%.2f\n",*(double*)b); 
}   

typedef void (*ptr)(void *);  //typedef申明一个函数指针   

void c_func(ptr p,void *param) {      
 p(param);                //调用对应函数 
}   
int main() {
     int a = 23;     
     double b = 23.23;     
     c_func(func_int,&a);     
     c_func(func_double,&b);     
     return 0; 
}
```

#### 谈谈多继承、菱形继承、虚继承

**多继承优缺点**

* C++允许为一个派生类指定多个基类，这样的继承结构被称做多重继承。
* 多重继承的优点很明显，就是对象可以调用多个基类中的接口；
* 如果派生类所继承的多个基类有相同的基类，而派生类对象需要调用这个祖先类的接口方法，就会容易出现二义性
* 加上全局符确定调用哪一份拷贝。比如pa.Author::eat()调用属于Author的拷贝。
* 使用虚拟继承，使得多重继承类Programmer_Author只拥有Person类的一份拷贝。

**菱形继承**

![img](https://uploadfiles.nowcoder.com/images/20220225/4107856_1645788250019/669F46EC1CA09D9F687FFD9A8EC4CFEE)

假设我们有类B和类C，它们都继承了相同的类A。另外我们还有类D，类D通过多重继承机制继承了类B和类C。因为上述图表的形状类似于菱形，因此这个问题被形象地称为菱形继承问题。现在，我们将上面的图表翻译成具体的代码：

```cpp
/*  *Animal类对应于图表的类A* */ 
class Animal { // 基类     
 int weight;      
public:     
 int getWeight() { return weight; } 
};  
 
class Tiger : public Animal { /* ... */ };
 
class Lion : public Animal { /* ... */ } 

class Liger : public Tiger, public Lion { /* ... */ }
```

在我们的继承结构中，我们可以看出Tiger和Lion类都继承自Animal基类。所以问题是：因为Liger多重继承了Tiger和Lion类，因此Liger类会有两份Animal类的成员（数据和方法），Liger对象"lg"会包含Animal基类的两个子对象。

所以，你会问Liger对象有两个Animal基类的子对象会出现什么问题？再看看上面的代码-调用"lg.getWeight()"将会导致一个编译错误。这是因为编译器并不知道是调用Tiger类的getWeight()还是调用Lion类的getWeight()。所以，调用getWeight方法是不明确的，因此不能通过编译。

**虚继承**

我们给出了菱形继承问题的解释，但是现在我们要给出一个菱形继承问题的解决方案。如果Lion类和Tiger类在分别继承Animal类时都用virtual来标注，对于每一个Liger对象，C++会保证只有一个Animal类的子对象会被创建。看看下面的代码:

```cpp
class Tiger : virtual public Animal { /* ... */ }; 
class Lion : virtual public Animal { /* ... */ };
```

你可以看出唯一的变化就是我们在类Tiger和类Lion的声明中增加了"virtual"关键字。现在类Liger对象将会只有一个Animal子对象，下面的代码编译正常:

```cpp
int main( ) {  
 Liger lg;  /*既然我们已经在Tiger和Lion类的定义中声明了"virtual"关键字，于是下面的代码编译OK */  
 int weight = lg.getWeight(); 
}
```

虚继承是解决C++多重继承问题的一种手段，从不同途径继承来的同一基类，会在子类中存在多份拷贝。这将存在两个问题：其一，浪费存储空间；第二，存在二义性问题，通常可以将派生类对象的地址赋值给基类对象，实现的具体方式是，将基类指针指向继承类（继承类有基类的拷贝）中的基类对象的地址，但是多重继承可能存在一个基类的多份拷贝，这就出现了二义性。虚继承可以解决多种继承前面提到的两个问题

```cpp
#include<iostream>
using namespace std;
class A{
public:
    int _a;
};
class B :virtual public A {
public:
    int _b;
};
class C :virtual public A {
public:
    int _c;
};
class D :public B, public C {
public:
    int _d;
};
//菱形继承和菱形虚继承的对象模型
int main() {
    D d;
    d.B::_a = 1;
    d.C::_a = 2;
    d._b = 3;
    d._c = 4;
    d._d = 5;
    cout << sizeof(D) << endl;
    return 0;
}
```

分别从菱形继承和虚继承来分析：

![img](https://uploadfiles.nowcoder.com/images/20220225/4107856_1645788186868/1DBA188A576ED176E295873CC580363A)

菱形继承中A在B,C,D,中各有一份，虚继承中，A共享。

上面的虚继承表实际上是一个指针数组。B、C实际上是虚基表指针，指向虚基表。

虚基表：存放相对偏移量，用来找虚基类

![img](https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.4.2/202102/1565960190086.png)

![img](https://cdn.jsdelivr.net/gh/forthespada/mediaImage2@2.6/202104/C++-97-2.png)

**虚拟继承的情况下，无论基类被继承多少次，只会存在一个实体。**虚拟继承基类的子类中，子类会增加某种形式的指针，或者指向虚基类子对象，或者指向一个相关的表格；表格中存放的不是虚基类子对象的地址，就是其偏移量，此类指针被称为bptr，如上图所示。如果既存在vptr又存在bptr，某些编译器会将其优化，合并为一个指针。



#### C 语言如何实现面向对象

#### C 语言如何实现多态、继承

```c
//C 语言模拟C++的继承与多态
typedef void (*FUN)();   //定义一个函数指针来实现对成员函数的继承

//父类
struct _A { 
  FUN _fun;  //由于C语言中结构体不能包含函数，故只能用函数指针在外面实现
  int _a;
};

//子类
struct _B {
  _A _a_;   //在子类中定义一个基类的对象即可实现对父类的继承
  int _b;
};

// 父类的同名函数
void _fA() {
  printf("_A:_fun()\n");
}

// 子类的同名函数
void _fB() {
  printf("_B:_fun()\n");
}

//C语言模拟继承与多态的测试
void Test() {
   
 _A _a;  //定义一个父类对象_a
   _B _b;  //定义一个子类对象_b
   _a._fun = _fA;    //父类的对象调用父类的同名函数
   _b._a_._fun = _fB;  //子类的对象调用子类的同名函数

 _A* p2 = &_a;  //定义一个父类指针指向父类的对象
 p2->_fun();   //调用父类的同名函数
 p2 = (_A*)&_b; //让父类指针指向子类的对象,由于类型不匹配所以要进行强转
 p2->_fun();   //调用子类的同名函数
}
```

c++的多态分为两种：

1. 编译时多态：重载

2. 运行时多态：重写即虚函数

思路就是使用函数指针来实现多态。

**编译时多态：**

先说一个c中的宏，`__V_ARGS__`，是c99引入进来的可变参宏，一般是用来输出debug信息。可以用这个宏实现一个简单的多态机制。代码举例：

```c
#define Check(...) printf(__VA_ARGS__);
int main(int argc, char *argv[])
{
    int i = 1, j = 2;
    char *Error = "error!!";
    Check("i = %d\n", j);
    Check("i = %d, j = %d\n", i, j);
    Check("i = %d, j = %d, Error:%s\n", i, j, Error);
 return 0;
}
/*********************关于结构体的*****************************/
#define func(...) myfunc((struct mystru) { __VA_ARGS__})

struct mystru
{
    const char *name;
    double d;
    int number;
};
 
void myfunc(struct mystru ms)
{
    printf("%s, %lf, %d\n", ms.name, ms.d, ms.number);
}
 
int main(int argc, char *argv[])
{
    func();
    func("hello", 1.1);
    func("hello");
    func("hello", 1.1, 100);
    func(.name = "hello");
    func(.d = 1.1);
    func(.number = 100);
    func(.d = 1.1, .name = "hello");
 return 0;
}
```

注意：一般我们在使用结构体的时候都是先赋值在传参数，这里实际上是用"..."可变参数替换为了`__VA_ARGS__`这个宏，然后转化为`(struct mystru){ __VA_ARGS__ }`，其实就是`
(struct mystru){ ... }` 。 通过（struct mystru）把参数转化结构体，这也是为什么如果我们不指定.name或者是.number时，必须按顺序传递参数，否则报错，因为在内存中结构体布局是确定的。不明确指定哪个参数只能按顺序传递。

**运行时多态：**

在c中sizeof(struct)是0,从内存上来看，c++的class和struct不仅仅有数据还有成员函数，这些成员函数如果是non-inline的，那么只会在内存中产生一份实例供所有对象使用，如果是inline的，会为每一个使用着产生一个实例。而c的struct就简单多了，它不占用内存空间，每一个实例按照struct分配一份就好，但这也是问题所在，它在内存中没实例啊。那么用c的struct实现时，我们就要想办法让它在内存中存在一份，大家都能找到它。

所以主要关键点就是在于函数指针的使用

```c++
//虚函数表结构
struct base_vtbl
{
 void(*dance)(void *);
 void(*jump)(void *);
};

//基类
struct base
{
    /*virtual table*/
 struct base_vtbl *vptr;
};
//基类的构造函数
struct base * new_base()
{
    struct base *temp = (struct base *)malloc(sizeof(struct base));
    //基类虚表结构中函数指针具体关联的函数名
 temp->vptr->dance = base_dance;
    temp->vptr->jump = base_jump;
 return temp;
}
//基类的成员函数
void base_dance()
{
 printf("base dance\n");
}
void base_jump()
{
 printf("base jump\n");
}


//派生类
struct derived1
{
 struct base super;
 int high;
};
//派生类的构造函数
struct derived1 * new_derived1(int h)
{
    struct derived1 * temp= (struct derived1 *)malloc(sizeof(struct derived1));
    //派生类虚表结构中函数指针具体关联的函数名
 temp->super->vptr->dance = derived1_table;
    temp->super->vptr->jump = derived1_jump;
 temp->high = h;
 return temp;
}
//派生类对象成员函数
void derived1_dance()
{
 printf("derived1 dance\n");
}
void derived1_jump(void * this)
{
 struct derived1* temp = (struct derived1 *)this;
 printf("derived1 jump:%d\n", temp->high);
}

/*******实际调用***********/
 struct base * bas = new_base();
//这里调用的是基类的成员函数
bas->vptr->dance();
bas->vptr->jump();

struct derived1 * child = new_derived1(100);
//基类指针指向派生类
bas  = (struct base *)child;

//这里调用的其实是派生类的成员函数
bas->vptr->dance();
bas->vptr->jump((void *)bas);
```

### 类

#### 说说什么是虚基类，可否被实例化？

在被继承的类前面加上virtual关键字，这时被继承的类称为虚基类，代码如下：

```cpp
class A
class B1:public virtual A;
class B2:public virtual A;
class D:public B1,public B2;
```

**虚继承的类**可以被实例化，举例如下：

```cpp
class Animal {/* ... */ };
class Tiger : virtual public Animal { /* ... */ };
class Lion : virtual public Animal { /* ... */ }
int main( )
{
    Liger lg;

    /*既然我们已经在Tiger和Lion类的定义中声明了"virtual"关键字，于是下面的代码编译OK */
    int weight = lg.getWeight();
}
```

#### 如何理解抽象类？

抽象类的定义如下：

纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加“=0”，有纯虚函数的类就叫做抽象类。

抽象类有如下几个特点：

* 抽象类只能用作其他类的基类，不能建立抽象类对象。
* 抽象类不能用作参数类型、函数返回类型或显式转换的类型。
* 可以定义指向抽象类的指针和引用，此指针可以指向它的派生类，进而实现多态性。

抽象类是一种特殊的类，它是为了抽象和设计的目的为建立的，它处于继承层次结构的较上层。

1、抽象类的定义： 称带有纯虚函数的类为抽象类。

2、抽象类的作用： 抽象类的主要作用是将有关的操作作为结果接口组织在一个继承层次结构中，由它来为派生类提供一个公共的根，派生类将具体实现在其基类中作为接口的操作。所以派生类实际上刻画了一组子类的操作接口的通用语义，这些语义也传给子类，子类可以具体实现这些语义，也可以再将这些语义传给自己的子类。

3、 抽象类只能作为基类来使用，其纯虚函数的实现由派生类给出。如果派生类中没有重新定义纯虚函数，而只是继承基类的纯虚函数，则这个派生类仍然还是一个抽象类。如果派生类中给出了基类纯虚函数的实现，则该派生类就不再是抽象类了，它是一个可以建立对象的具体的类。

抽象类是不能定义对象的。一个纯虚函数不需要（但是可以）被定义。

4、纯虚函数定义 纯虚函数是一种特殊的虚函数，它的一般格式如下：

```plaintext
class <类名> 　{ 　virtual <类型><函数名>(<参数表>)=0; 　… 　}; 
```

　　在许多情况下，在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做。这就是纯虚函数的作用。 　纯虚函数可以让类先具有一个操作名称，而没有操作内容，让派生类在继承时再去具体地给出定义。凡是含有纯虚函数的类叫做抽象类。这种类不能声明对象，只是作为基类为派生类服务。除非在派生类中完全实现基类中所有的的纯虚函数，否则，派生类也变成了抽象类，不能实例化对象。

5、纯虚函数引入原因 1、为了方便使用多态特性，我们常常需要在基类中定义虚拟函数。 2、在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔 雀等子类，但动物本身生成对象明显不合常理。 　为了解决上述问题，引入了纯虚函数的概念，将函数定义为纯虚函数（方法：virtual ReturnType Function()= 0;）。若要使派生类为非抽象类，则编译器要求在派生类中，必须对纯虚函数予以重载以实现多态性。同时含有纯虚函数的类称为抽象类，它不能生成对象。这样就很好地解决了上述两个问题。 例如，绘画程序中，shape作为一个基类可以派生出圆形、矩形、正方形、梯形等， 如果我要求面积总和的话，那么会可以使用一个 shape * 的数组，只要依次调用派生类的area()函数了。如果不用接口就没法定义成数组，因为既可以是circle ,也可以是square ,而且以后还可能加上rectangle，等等.

6、相似概念 1、多态性

指相同对象收到不同消息或不同对象收到相同消息时产生不同的实现动作。C++支持两种多态性：编译时多态性，运行时多态性。 　a.编译时多态性：通过重载函数实现 　b.运行时多态性：通过虚函数实现。 2、虚函数 　虚函数是在基类中被声明为virtual，并在派生类中重新定义的成员函数，可实现成员函数的动态重载。 3、抽象类 　包含纯虚函数的类称为抽象类。由于抽象类包含了没有定义的纯虚函数，所以不能定义抽象类的对象。

#### 说说类方法和数据的权限有哪几种？

C++通过 public、protected、private 三个关键字来控制成员变量和成员函数的访问权限，它们分别表示公有的、受保护的、私有的，被称为成员访问限定符。

| **关键字** | **权限**                       |
| ---------- | ------------------------------ |
| public     | 可以被任意实体访问             |
| protected  | 只允许子类及本类的成员函数访问 |
| private    | 只允许本类的成员函数访问       |

类中的成员可以分为三种类型，分别为public成员、protected成员、public成员。类中可以直接访问自己类的public、protected、private成员，但类对象只能访问自己类的public成员。

1. public继承：派生类可以访问基类的public、protected成员，不可以访问基类的private成员； 派生类对象可以访问基类的public成员，不可以访问基类的protected、private成员。
2. protected继承：派生类可以访问基类的public、protected成员，不可以访问基类的private成员； 派生类对象不可以访问基类的public、protected、private成员。
3. private继承：派生类可以访问基类的public、protected成员，不可以访问基类的private成员； 派生类对象不可以访问基类的public、protected、private成员。

#### 请你回答一下 C++ 类内可以定义引用数据成员吗？

c++类内可以定义引用成员变量，但要遵循以下三个规则：

1. 不能用默认构造函数初始化，必须提供构造函数来初始化引用成员变量。否则会造成引用未初始化错误。
2. 构造函数的形参也必须是引用类型。
3. 不能在构造函数里初始化，必须在初始化列表中进行初始化。

#### 对比组合与继承

**一：继承**

继承是Is a 的关系，比如说Student继承Person,则说明Student is a Person。

继承的优点：子类可以重写父类的方法来方便地实现对父类的扩展。

继承的缺点：

①：父类的内部细节对子类是可见的。

②：子类从父类继承的方法在编译时就确定下来了，所以无法在运行期间改变从父类继承的方法的行为。

③：如果对父类的方法做了修改的话（比如增加了一个参数），则子类的方法必须做出相应的修改。所以说子类与父类是一种高耦合，违背了面向对象思想。

**二：组合**

组合也就是设计类的时候把要组合的类的对象加入到该类中作为自己的成员变量。

组合的优点：

①：当前对象只能通过所包含的那个对象去调用其方法，所以所包含的对象的内部细节对当前对象时不可见的。

②：当前对象与包含的对象是一个低耦合关系，如果修改包含对象的类中代码不需要修改当前对象类的代码。

③：当前对象可以在运行时动态的绑定所包含的对象。可以通过set方法给所包含对象赋值。

组合的缺点：①：容易产生过多的对象。②：为了能组合多个对象，必须仔细对接口进行定义。

### 特殊成员函数

#### 构造函数

**作用**：帮助实例化一个对象



**构造函数顺序**

1. 基类构造函数。如果有多个基类，则构造函数的调用顺序是某类在类派生表中出现的顺序，而不是它们在成员初始化表中的顺序。

2. 成员类对象构造函数。如果有多个成员类对象则构造函数的调用顺序是对象在类中被声明的顺序，而不是它们出现在成员初始化表中的顺序。

3. 派生类构造函数。

    1. 对象的vptr被初始化；
    2. 如果有成员初始化列表，将在构造函数体内扩展开来，这必须在vptr被设定之后才做；
    3. 执行程序员所提供的代码；

    

**几种关键字**

* default 关键字可以显式要求编译器生成合成构造函数，防止在调用时相关构造函数类型没有定义而报错
* delete 关键字可以删除构造函数、赋值运算符函数等，这样在使用的时候会得到友善的提示



**能否内联**：可以但没必要，编译器也不听你的



**能否抛出异常**

在构造函数中抛出异常，当前对象的析构函数不会被调用，如果在构造函数中分配了内存，那么就会造成内存泄露，所以要格外注意



**有参构造函数里面可以调用无参构造函数吗**

* 不能在构造函数体中调用其他的构造函数，这等于是临时构造了一个Teacher后又丢弃了它。
* 不过在新标准（C++11）中，可以在构造函数的构造初始化列表中调用本类的其他构造函数（委托构造函数）



**构造函数里面可以调用成员函数吗**

可以成员函数调用，成员函数对于一个类对象来说，始终是可以用，它和对象的构造没有关系。但是不要使用还未初始化的数据成员





#### 析构函数

**作用**：用于撤销对象的一些特殊任务处理，可以是释放对象分配的内存空间

**特点**：

* 析构函数与构造函数同名，但该函数前面加~。
* 析构函数没有参数，也没有返回值，而且不能重载，在一个类中只能有一个析构函数。

**能否内联**：可以但没必要，编译器也不听你的



**什么时候调用析构函数**

* 对象生命周期结束，被销毁时；
* delete指向对象的指针时，或delete指向对象的基类类型指针，而其基类虚构函数是虚函数时
* 对象i是对象o的成员，o的析构函数被调用时，对象i的析构函数也被调用。

**析构函数顺序**

1. 调用派生类的析构函数；
2. 调用成员类对象的析构函数；
3. 调用基类的析构函数。
4. 基类的成员析构



**是否能抛出异常**

* 不应该抛出异常
* 如果析构函数抛出异常，则异常点之后的程序不会执行，如果析构函数在异常点之后执行了某些必要的动作比如释放某些资源，则这些动作不会执行，会造成诸如资源泄漏的问题。
* 通常异常发生时，c++的异常处理机制在异常的传播过程中会进行栈展开（stack-unwinding），因发生异常而逐步退出复合语句和函数定义的过程，被称为栈展开。在栈展开的过程中就会调用已经在栈构造好的对象的析构函数来释放资源，此时若其他析构函数本身也抛出异常，则前一个异常尚未处理，又有新的异常，会造成程序崩溃。





#### C++有哪几种的构造函数

* 默认构造函数：有了有参的构造了，编译器就不提供默认的构造函数
* 初始化构造函数：对象不存在，没用别的对象初始化，在创建一个新的对象时调用构造函数
* 拷贝构造函数：对象不存在，但是使用别的已经存在的对象来进行初始化

    * 赋值构造函数默认实现的是值拷贝（浅拷贝）

    * 什么时候用到拷贝构造函数
        * 对一个对象做显示的初始化操作，X xx = x；
        * 当对象被当做参数交给某个函数时；
        * 当函数传回一个类对象时（有时候有优化的）

    * 什么时候编译器合成一个拷贝构造函数
        * 如果一个类没有拷贝构造函数，但是含有一个类类型的成员变量，该类型含有拷贝构造函数，此时 编译器会为该类合成一个拷贝构造函数；
        * 如果一个类没有拷贝构造函数，但是该类继承自含有拷贝构造函数的基类，此时编译器会为该类合成一个拷贝构造函数；
        * 如果一个类没有拷贝构造函数，但是该类声明或继承了虚函数，此时编译器会为该类合成一个拷 构造函数；
        * 如果一个类没有拷贝构造函数，但是该类含有虚基类，此时编译器会为该类合成一个拷贝构造函数；

    *  如何禁止程序自动生成拷贝构造函数？
        * 自己声明一个
        * private
        * delete

    * 为什么拷贝构造函数必须传引用不能传值？
        * 拷贝构造函数的参数必须使用引用传递，如果传值就又会调用拷贝构造函数，无限递归了

* 移动构造函数（move和右值引用）

    * C++引入了移动构造函数，专门处理用 a 初始化 b后，就将a析构的情况
        * 避免了新空间的分配，大大降低了构造成本

    * 拷贝构造函数中，对于指针，我们一定要采用深层复制，而移动构造函数中，对于指针，我们采用浅层复制；

        * 浅拷贝：又称值拷贝，将源对象的值拷贝到目标对象中去，本质上来说源对象和目标对象共用一份实体，只是所引用的变量名不同，地址其实还是相同的。

        * 深拷贝，拷贝的时候先开辟出和源对象大小一样的空间，然后将源对象里的内容拷贝到目标对象中去，这样两个指针就指向了不同的内存位置。
* 委托构造函数

    * C++11 新增
    * 委托构造函数的**成员初始值列表**只有一个**唯一的参数**，就是构造函数(当然不能是当前的构造函数)
    * 当被委托的构造函数的函数体中如果有代码，那么会先执行完函数体的代码，才会回到委托构造函数。
    * 优点：简化构造函数的书写，提高代码的可维护性，避免代码冗余膨胀
    * 缺点：
        * 在委托其他构造函数后，不能再进行成员列表初始化，而只能在函数体内对其他成员变量进行赋值。
        * 只能委托一个构造函数，不能委托多个
        * 不要形成委托坏。

* 转换构造函数：用于将其他类型的变量，隐式转换为本类对象





#### nullptr 可以调用成员函数吗？

能，因为在**编译时对象**就绑定了**函数地址**，和指针空不空没关系。

```plaintext
//给出实例
class animal{
public:
    void sleep(){ cout << "animal sleep" << endl; }
    void breathe(){ cout << "animal breathe haha" << endl; }
};
class fish :public animal{
public:
    void breathe(){ cout << "fish bubble" << endl; }
};
int main(){
    animal *pAn=nullptr;
    pAn->breathe();   // 输出：animal breathe haha
    fish *pFish = nullptr;
    pFish->breathe(); // 输出：fish bubble
    return 0;
}  
```

pAn->breathe();编译的时候，函数的地址就和指针pAn绑定了；

调用breath(*this), this就等于pAn。

由于函数中没有需要解引用this的地方，所以函数运行不会出错

但是若用到this，因为this=nullptr，运行出错。



#### 谈谈成员初始化列表

赋值初始化，通过在函数体内进行赋值初始化

* 在所有的数据成员被分配内存空间后才进行的
* 会产生临时对象，效率低，如果有些成员是类的话还会相当于构造函数 + 赋值



列表初始化，在冒号后使用初始化列表进行初始化。

* 在函数体之前进行

* 纯粹的初始化，效率高

* 什么时候必须用

    * 当初始化一个引用成员变量时；
    * 初始化一个const成员变量时；（初始化列表是在编译的时候就指定了值，const成员不可以在运行的时候初始化）
    * 当调用一个基类的构造函数，而构造函数拥有一组参数时
    * 当调用一个成员类的构造函数，而他拥有一组参数；

* 做了什么

    * 编译器会一一操作初始化列表，以适当的顺序在构造函数之内安插初始化操作，并且在任何显示用户代码之前；
    * list中的项目顺序是由类中的成员声明顺序决定的，不是由初始化列表的顺序决定的；

    

#### 谈谈空类

sizeof(空类）

* 为了让每个实例有独一无二的地址会往空类里加一个字节，所以sizeof(空类）大小为 1
* 如果空类里有虚函数
    * 对象里有一个指向虚函数表的指针
    * 类会有一张虚函数表，并且代替 1 字节的占位符

默认生成的成员函数

* 默认构造函数（无参）
* 拷贝构造函数
* 析构函数（非虚）
* 赋值运算符
* 两个取址运算符



#### 什么情况会自动生成默认构造函数？

* 如果一个类没有任何构造函数，但他含有一个成员对象，该成员对象含有默认构造函数，那么编译器就为该类合成一个默认构造函数，因为不合成一个默认构造函数那么该成员对象的构造函数不能调用；不过这个合成操作只有在构造函数真正被需要的时候才会发生；如果一个类A含有多个成员类对象的话，那么类A的每一个构造函数必须调用每一个成员对象的默认构造函数而且必须按照类对象在类A中的声明顺序进行；
* 没有任何构造函数的类派生自一个带有默认构造函数的基类，那么需要为该派生类合成一个构造函数，只有这样基类的构造函数才能被调用；
* 带有虚函数的类，虚函数的引入需要进入虚表，指向虚表的指针，该指针是在构造函数中初始化的，所以没有构造函数的话该指针无法被初始化；
* 带有一个虚基类的类

需要注意的是：

* 默认构造不一定是合成的，也可以是用户自定义的

* 并不是任何没有构造函数的类都会合成一个构造函数
* 编译器合成出来的构造函数并不会显示设定类内的每一个成员变量
* 合成的默认构造函数中，只有基类子对象和成员类对象会被初始化。所有其他的非静态数据成员都不会被初始化。



#### 三/五/零之法则

三之法则：如果某个类需要用户定义的析构函数、用户定义的复制构造函数或用户定义的复制赋值运算符，那么它几乎肯定需要全部三者。（只定义了析构函数，编译器将自动为我们生成拷贝构造函数和默认构造函数。）

五之法则：任何想要移动语义的类必须声明全部五个特殊成员函数 (析构函数、拷贝构造、赋值运算、移动拷贝构造、移动赋值运算)：

零之法则：有自定义析构函数、复制/移动构造函数或复制/移动赋值运算符的类应该专门处理所有权

当有意将某个基类用于多态用途时，可能需要将它的析构函数声明为公开的虚函数。由于这会阻拦隐式移动（并弃用隐式复制）的生成，因而必须将各特殊成员函数声明为预置的





#### 构造函数、拷贝构造函数和赋值操作符的区别

**构造函数**

对象不存在，没用别的对象初始化，在创建一个新的对象时调用构造函数

**拷贝构造函数**

对象不存在，但是使用别的已经存在的对象来进行初始化

**赋值运算符**

对象存在，用别的对象给它赋值，这属于重载“=”号运算符的范畴，“=”号两侧的对象都是已存在的

* 拷贝构造函数是函数，赋值运算符是运算符重载。
* 拷贝构造函数会生成新的类对象，赋值运算符不能。
* 拷贝构造函数是直接构造一个新的类对象，所以在初始化对象前不需要检查源对象和新建对象是否相同；赋值运算符需要上述操作并提供两套不同的复制策略，另外赋值运算符中如果原来的对象有内存分配则需要先把内存释放掉。
* 形参传递是调用拷贝构造函数（调用的被赋值对象的拷贝构造函数），但并不是所有出现"="的地方都是使用赋值运算符，如下：

注：类中有指针变量时要重写析构函数、拷贝构造函数和赋值运算符。



#### 谈谈拷贝初始化与直接初始化？

* 当用于类类型对象时，初始化的拷贝形式和直接形式有所不同：直接初始化直接调用与实参匹配的构造函数（有可能是拷贝构造函数），拷贝初始化总是调用拷贝构造函数。拷贝初始化首先使用指定构造函数创建一个临时对象，然后用拷贝构造函数将那个临时对象拷贝到正在创建的对象。举例如下

```plaintext
string str1("I am a string");//语句1 直接初始化
string str2(str1);//语句2 直接初始化，str1是已经存在的对象，直接调用拷贝构造函数对str2进行初始化
string str3 = "I am a string";//语句3 拷贝初始化，先为字符串”I am a string“创建临时对象，再把临时对象作为参数，使用拷贝构造函数构造str3
string str4 = str1;//语句4 拷贝初始化，这里相当于隐式调用拷贝构造函数，而不是调用赋值运算符函数
```

* 为了提高效率，允许编译器跳过创建临时对象这一步，

 直接调用构造函数构造要创建的对象，这样就完全等价于

 直接初始化了

 （语句1和语句3等价），但是需要辨别两种情况。

* 当拷贝构造函数为private时：语句3和语句4在编译时会报错
* 使用explicit修饰构造函数时：如果构造函数存在隐式转换，编译时会报错

#### 解释一下什么是trivial destructor

“trivial destructor”一般是指用户没有自定义析构函数，而由系统生成的，这种析构函数在《STL源码解析》中成为“无关痛痒”的析构函数。

反之，用户自定义了析构函数，则称之为“non-trivial destructor”，这种析构函数**如果申请了新的空间一定要显式的释放，否则会造成内存泄露**

对于trivial destructor，如果每次都进行调用，显然对效率是一种伤害，如何进行判断呢？

《STL源码解析》中给出的说明是：

> 首先利用value_type()获取所指对象的型别，再利用__type_traits判断该型别的析构函数是否trivial，若是(__true_type)，则什么也不做，若为(__false_type)，则去调用destory()函数

也就是说，在实际的应用当中，STL库提供了相关的判断方法**__type_traits**，感兴趣的读者可以自行查阅使用方式。除了trivial destructor，还有trivial construct、trivial copy construct等，如果能够对是否trivial进行区分，可以采用内存处理函数memcpy()、malloc()等更加高效的完成相关操作，提升效率。

### 虚函数

#### 哪些函数不能是虚函数？

常见的不能声明为虚函数的有：

* 普通函数（非成员函数）
* 静态成员函数
* 内联成员函数
* 构造函数
* 友元函数。

**为什么C++不支持普通函数为虚函数？**

   普通函数（非成员函数）只能被overload，不能被override，声明为虚函数也没有什么意思，因此编译器会在编译时绑定函数。

**为什么C++不支持构造函数为虚函数？**

这个原因很简单，主要是从语义上考虑，所以不支持。因为构造函数本来就是为了明确初始化对象成员才产生的，然而virtual function主要是为了再不完全了解细节的情况下也能正确处理对象。另外，virtual函数是在不同类型的对象产生不同的动作，现在对象还没有产生，如何使用virtual函数来完成你想完成的动作。（这不就是典型的悖论）

构造函数用来创建一个新的对象,而虚函数的运行是建立在对象的基础上,在构造函数执行时,对象尚未形成,所以不能将构造函数定义为虚函数

1. 从存储空间角度：虚函数对应一个vtale,这个表的地址是存储在对象的内存空间的。如果将构造函数设置为虚函数，就需要到vtable 中调用，可是对象还没有实例化，没有内存空间分配，如何调用。（悖论）
2. 从使用角度：虚函数主要用于在信息不全的情况下，能使重载的函数得到对应的调用。构造函数本身就是要初始化实例，那使用虚函数也没有实际意义呀。所以构造函数没有必要是虚函数。虚函数的作用在于通过父类的指针或者引用来调用它的时候能够变成调用子类的那个成员函数。而构造函数是在创建对象时自动调用的，不可能通过父类的指针或者引用去调用，因此也就规定构造函数不能是虚函数。
3. 从实现上看，vbtl 在构造函数调用后才建立，因而构造函数不可能成为虚函数。从实际含义上看，在调用构造函数时还不能确定对象的真实类型（因为子类会调父类的构造函数）；而且构造函数的作用是提供初始化，在对象生命期只执行一次，不是对象的动态行为，也没有太大的必要成为虚函数。

**为什么C++不支持内联成员函数为虚函数？**

其实很简单，那内联函数就是为了在代码中直接展开，减少函数调用花费的代价，虚函数是为了在继承后对象能够准确的执行自己的动作，这是不可能统一的。（再说了，*inline函数在编译时被展开，虚函数在运行时才能动态的绑定函数*）

内联函数是在编译时期展开,而虚函数的特性是运行时才动态联编,所以两者矛盾,不能定义内联函数为虚函数

**为什么C++不支持静态成员函数为虚函数？**

这也很简单，静态成员函数对于每个类来说只有一份代码，所有的对象都共享这一份代码，他也没有要动态绑定的必要性。

静态成员函数属于一个类而非某一对象,没有this指针,它无法进行对象的判别

**为什么C++不支持友元函数为虚函数？**

因为C++不支持友元函数的继承，对于没有继承特性的函数没有虚函数的说法。

#### 虚析构函数的作用

虚析构函数，是将基类的析构函数声明为virtual，举例如下：

```cpp
class TimeKeeper
{
public:    
    TimeKeeper() {}        
    virtual ~TimeKeeper() {}    
};
```

**虚析构函数的主要作用是防止内存泄露。**

定义一个基类的指针p，在delete p时，如果基类的析构函数是虚函数，这时只会看p所赋值的对象，如果p赋值的对象是派生类的对象，就会调用派生类的析构函数（毫无疑问，在这之前也会先调用基类的构造函数，在调用派生类的构造函数，然后调用派生类的析构函数，基类的析构函数，所谓先构造的后释放）；如果p赋值的对象是基类的对象，就会调用基类的析构函数，这样就不会造成内存泄露。

如果基类的析构函数不是虚函数，在delete p时，调用析构函数时，只会看指针的数据类型，而不会去看赋值的对象，这样就会造成内存泄露。

1. 虚析构：将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。如果基类的析构函数不是虚函数，在特定情况下会导致派生来无法被析构。
2. 用派生类类型指针绑定派生类实例，析构的时候，不管基类析构函数是不是虚函数，都会正常析构
3. 用基类类型指针绑定派生类实例，析构的时候，如果基类析构函数不是虚函数，则只会析构基类，不会析构派生类对象，从而造成内存泄漏。为什么会出现这种现象呢，个人认为析构的时候如果没有虚函数的动态绑定功能，就只根据指针的类型来进行的，而不是根据指针绑定的对象来进行，所以只是调用了基类的析构函数；如果基类的析构函数是虚函数，则析构的时候就要根据指针绑定的对象来调用对应的析构函数了。

C++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。

#### 虚函数的代价

* 带有虚函数的类，每一个类会产生一个虚函数表，用来存储指向虚成员函数的指针，增大类；

* 带有虚函数的类的每一个对象，都会有有一个指向虚表的指针，会增加对象的空间大小；

* 虚函数难以内联，因为内联函数在编译阶段进行替代，而虚函数在运行阶段才能确定到底是采用哪种函数，虚函数一般不是内联函数。

* Cache命中率不够好，一般函数可能编译后的指令就在当前函数地址附近，这样很可能在调用前目标函数代码已经被载入指令cache. 但是虚拟函数不在cache中的概率高。而且一调函数就可能在cache中载入虚函数表，如果这个虚函数又调用其它的虚函数，那么可能又得载入到cache中导致cache被占用，指令和数据的cache命中率下降

* 编译器不好优化。因为编译器只知道你要调用的是一个不确定的地址处的函数，没法知道更多细节，也就没法替你做更多优化

* 查找虚表有一定损耗（影响小）

#### 虚函数表放在内存的什么区，其中的内容什么时候写进去的，虚表指针初始化时间，怎么查找虚函数的？

虚表：

* 编译时构造完成，在构造函数执行之前
* 存储在只读数据段（.rodata)，也就是内存模型中的常量区

虚表指针：

* 在对类进行实例化，构造函数执行时对虚表指针进行初始化
* 存储在对象内存布局最前面，位于代码段(.text) ，也就是内存模型中的代码去

查找过程：

![image-20220223220332562](https://s2.loli.net/2022/02/23/5Qglf4ATHNROqMm.png)

* 只要类里面有虚函数，类里就会有一个指针（无论有多少个虚函数），这个指针就是虚指针
* 父类有虚函数，子类也一定有。继承会把数据和函数的调用权都继承下来
* 当我们用指针调用的时候会发生动态绑定，首先通过指针找到`vptr`，然后找到`vtbl`，最后调用要求的函数

我们可以用C来模拟动态绑定的路线

```cpp
//n是虚函数在虚函数表中的第几个，编译器按代码顺序放
(*(p->vptr)[n])(p);
(*p->vptr[n])(p);
```



#### 说说C++中虚函数与纯虚函数？

1. 虚函数和纯虚函数可以定义在同一个类中，含有纯虚函数的类被称为抽象类，而只含有虚函数的类不能被称为抽象类。

2. 虚函数可以被直接使用，也可以被子类重载以后，以多态的形式调用，而纯虚函数必须在子类中实现该函数才可以使用，因为纯虚函数在基类有声明而没有定义。

3. 虚函数和纯虚函数都可以在子类中被重载，以多态的形式被调用。

4. 虚函数和纯虚函数通常存在于抽象基类之中，被继承的子类重载，目的是提供一个统一的接口。

5. 虚函数的定义形式：virtual{};纯虚函数的定义形式：virtual { } = 0;在虚函数和纯虚函数的定义中不能有static标识符，原因很简单，被static修饰的函数在编译时要求前期绑定,然而虚函数却是动态绑定，而且被两者修饰的函数生命周期也不一样。

6. 纯虚函数不可以实例化，但是可以用其派生类实例化

 虚函数的原理采用 vtable。类中含有纯虚函数时，其vtable 不完全，有个空位。即“纯虚函数在类的vftable表中对应的表项被赋值为0。也就是指向一个不存在的函数。由于编译器绝对不允许有调用一个不存在的函数的可能，所以该类不能生成对象。在它的派生类中，除非重写此函数，否则也不能生成对象。”所以纯虚函数不能实例化。
7. 纯虚函数是在基类中声明的虚函数，它要求任何派生类都要定义自己的实现方法，以实现多态性。
8. 定义纯虚函数是为了实现一个接口，用来规范派生类的行为，也即规范继承这个类的程序员必须实现这个函数。派生类仅仅只是继承函数的接口。纯虚函数的意义在于，让所有的类对象（主要是派生类对象）都可以执行纯虚函数的动作，但基类无法为纯虚函数提供一个合理的缺省实现。所以类纯虚函数的声明就是在告诉子类的设计者，“你必须提供一个纯虚函数的实现，但我不知道你会怎样实现它”。

#### 构造函数或析构函数中可以调用虚函数吗

不建议，构造函数和析构函数的时候对象都不是一个完整的状态，调用的话不安全也没意义



### this 指针

#### 谈谈 this 指针

* this指针是类的指针，指向对象的首地址。
* this指针只能在成员函数中使用，在全局函数、静态成员函数中都不能用this。
* this指针只有在成员函数中才有定义，且存储位置会因编译器不同有不同存储位置。
* 一个对象的this指针并不是对象本身的一部分，不会影响 sizeof(对象) 的结果



**this 指针的使用**

* this作用域是在类内部，当在类的非静态成员函数中访问类的非静态成员的时候（全局函数，静态函数中不能使用this指针），编译器会自动将对象本身的地址作为一个隐含参数传递给函数
* 在类的非静态成员函数中返回类对象本身的时候，直接使用 return *this；
* 当形参数与成员变量名相同时用于区分，如this->n = n （不能写成n = n）



#### this指针是什么时候创建的？

this在成员函数的开始执行前构造，在成员的执行结束后清除。



#### this指针存放在何处？堆、栈、全局变量，还是其他？

this指针会因编译器不同而有不同的放置位置。可能是栈，也可能是寄存器，甚至全局变量。在汇编级别里面，一个值只会以3种形式出现：立即数、寄存器值和内存变量值。不是存放在寄存器就是存放在内存中，它们并不是和高级语言变量对应的。

#### this指针是如何传递类中的函数的？绑定？还是在函数参数的首参数就是this指针？那么，this指针又是如何找到“类实例后函数的”

大多数编译器通过ecx（计数寄存器）寄存器传递this指针。事实上，这也是一个潜规则。一般来说，不同编译器都会遵从一致的传参规则，否则不同编译器产生的obj就无法匹配了。

在call之前，编译器会把对应的对象地址放到eax中。this是通过函数参数的首参来传递的。this指针在调用之前生成，至于“类实例后函数”，没有这个说法。类在实例化时，只分配类中的变量空间，并没有为函数分配空间。自从类的函数定义完成后，它就在那儿，不会跑的

#### this指针是如何访问类中的变量的？

this指针是类的指针，指向对象的首地址，就像其他指针一样访问



#### 我们只有获得一个对象后，才能通过对象使用this指针。如果我们知道一个对象this指针的位置，可以直接使用吗？

* this指针只有在成员函数中才有定义。因此，你获得一个对象后，也不能通过对象使用this指针。
* 而且一般情况 this 为右值，也没法通过 &this 获取位置





#### 每个类编译后，是否创建一个类中函数表保存函数指针，以便用来调用函数？

普通的类函数（不论是成员函数，还是静态函数）都不会创建一个函数表来保存函数指针。

只有虚函数才会被放到函数表中。但是，即使是虚函数，如果编译期就能明确知道调用的是哪个函数，编译器就不会通过函数表中的指针来间接调用，而是会直接调用该函数。

正是由于this指针的存在，用来指向不同的对象，从而确保不同对象之间调用相同的函数可以互不干扰。



#### this指针调用成员变量时，堆栈会发生什么变化？

当在类的非静态成员函数访问类的非静态成员时，编译器会自动将对象的地址传给作为隐含参数传递给函数，这个隐含参数就是this指针。

即使你并没有写this指针，编译器在链接时也会加上this的，对各成员的访问都是通过this的。

例如你建立了类的多个对象时，在调用类的成员函数时，你并不知道具体是哪个对象在调用，此时你可以通过查看this指针来查看具体是哪个对象在调用。This指针首先入栈，然后成员函数的参数从右向左进行入栈，最后函数返回地址入栈。

#### 如果在类的析构函数中调用delete this，会发生什么？

会导致堆栈溢出。原因很简单，delete的本质是“为将被释放的内存调用一个或多个析构函数，然后，释放内存”。显然，delete this会去调用本对象的析构函数，而析构函数中又调用delete this，形成无限递归，造成堆栈溢出，系统崩溃。

#### 在成员函数中调用delete this会出现什么问题？对象还可以使用吗？

在类对象的内存空间中，只有数据成员和虚函数表指针，并不包含代码内容，类的成员函数单独放在代码段中。

在调用成员函数时，隐含传递一个this指针，让成员函数知道当前是哪个对象在调用它。

当调用delete this时，类对象的内存空间被释放。在delete this之后进行的其他任何函数调用，只要不涉及到this指针的内容，都能够正常运行。一旦涉及到this指针，如操作数据成员，调用虚函数等，就会出现不可预期的问题。

delete this之后不是释放了类对象的内存空间了么，那么这段内存应该已经还给系统，不再属于这个进程。照这个逻辑来看，应该发生指针错误，无访问权限之类的令系统崩溃的问题才对啊？这个问题牵涉到操作系统的内存管理策略。delete this释放了类对象的内存空间，但是内存空间却并不是马上被回收到系统中，可能是缓冲或者其他什么原因，导致这段内存空间暂时并没有被系统收回。此时这段内存是可以访问的，你可以加上100，加上200，但是其中的值却是不确定的。当你获取数据成员，可能得到的是一串很长的未初始化的随机数；访问虚函数表，指针无效的可能性非常高，造成系统崩溃。

#### 成员函数里memset(this,0,sizeof(*this))会发生什么

有时候类里面定义了很多int,char,struct等c语言里的那些类型的变量，我习惯在构造函数中将它们初始化为0，但是一句句的写太麻烦，所以直接就memset(this, 0, sizeof *this);将整个对象的内存全部置为0。对于这种情形可以很好的工作，但是下面几种情形是不可以这么使用的；

* 类含有虚函数表：这么做会破坏虚函数表，后续对虚函数的调用都将出现异常；
* 类中含有C++类型的对象：例如，类中定义了一个list的对象，由于在构造函数体的代码执行之前就对list对象完成了初始化，假设list在它的构造函数里分配了内存，那么我们这么一做就破坏了list对象的内存。

#### 静态成员函数可以访问非静态的成员变量吗？

静态成员函数不接受隐含的 this 自变量。所以，它就无法访问自己类的非静态成员

如何访问：在静态函数的形参表里加上实例的地址；入参的时候把对象的指针传进来

