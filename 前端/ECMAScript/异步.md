# 异步

[JS 异步编程六种方案 - 掘金 (juejin.cn)](https://juejin.cn/post/6844903760280420366)



## 同步与异步



## 异步发展

### 回调函数

* 优点：简单，容易理解和实现
* 缺点：不利于代码阅读和维护，回调地狱；不能用 try catch 捕获错误，不能直接 return

### 事件监听

* 这种方式下，异步任务的执行不取决于代码的顺序，而取决于某个事件是否发生
* 优点：比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以"去耦合"，有利于实现模块化。
* 缺点：整个程序都要变成事件驱动型，运行流程会变得很不清晰。阅读代码的时候，很难看出主流程。

### 发布订阅

* 存在一个"信号中心"，某个任务执行完成，就向信号中心"发布"（publish）一个信号，其他任务可以向信号中心"订阅"（subscribe）这个信号，从而知道什么时候自己可以开始执行
* 可以通过查看“消息中心”，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。

### Promise/A+

* Promise 的三种状态
    * Pending----Promise对象实例创建时候的初始状态
    * Fulfilled----可以理解为成功的状态
    * Rejected----可以理解为失败的状态
* **这个承诺一旦从等待状态变成为其他状态就永远不能更改状态了**，比如说一旦状态变为 resolved 后，就不能再次改变为Fulfilled
* 当我们在构造 Promise 的时候，构造函数内部的代码是立即执行的
* promise的链式调用
    * 每次调用返回的都是一个新的Promise实例(这就是then可用链式调用的原因)
    * 如果then中返回的是一个结果的话会把这个结果传递下一次then中的成功回调
    * 如果then中出现异常,会走下一个then的失败回调
    * 在 then中使用了return，那么 return 的值会被Promise.resolve() 包装(见例1，2)
    * then中可以不传递参数，如果不传递会透到下一个then中(见例3)
    * catch 会捕获到没有捕获的异常
* 优点：不仅能够捕获错误，而且也很好地解决了回调地狱的问题
* 缺点：无法取消 Promise，错误需要通过回调函数捕获

### 生成器Generators/ yield

* Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同，Generator 最大的特点就是可以控制函数的执行。
* 语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。
* **Generator 函数除了状态机，还是一个遍历器对象生成函数**。
* **可暂停函数, yield可暂停，next方法可启动，每次返回的是yield后的表达式结果**。
* yield表达式本身没有返回值，或者说总是返回undefined。**next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值**。

### Async/Await

* 使用async/await，你可以轻松地达成之前使用生成器和co函数所做到的工作,它有如下特点：
    * async/await是基于Promise实现的，它不能用于普通的回调函数。
    * async/await与Promise一样，是非阻塞的。
    * async/await使得异步代码看起来像同步代码，这正是它的魔力所在。
* **一个函数如果加上 async ，那么该函数就会返回一个 Promise**
* Async/Await并发请求





