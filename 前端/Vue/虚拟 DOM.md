# 虚拟 DOM

## 对虚拟 DOM 的理解

从本质上来说，Virtual Dom是⼀个JavaScript对象，通过对象的⽅式来表示DOM结构。将⻚⾯的状态 抽象为JS对象的形式，配合不同的渲染⼯具，使跨平台渲染成为可能。通过事务处理机制，将多次 DOM修改的结果⼀次性的更新到⻚⾯上，从⽽有效的减少⻚⾯渲染的次数，减少修改DOM的重绘重排 次数，提⾼渲染性能。

虚拟DOM是对DOM的抽象，这个对象是更加轻量级的对 DOM的描述。它设计的最初⽬的，就是更好的 跨平台，⽐如Node.js就没有DOM，如果想实现SSR，那么⼀个⽅式就是借助虚拟DOM，因为虚拟 DOM本身是js对象。 在代码渲染到⻚⾯之前，vue会把代码转换成⼀个对象（虚拟 DOM）。以对象的 形式来描述真实DOM结构，最终渲染到⻚⾯。在每次数据发⽣变化前，虚拟DOM都会缓存⼀份，变化 之时，现在的虚拟DOM会与缓存的虚拟DOM进⾏⽐较。在vue内部封装了diff算法，通过这个算法来进 ⾏⽐较，渲染时修改改变的变化，原先没有发⽣改变的通过原先的数据进⾏渲染。 



另外现代前端框架的⼀个基本要求就是⽆须⼿动操作DOM，⼀⽅⾯是因为⼿动操作DOM⽆法保证程序 性能，多⼈协作的项⽬中如果review不严格，可能会有开发者写出性能较低的代码，另⼀⽅⾯更重要的 是省略⼿动DOM操作可以⼤⼤提⾼开发效率。

## 虚拟 DOM 的解析过程

虚拟DOM的解析过程： 

* ⾸先对将要插⼊到⽂档中的 DOM 树结构进⾏分析，使⽤ js 对象将其表示出来，⽐如⼀个元素对 象，包含 TagName、props 和 Children 这些属性。然后将这个 js 对象树给保存下来，最后再将 DOM ⽚段插⼊到⽂档中。 
* 当⻚⾯的状态发⽣改变，需要对⻚⾯的 DOM 的结构进⾏调整的时候，⾸先根据变更的状态，重新 构建起⼀棵对象树，然后将这棵新的对象树和旧的对象树进⾏⽐较，记录下两棵树的的差异。 
* 最后将记录的有差异的地⽅应⽤到真正的 DOM 树中去，这样视图就更新了。



## 为什么要虚拟 DOM

（1）保证性能下限，在不进⾏⼿动优化的情况下，提供过得去的性能

看⼀下⻚⾯渲染的流程：解析HTML -> ⽣成DOM -> ⽣成 CSSOM -> Layout -> Paint -> Compiler 

下⾯对⽐⼀下修改DOM时真实DOM操作和Virtual DOM的过程，来看⼀下它们重排重绘的性能消耗∶ 

* 真实DOM∶ ⽣成HTML字符串＋重建所有的DOM元素 
* 虚拟DOM∶ ⽣成vNode+ DOMDiff＋必要的dom更新 

Virtual DOM的更新DOM的准备⼯作耗费更多的时间，也就是JS层⾯，相⽐于更多的DOM操作它的消 费是极其便宜的。尤⾬溪在社区论坛中说道∶ 框架给你的保证是，你不需要⼿动优化的情况下，依然可 以给你提供过得去的性能。 



（2）跨平台

Virtual DOM本质上是JavaScript的对象，它可以很⽅便的跨平台操作，⽐如服务端渲染、uniapp等。

## 虚拟 DOM 真的比真实 DOM 性能好吗

* ⾸次渲染⼤量DOM时，由于多了⼀层虚拟DOM的计算，会⽐innerHTML插⼊慢。 
* 正如它能保证性能下限，在真实DOM操作的时候进⾏针对性的优化时，还是更快的。



## DIFF 算法的原理

在新⽼虚拟DOM对⽐时： 

* ⾸先，对⽐节点本身，判断是否为同⼀节点，如果不为相同节点，则删除该节点重新创建节点进⾏ 替换 

* 如果为相同节点，进⾏patchVnode，判断如何对该节点的⼦节点进⾏处理，先判断⼀⽅有⼦节点⼀ ⽅没有⼦节点的情况(如果新的children没有⼦节点，将旧的⼦节点移除) 

* ⽐较如果都有⼦节点，则进⾏updateChildren，判断如何对这些新⽼节点的⼦节点进⾏操作（diff 核⼼）。 

* 匹配时，找到相同的⼦节点，递归⽐较⼦节点 

    

在diff中，只对同层的⼦节点进⾏⽐较，放弃跨级的节点⽐较，使得时间复杂从$O(n^3 )$降低值 $O(n)$，也就 是说，只有当新旧children都为多个⼦节点时才需要⽤核⼼的Diff算法进⾏同层级⽐较。



## Vue 中 key 的作用

vue 中 key 值的作⽤可以分为两种情况来考虑： 

* 第⼀种情况是 v-if 中使⽤ key。由于 Vue 会尽可能⾼效地渲染元素，通常会复⽤已有元素⽽不是 从头开始渲染。因此当使⽤ v-if 来实现元素切换的时候，如果切换前后含有相同类型的元素，那么 这个元素就会被复⽤。如果是相同的 input 元素，那么切换前后⽤户的输⼊不会被清除掉，这样是 不符合需求的。因此可以通过使⽤ key 来唯⼀的标识⼀个元素，这个情况下，使⽤ key 的元素不会 被复⽤。这个时候 key 的作⽤是⽤来标识⼀个独⽴的元素。
* 第⼆种情况是 v-for 中使⽤ key。⽤ v-for 更新已渲染过的元素列表时，它默认使⽤“就地复⽤”的 策略。如果数据项的顺序发⽣了改变，Vue 不会移动 DOM 元素来匹配数据项的顺序，⽽是简单复 ⽤此处的每个元素。因此通过为每个列表项提供⼀个 key 值，来以便 Vue 跟踪元素的身份，从⽽ ⾼效的实现复⽤。这个时候 key 的作⽤是为了⾼效的更新渲染虚拟 DOM。



key 是为 Vue 中 vnode 的唯⼀标记，通过这个 key，diff 操作可以更准确、更快速 更准确：

* 因为带 key 就不是就地复⽤了，在 sameNode 函数a.key === b.key对⽐中可以避免就地 复⽤的情况。所以会更加准确。 
* 更快速：利⽤ key 的唯⼀性⽣成 map 对象来获取对应节点，⽐遍历⽅式更快

## 为什么不建议用 index 作为 key？

使⽤index 作为 key和没写基本上没区别，因为不管数组的顺序怎么颠倒，index 都是 0, 1, 2...这样排 列，导致 Vue 会复⽤错误的旧⼦节点，做很多额外的⼯作。